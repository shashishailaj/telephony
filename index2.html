<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>
      Web Telephony API
    </title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            class='remove'>
    </script>
    <script class="remove">
    /*Respec configuration*/
    var respecConfig = {
          specStatus:           "ED",
          shortName:            "telephony",
          noLegacyStyle:        true,
          publishDate:          "",
          previousPublishDate:  "",
          previousMaturity:     "",
          edDraftURI:           "http://www.w3.org/2012/sysapps/telephony/",
          // lcEnd:                "",
          crEnd:                "",
          editors: [
            { name: "Marcos Cáceres", company: "Mozilla",
                    companyURL: "http://www.tid.es/",
                    note: "patterns, correctness; integrator" },
            { name: "José M. Cantera", company: "Telefónica",
                    companyURL: "http://www.tid.es/",
                    note: "calls, tones" },
            { name: "Eduardo Fullea", company: "Telefónica",
                    companyURL: "http://www.tid.es/",
                    note: "calls, tones; integrator" },
            { name: "Zoltan Kis", company: "Intel",
                    companyURL: "http://www.intel.com/",
                    note: "calls, tones, services; integrator" },
            { name: "John Lyle", company: "University of Oxford",
                    companyURL: "http://www.cs.ox.ac.uk/",
                    note: "security and privacy"
            }
          ],
          inlineCSS:    true,
          noIDLIn:      true,
          // extraCSS:     ["../ReSpec.js/css/respec.css"],
          wg:           "System Applications Working Group",
          wgURI:        "http://www.w3.org/2012/sysapps/",
          wgPublicList: "public-sysapps",
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/58119/status",
          otherLinks: [{
            key: "Repository",
            data: [{
                    value: "We are on Github.",
                    href: "https://github.com/sysapps/telephony"
                }, {
                    value: "File a bug.",
                    href: "https://github.com/sysapps/telephony/issues"
                }, {
                    value: "Commit history.",
                   href: "https://github.com/sysapps/telephony/commits/gh-pages"
                }
            ]
        }]
    };
    </script>
    <style>
    /*HTML5 Tidy screws up if this line is missing.*/
    figure{
        display: block;
        width: auto;
        margin: 2em auto;
        text-align: center;
    }
    figcaption{
        display: block;
        margin-top: 1em;
    }                
    </style>
  </head>
  <body>
    <!-- - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - -->
    <section id="abstract">
      <p>
        This specification defines an API to manage telephone calls. A typical
        use case of the <cite>Web Telephony API</cite> is the implementation of
        a 'Dialer' application supporting multiparty calls and multiple
        telephony services.
      </p>
    </section>

    <!-- - - - - - - - - - -  Status of this document - - - - - - - - - - - -->
    <section id="sotd">
      <p>
        Implementors should be aware that this specification is not stable.
        <strong>Implementors who are not taking part in the discussions are
        likely to find the specification changing out from under them in
        incompatible ways.</strong> Vendors interested in implementing this
        specification before it eventually reaches the Candidate Recommendation
        stage should join the aforementioned mailing lists and take part in the
        discussions.
      </p>
      <p>
        Significant changes to this document since last publication are
        documented in the <a href="#Changes">Changes section</a>.
      </p>
    </section>

    <!-- - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - -->
    <section class="informative"> <h2>Introduction</h2>
      <p>
        The <cite>Web Telephony API</cite> allows applications to manage
        interaction with telephony call signaling, but does not handle audio
        channels management.
      </p>
      <p>
        A simple example for making a telephony call is provided below:
      </p>
      <pre title="Dialing a call" class="example highlight">
        navigator.telephony.dial('+1234567890').then(
            function(call) {
                call.onstatechange = stateHandler;
            },
            function(error) {
                console.log("Telephony error" + error.name);
            }
        );


        function stateHandler(TelephonyCall call) {
            if(telCall.state == 'active')
               window.console.log('Connected!');
            else if(telCall.state == 'disconnected') {
               window.console.log('Disconnected!');
               // update call history
            }
        }
      </pre>
      <p>
        A simple example for receiving a telephony call is provided below:
      </p>
      <pre title="Receiving calls" class="example highlight">
        navigator.telephony.onincoming = function(TelephonyCall call) {
            call.onstatechange = stateHandler;
            if(call.state == 'incoming') {
                call.accept().then(
                    function(call) {
                        console.log('Call from ' + call.remotePartyId + ' accepted');
                    },
                    function(error) {
                        console.log("Telephony error" + error.name);
                    }
                );
            }
        };
      </pre>
      <p>
        The use cases for this specification are collected in the <a href=
        'http://www.w3.org/wiki/System_Applications_WG:_Telephony_API'>wiki
        page</a> of this API.
      </p>
      <p>
        The following specifications informed the design of the <cite>Web
        Telephony API</cite>: for <abbr title=
        "Global System for Mobile Communications">GSM</abbr> the [[!GSM-CALL]]
        suite, for IMS/SIP the [[!IMS]] suite, for <abbr title=
        "Extensible Messaging and Presence Protocol ">XMPP</abbr> the
        [[!JINGLE]] specification.
        It is likely that the same API would work also for <abbr title=
        "Session Initiation Protocol">SIP</abbr> and <abbr title=
        "Extensible Messaging and Presence Protocol ">XMPP</abbr> calls,
        but IMS/SIP and XMPP are not explicitly supported in this version.
      </p>
      <p class='issue'>
        It is under discussion whether a system message should be propagated
        when a CDMA telephony call is active, since not all CDMA networks
        support concurrent services. Therefore, many applications will lose
        their data connection when the end user is in a voice call. However,
        such message should be sent when the data connection is lost for any
        reason, independently from this specification, so it could be monitored
        from one place.
      </p>
    </section>

    <!-- - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - -->
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in
        this specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]],
        as this specification uses that specification and terminology.
      </p>
    </section>

    <!-- - - - - - - - - - - - - -  Dependencies  - - - - - - - - - - - - - -->
    <section> <h2>Dependencies</h2>
      <p>
        This specification depends on the following interfaces and concepts
        defined in other specifications.
      </p>
      <p>
        The following dependencies are defined in [[!HTML]]:
        <dfn><code><a
        href="http://www.whatwg.org/specs/web-apps/current-work/#eventhandler">
        EventHandler</a></code></dfn> interface, <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#queue-a-task">queue
        a task</a></dfn>, <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#event-handlers">
        event handler</a></dfn>, <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#origin">origin</a>
        </dfn>,
        <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#task-source">task
        source</a></dfn>.
      </p>
      <p>
        The following dependencies are defined in [[!DOM4]]: the <dfn><a href=
        "http://dom.spec.whatwg.org/#event"><code>Event</code></a></dfn> and
        the <dfn><a href=
        "http://dom.spec.whatwg.org/#promise"><code>Promise</code></a></dfn>
        interfaces, the concepts of a <a href=
        "http://dom.spec.whatwg.org/#concept-resolver"><dfn>resolver</dfn></a>,
        <dfn><a href="http://dom.spec.whatwg.org/#concept-event-fire">fire an
        event</a></dfn>.
      </p>
    </section> <!-- Dependencies -->

    <!-- - - - - - - - - - -  Task Source - - - - - - - - - - - - - - - - - -->
    <section> <h2>Task Source</h2>
      <p>
        The <a>task source</a> for all <a title="queue a task">tasks queued</a>
        in this specification is the <dfn>telephony task source</dfn>.
      </p>
    </section>

    <!-- - - - - - - - - - - Extended interface Navigator - - - - - - - - - -->
    <section> <h2>Extensions to <code>Navigator</code> object</h2>
      <p>
        The <a>TelephonyManager</a> interface is exposed on [[!HTML]]'s
     <a href="http://www.whatwg.org/specs/web-apps/current-work/#dom-navigator">
        <code>Navigator</code></a> object.
      </p>
      <dl title="partial interface Navigator" class="idl">
        <dt>
          readonly attribute TelephonyManager telephony
        </dt>
      </dl>
      <!-- - - - - - - - - - - - telephony attribute  - - - - - - - - - - - -->
      <section> <h3>The <code>telephony</code> attribute</h3>
      <p>
        When getting the <dfn id="widl-Navigator-telephony">telephony</dfn>
        attribute, the user agent MUST return the <a>TelephonyManager</a>
        object, which provides telephony related functionality.
      </p>
      </section> <!-- telephony attribute -->
    </section> <!-- Navigator -->


    <!-- - - - - - - - - - - - Interface TelephonyManager - - - - - - - - - -->
    <section> <h2>The <a>TelephonyManager</a> Interface</h2>
      <p>
        The <dfn>TelephonyManager</dfn> interface provides access to telephony
        functionality related to <a>telephony service</a> management such as
        multiple SIM and later VoIP support,
        <a>telephony call</a> management such as managing the telephony call
        objects, sending [[!DTMF]] tones, retrieving emergency numbers, and
        helper functionality for parsing and dispatching telephony commands.
      </p>
      <dl title="TelephonyManager implements ServiceManager"   class="idl"></dl>
      <dl title="TelephonyManager implements CallManager"      class="idl"></dl>
      <dl title="TelephonyManager implements ToneManager"      class="idl"></dl>
      <dl title="TelephonyManager implements EmergencyManager" class="idl"></dl>
      <dl title="TelephonyManager implements CommandParser"    class="idl"></dl>
      <p>
        Each of these interfaces will be expanded in the following sections.
      </p>
    </section> <!-- TelephonyManager -->

    <!-- - - - - - - - - - - - - -  Telephony Services  - - - - - - - - - - -->
    <section> <h2>Telephony services</h2>
      <section> <h2>Definitions</h2>
      <section> <h3>Telephony service</h3>
      <p>
        A <dfn>telephony service</dfn> manages telephony operations associated
        with a subscriber identity, which is registered with a telephony
        service provider. For example, in cellular telephony, a telephony
        service is associated with <abbr title=
        "Subscriber Identity Module">SIM</abbr> card (Subscriber Identity
        Module). A telephony service can use different protocols for telephony
        signaling and media (e.g. GSM, CDMA, VoLTE, etc.) with the same
        subscriber identity.
      </p>
      </section>
      <section> <h3>Telephony service id</h3>
      <p>
        A user agent can access zero or more <a>telephony service</a>s.
        Each telephony service has a unique <dfn>telephony service id</dfn>,
        which identifies a <a>telephony service</a> together with a user
        identity in the system.
      </p>
      <p>
        Access to a telephony service by any <a>origin</a> is restricted by a
        security policy. See the <strong>Security and privacy considerations
        </strong> section for more details.
      </p>
      <p>
        In the API, telephony services are represented by a DOMString that maps
        to a <a>telephony service id</a> for each <a>telephony service</a>
        available to an <a>origin</a>.
      </p>
      <p>
        It is strongly RECOMMENDED that implementations <strong>do not</strong>
        use use the MSISDN as the telephony service id. The <abbr
        title="Mobile Subscriber Integrated Services Digital Network-Number">
        MSISDN</abbr> cannot guarantee uniqueness. For telephony services that
        make use of a SIM card, it is RECOMMENDED that the ICC-ID be used for
        the service identifier. For reducing fingerprinting, implementations MAY
        choose to use generated UUID's or SHA signatures as service identifiers,
        associated in the implementation to the internal service identifiers
        such as ICC-ID.
      </p>
      </section>
      <section> <h3>Default telephony service</h3>
      <p>
        The <dfn>default telephony service</dfn> is the <a>telephony
        service</a> that is used as default for the <a>origin</a> when the
        service is not specified in the methods of this API.
      </p>
      <p>
        If there is no <a>default telephony service</a> set for the
        <a>origin</a>, the user agent SHOULD use the underlying system's default
        telephony service, if available and if allowed by policy.
        On implementations that have access to a hardware modem, regulations may
        require supporting emergency number dialing from PIN dialog or dialer
        interface. In this case even in the absence of a SIM card (subscriber
        identity) the implementations MUST implement a telephony service
        associated with only emergency dialing capability, and set it as default
        telephony service id even when no SIM card is present.
        When not even emergency calls are possible (e.g. it is a purely IP based
        implementation and there is no cellular modem), the implementation MAY
        use <code>null</code> for default <a>telephony service id</a>.
        In this case, also the <a>telephony</a> attribute of the <a
        href="http://www.whatwg.org/specs/web-apps/current-work/#dom-navigator">
        <code>Navigator</code></a> object object should be <code>null</code>,
        i.e. no telephony functionality is available.
      </p>
      <p>
        The default telephony service can be changed by the user through the
        <code>changeDefaultService()</code> method of the
        <a><code>ServiceManager</code></a> interface.
      </p>
      </section>
      </section> <!-- definitions -->

      <!-- - - - - - - - -  ServiceManager WebIDL definitions - - - - - - - -->
      <section> <h2>The <a>ServiceManager</a> Interface</h2>
        <p>
          The <a>ServiceManager</a> interface manages the state of the
          <a>TelephonyService</a> objects.
        </p>
        <dl title="interface ServiceManager : EventTarget" class="idl">
          <dt> readonly attribute DOMString?   defaultServiceId        </dt>
          <dt> Promise setDefaultService(DOMString serviceId)          </dt>
          <dt> Promise getServiceIds()                                 </dt>
          <dt> TelephonyService? getService(DOMString serviceId)       </dt>
          <dt> attribute EventHandler onserviceadded                   </dt>
          <dt> attribute EventHandler onserviceremoved                 </dt>
          <dt> attribute EventHandler ondefaultservicechanged          </dt>
        </dl>

      <!-- - - - - - - - - - - ServiceManager Event handlers  - - - - - - - -->
      <section> <h2>Event handlers</h2>
        <p>
          The following are the <a>event handler</a>s implemented by the
          <a>ServiceManager</a> interface.
        </p>
        <table class="simple">
          <tr>
            <th>event handler    </th>
            <th>event name       </th>
            <th>event type       </th>
            <th>short description</th>
          </tr>
          <tr>
            <td><dfn id="widl-ServiceManager-onserviceadded">
                   <code>onserviceadded</code></dfn>
            </td>
            <td><dfn><code>serviceadded</code></dfn></td>
            <td><a>TelephonyServiceEvent</a></td>
            <td>handles a new enabled telephony service.</td>
          </tr>
          <tr>
            <td> <dfn id="widl-ServiceManager-onserviceremoved">
                   <code>onserviceremoved</code></dfn>
            </td>
            <td><dfn><code>serviceremoved</code></dfn></td>
            <td><a>TelephonyServiceEvent</a></td>
            <td>handles a disabled telephony service.</td>
          </tr>
          <tr>
            <td><dfn id="widl-ServiceManager-ondefaultchanged">
                   <code>ondefaultservicechanged</code></dfn>
            </td>
            <td><dfn><code>defaultservicechanged</code></dfn></td>
            <td><a>TelephonyServiceEvent</a></td>
            <td>handles the change of default telephony service.</td>
          </tr>
        </table>
      </section>

      <!-- - - - - - - - -  Telephony service changes - - - - - - - - - - - -->
      <section> <h3>Handling events for changes in telephony services</h3>
        <p>
          Telephony services can be added or removed from the system at any
          time (e.g., the user pops out the SIM card or adds a different SIM
          card; the user tells the system to only allow certain applications to
          access a particular telephony service, etc.).
        </p>
        <p>
          The functionality related to managing telephony services is described
          in the <a><code>ServiceManager</code></a> interface.
          <a><code>TelephonyManager</code></a> implements the the
          <a><code>ServiceManager</code></a> interface.
        </p>
        <p>
          When a <a>telephony service</a> is either added or removed in the
          system, or the <a>default telephony service</a> is changed, the user
          agent MUST run the steps to change the telephony service:
        </p>
        <ol id="steps-ServiceManager-change-events">
          <li>Let <var>event</var> be a new <a>TelephonyServiceEvent</a>, with
          the event name set to <code>serviceremoved</code> if the telephony
          service was removed, or <code>serviceadded</code> if it was added, or
          <code>defaultservicechanged</code> if the
          <a>default telephony service</a> has changed.
          This event does not bubble, is not cancelable, has no default action,
          and its <a>serviceId</a> attribute is set to the <a>telephony service
          id</a> of the <a>telephony service</a> that initiated this algorithm.
          </li>
          <li>If the service has been removed and it's been the default
          telephony service for the <a>origin</a>, then change default telephony
          service.
          </li>
          <li>
            <a>Queue a task</a> to fire an event <var>event</var> at the
            <a>TelephonyManager</a>.
          </li>
        </ol>
      </section>

      <!-- - - - - - - - - - -  Default Telephony Service - - - - - - - - - -->
      <section> <h3>The <a><code>defaultServiceId</code></a> property</h3>
        <p>
          When getting the <dfn id=
          "widl-ServiceManager-defaultServiceId">defaultServiceId</dfn>
          attribute, the user agent MUST return the <code>DOMString</code> that
          represents the <a>telephony service id</a> of the
          <a>default telephony service</a> (if any).
          Otherwise, it returns <code>null</code>.
        </p>
      </section>

      <!-- - - - - - - - - Setting the default TelephonyService - - - - - - -->
      <section> <h3>The <code>setDefaultService()</code> method</h3>
        <p>
          The <dfn id=
          "widl-ServiceManager-setDefaultService-Promise-DOMString-serviceId">
          setDefaultService()</dfn> method provides a means to change the
          <a>default telephony service</a> used by the user agent. When
          invoked, the user agent MUST run the the following steps:
        </p>
        <ol id="steps-set-default-service">
          <li>Let <var>serviceId</var> be the first argument passed to
          this operation.
          </li>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
          object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
          asynchronously.
          </li>
          <li>If <var>serviceId</var> does not exactly match the identifier of
          any <a>telephony service</a> known to the user agent,run the following
          error steps and terminate this algorithm:
            <ol id="steps-promise-error">
              <li>Let <var>error</var> be a new <a href=
              "http://dom.spec.whatwg.org/#domerror"><code>DOMError</code></a>
              object whose name is <a href=
              "http://dom.spec.whatwg.org/#notfounderror">
              <code>NotFoundError</code></a>.
              </li>
              <li>Invoke <var>resolver</var>'s reject(value) method with <var>
                error</var> as the value argument.
              </li>
            </ol>
          </li>
          <li>If <var>serviceId</var> exactly matches the
            <a>telephony service id</a> of the current
            <a>default telephony service</a>, run the following
            sub-steps and terminate this algorithm:
            <ol>
              <li>Invoke <var>resolver</var>'s accept(value) method with
                  <var>serviceId</var> as the value argument.
              </li>
            </ol>
          </li>
          <li>Otherwise, make a request to the underlying system to change from
          the current default telephony service to the one identified by
          <var>serviceId</var>.
          </li>
          <li>Wait for response from the underlying system.
          </li>
          <li>If it's not possible to change the default telephony service for
          whatever reason: timeout, security, etc., then run the following
          sub-steps and terminate this algorithm:
            <ol>
              <li>Let <var>error</var> be a new DOMError object whose name is
              <code>"NoModificationAllowedError"</code>.
              </li>
              <li>Call <var>resolver</var>'s <code>reject(value)</code> method
              with <var>error</var> as the <var>value</var> argument.
              </li>
            </ol>
          </li>
          <li>Otherwise, <a>queue a task</a> to:
            <ol>
              <li>Change the <a>defaultServiceId</a> attribute to the
              <a>telephony service id</a> of the new <a>default telephony
              service</a>.
              </li>
              <li>invoke <var>resolver</var>'s <code>accept(value)</code> method
              with the id of the new default service as <var>value</var>
              argument.
              </li>
              <li>
                <a>Fire an event</a> named <code>defaultservicechanged</code>
                at the <a>telephony</a> attribute of the navigator object.
              </li>
            </ol>
          </li>
        </ol>
      </section> <!-- setDefaultService -->

      <!-- - - - - - - - - - - - getServiceIds()  - - - - - - - - - - - - - -->
      <section> <h3>The <code>getServiceIds()</code> method</h3>
        <p>
          The <dfn id="widl-ServiceManager-getServiceIds-Promise">
          getServiceIds()</dfn> method provides a means to retrieve the
          list of <a>telephony service id</a>s representing enabled
          <a>telephony service</a>s. When invoked, the user agent MUST run the
          following steps:
        </p>
        <ol id="steps-get-serviceids">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Make a request to the underlying system to retrieve the list of
            <a>telephony service id</a>s of enabled <a>telephony service</a>s.
          </li>
          <li>Wait for response from the underlying system.
          </li>
          <li>If it's not possible to retrieve the list of telephony service
          identifiers for whatever reason: timeout, security, etc., then run the
          following sub-steps and terminate this algorithm:
            <ol>
              <li>Let <var>error</var> be a new DOMError object whose name is
              <code>"NoModificationAllowedError"</code>.
              </li>
              <li>Call <var>resolver</var>'s <code>reject(value)</code> method
              with <var>error</var> as the <var>value</var> argument.
              </li>
            </ol>
          </li>
          <li>Otherwise, <a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept(value)</code> method with the sequence of id's as
            <var>value</var> argument, even if the list is empty.
          </li>
        </ol>
      </section> <!-- getServiceIds -->

      <!-- - - - - - - - - - - - getService() - - - - - - - - - - - - - - - -->
      <section> <h3>The <code>getService()</code> method</h3>
        <p>
          The <dfn
       id="widl-ServiceManager-getService-TelephonyService-DOMString-serviceId">
          getService()</dfn> method provides a means to synchronously retrieve
          the <a><code>TelephonyService</code></a> object corresponding to a
          <a>telephony service id</a>. When invoked, the user agent MUST run the
          following steps:
        </p>
        <ol id="steps-get-service">
          <li>Let <var>service</var> be the <a><code>TelephonyService</code></a>
            object whose <code>serviceId</code> property is equal to
            <var>service</var>. Implementations SHOULD maintain an associative
            list of <a>telephony service id</a>s to
            <a><code>TelephonyService</code></a> objects.
          </li>
          <li>Return <var>service</var>.
          </li>
        </ol>
      </section> <!-- getServiceIds -->
      </section> <!-- ServiceManager -->

      <!-- - - - - - - - - - Interface TelephonyServiceEvent  - - - - - - - -->
      <section> <h2>The <a>TelephonyServiceEvent</a> Interface</h2>
        <p>
          Defines a telephony event for notifying a changed <a>telephony
          service</a>.
        </p>
        <dl title=
        "[Constructor(DOMString type, optional TelephonyServiceEventInit eventInitDict)]interface TelephonyServiceEvent : Event"
        class="idl">
          <dt>readonly attribute DOMString serviceId</dt>
        </dl>
        <!-- - - - - - - - - - serviceId attribute  - - - - - - - - - - - - -->
        <section>
          <h3>The <code>serviceId</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "widl-TelephonyServiceEvent-serviceId">serviceId</dfn>, the user
            agent MUST return the <a>telephony service id</a> of the
            <a>telephony service</a> that triggered the event.
          </p>
        </section>
        <!-- - - - - - - - - - TelephonyServiceEventInit dictionary - - - - -->
        <section>
          <h3><code>TelephonyServiceEventInit</code> dictionary</h3>
          <dl title="dictionary TelephonyServiceEventInit : EventInit" class=
          "idl">
            <dt>DOMString serviceId</dt>
          </dl>
          <!-- - - - - - - - - - serviceId member - - - - - - - - - - - - - -->
          <section>
            <h3>The <code>serviceId</code> member</h3>
            <p>
              The <dfn id=
              "widl-TelephonyServiceEventInit-serviceId">serviceId</dfn> member
              represents the <a>telephony service id</a> of a <a>telephony
              service</a>.
            </p>
          </section><!-- serviceId member -->
        </section><!-- TelephonyServiceEventInit interface -->
      </section><!-- interface TelephonyServiceEvent -->

      <!-- - - - - - - - - - Interface TelephonyService - - - - - - - - - - -->
      <section> <h2>The <a>TelephonyService</a> Interface</h2>
        <p>The interface which manages a given <a>telephony service</a>s present
          in the system. Different services may provide different set of
          interfaces for managing service specific settings, depending on
          protocol and the current telephony network to which the device is
          connected.
        </p>
        <dl title="[NoInterfaceObject]
          interface TelephonyService: EventHandler"
          class="idl">
          <dt>readonly attribute DOMString            serviceId     </dt>
          <dt>readonly attribute boolean              enabled       </dt>
          <dt>readonly attribute boolean              emergencyOnly </dt>
          <dt>readonly attribute TelephonyProtocol    protocol      </dt>
          <dt>readonly attribute TelephonyServiceType serviceType   </dt>
          <dt>         attribute DOMString            displayName   </dt>
          <dt>readonly attribute DOMString            provider      </dt>
          <dt>Promise setEnabled(boolean enabled)                   </dt>
        </dl>

        <!-- - - - - - - - - TelephonyService.serviceId - - - - - - - - - - -->
        <section> <h3>The <code>serviceId</code> property</h3>
          <p>
            It MUST return the <a>telephony service id</a> of the
            <a>telephony service</a>.
          </p>
        </section> <!--serviceId -->

        <!-- - - - - - - - - TelephonyService.enabled - - - - - - - - - - - -->
        <section> <h3>The <code>enabled</code> property</h3>
          <p>
            It MUST return or set the enabled state of the service, i.e.
            <code>TRUE</code> if the service is enabled, and <code>FALSE</code>
            if the service is disabled.
          </p>
        </section> <!-- enabled -->

        <!-- - - - - - - - - TelephonyService.emergencyOnly - - - - - - - - -->
        <section> <h3>The <code>emergencyOnly</code> property</h3>
          <p>
            It MUST return <code>TRUE</code> if the service permits only
            emergency calls, and <code>FALSE</code> otherwise.
          </p>
        </section> <!-- emergencyOnly -->

        <!-- - - - - - - - - TelephonyService.displayName - - - - - - - - - -->
        <section> <h3>The <code>displayName</code> property</h3>
          <p>
            It MUST return the string value as displayed to the user by the
            application. It MAY be a localization string identifier.
          </p>
        </section> <!-- displayName -->

        <!-- - - - - - - - - TelephonyService.provider  - - - - - - - - - - -->
        <section> <h3>The <code>provider</code> property</h3>
          <p>
            It MUST return the name of the service provider, which SOULD be
            unique in the telephony domain. A provider may have multiple
            services provisioned, therefore multiple
            <code>TelephonyService</code> objects MAY have the same provider.
          </p>
        </section> <!-- provider -->

        <!-- - - - - - - - - TelephonyService.protocol  - - - - - - - - - - -->
        <section> <h3>The <code>protocol</code> property</h3>
          <p>
            The following values are supported as telephony protocols:
            <ul>
              <li><code>"unknown"</code>: protocol not known</li>
              <li><code>"gsm"</code>: used for GSM and related protocols</li>
              <li><code>"cdma"</code>: used for CDMA and related protocols</li>
              <li><code>"sip"</code>: used for SIP based protocols and
                extensions</li>
              <li><code>"xmpp"</code>: used for XMPP based protocols and
                extensions.
              </li>
          </p>
          </p>
          <dl title="enum TelephonyProtocol" class="idl">
            <dt>unknown</dt>
            <dt>gsm</dt>
            <dt>cdma</dt>
            <dt>sip</dt>
            <dt>xmpp</dt>
          </dl>
        </section> <!-- protocol -->

        <!-- - - - - - - - - TelephonyService.serviceType - - - - - - - - - -->
        <section> <h3>The <code>serviceType</code> property</h3>
          <p>
            The following values are supported as <a>telephony service</a> type:
            <ul>
              <li><code>"unknown"</code>: service type not known</li>
              <li><code>"hw"</code>: hardware modem</li>
              <li><code>"hfp"</code>: external modem used through Bluetooth
                Hands Free Profile (for control and also handles audio)
              </li>
              <li><code>"sap"</code>: external modem used through Bluetooth SIM
                Access Profile (only for control, audio is local)
              </li>
              <li><code>"sw"</code>: software modem</li>
              <li><code>"voip"</code>: VoIP account.</li>
          </p>
          <dl title="enum TelephonyServiceType" class="idl">
            <dt>unknown</dt>
            <dt>hw</dt>
            <dt>hfp</dt>
            <dt>sap</dt>
            <dt>sw</dt>
            <dt>voip</dt>
          </dl>
        </section> <!-- serviceType -->

        <!-- - - - - - - - - TelephonyService.setEnabled()  - - - - - - - - -->
        <section> <h3>The <code>setEnabled()</code> method</h3>
          <p>
            The <dfn
            id="widl-TelephonyService-setEnabled-Promise-boolean-enabled">
            setEnabled()</dfn> method enables or disabled the
            <a>telephony service </a>. When invoked, the user agent MUST run the
            following steps:
          </p>
          <ol id="steps-telephonyservice-setenabled">
            <li>Let <var>enabled</var> be the first argument passed to
              this operation.
            </li>
            <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated resolver.
            </li>
            <li>Return <var>promise</var> and continue the following steps
              asynchronously.
            </li>
            <li>Make a request to the underlying system to enable the
              <a>telephony service</a> if <var>enabled</var> is
              <code>TRUE</code>, and disable it otherwise.
            </li>
            <li>Wait for response from the underlying system.
            </li>
            <li>If it was not possible to complete the request for whatever
              reason: timeout, security, etc., then run the following sub-steps
              and terminate this algorithm:
              <ol>
                <li>Let <var>error</var> be a new DOMError object whose name is
                <code>"NoModificationAllowedError"</code>.
                </li>
                <li>Call <var>resolver</var>'s <code>reject(value)</code> method
                with <var>error</var> as the <var>value</var> argument.
                </li>
              </ol>
            </li>
            <li>Otherwise, when the request has been completed,
              <a>queue a task</a> to invoke <var>resolver</var>'s
              <code>accept()</code> method. Parallel to this, implementations
              MUST also follow the
              <a href="steps-servicemanager-change-events">steps</a> for
              handling service change events.
            </li>
          </ol>
        </section> <!-- setEnabled() -->

        <!-- - - - - - - - TelephonyService extension note  - - - - - - - - -->
        <section> <h3>Extension possibilities</h3>
        <section class="note">
          <p>
            In the future, <a>TelephonyService</a> could be extended e.g. in
            the following way:
          </p>
          <dl title="CellularService implements TelephonyService" class="idl">
          </dl>
          <dl title="[NoInterfaceObject]
          interface CellularService" class="idl">
          <dt>readonly attribute SimInfo?               simInfo     </dt>
          <dt>readonly attribute SimSettings?           simSettings </dt>
          <dt>readonly attribute TelephonyNetwork?      network     </dt>
          <dt>readonly attribute CallForwarding?        forwarding  </dt>
          <dt>readonly attribute CallBarring?           barring     </dt>
          <dt>readonly attribute CallMeters?            meters      </dt>
          <dt>readonly attribute SupplementaryServices? ss          </dt>
          <dt>//... and other interfaces...                         </dt>
          </dl>
          <p>Depending on implementation, on operator network support and on
          settings, some of these interfaces may not be available, in which case
          the value of the corresponding attributes is set to <code>null</code>.
          </p>
        </section> <!-- note -->
        </section> <!-- extensions -->
      </section> <!-- TelephonyService -->
    </section> <!-- Telephony services -->

    <!-- - - - - - - - - - - - - - Telephony Calls  - - - - - - - - - - - -->
    <section> <h2>Telephony Calls</h2>
      <section> <h3>Definitions</h3>
      <section><h3>Telephony call</h3>
      <p>
          A <dfn>telephony call</dfn> results from a <a>telephony service</a>'s
          attempt to establish a connection for communication between two or
          more parties. Telephony calls involving more than two parties are
          referred to as a <dfn>multiparty call</dfn>.
      </p>
      </section>
      <section><h3>Call state</h3>
      <p>
          In the process of establishing and maintaining a connection between
          multiple parties, a telephony call transitions through various
          <a title="call state">call states</a>. A <a>telephony call</a> is
          always in a defined <a>call state</a>, which can change over time.
      </p>
      </section>
      <section><h3>Outbound and inbound call</h3>
      <p>
          Telephony calls initiated by a telephony service of the system is an
          <dfn>outbound call</dfn>. Conversely, a telephony call from a remote
          party is an <dfn>inbound call</dfn>.
      </p>
      </section>
      <section><h3>Call id</h3>
      <p>
          Every telephony call has a <dfn>call id</dfn>, which is a string that
          uniquely identifies the call and call history.
      </p>
      </section>
      <section><h3>Active call</h3>
      <p>
          An <dfn>active call</dfn> is a <a>Call</a> in the <a>active</a> state
          representing a connected call which is bound to the media input and
          output devices (e.g. microphone, speaker, tone generator). Note that
          a call on hold is also active from a call signaling point of
          view, but not bound to media input and output devices.
      </p>
      </section>
      <section><h3>Call types</h3>
      <p>
          Within the API, a telephony call is represented by the <a>Call</a>
          typedef - which encapsulates both objects that implement the
          <a><code>TelephonyCall</code></a> interface and the
          <a><code>ConferenceCall</code></a>
          interface.
      </p>
      </section>
      <section><h3>Remote party id</h3>
      <p>
          A <dfn>remote party id</dfn> uniquely identifies a participant
          (a.k.a. remote party) in a telephony call in the given <a>telephony
          service</a>, such as a phone number.
      </p>
      </section>

      <!-- - - - - - - - - - - - - - Call typedef - - - - - - - - - - - - - -->
      <section> <h3>The <code>Call</code> typedef</h3>
          <dl title="typedef (TelephonyCall or ConferenceCall) Call"
          class="idl"></dl>
      </section><!-- Call typedef -->

      <!-- - - - - - - - - - - - - -  Multiparty calls  - - - - - - - - - - -->
      <section> <h3>Multiparty calls</h3>
        <p>
          A <dfn>multiparty call</dfn> (also commonly referred to as a
          <dfn>conference call</dfn>) is a <a>telephony call</a> with multiple
          remote party participants, which is controlled as a single telephony
          call, i.e. it can be <a>held</a>, <a>active</a>,
          <a>disconnected</a> from all participants in one transaction.
          if the <a>telephony service</a> supports it, other calls can be
          joined with a multiparty call, and a participant can be split off the
          conference call for a private conversation, while the conference call
          is put on hold. A <a><code>ConferenceCall</code></a> object is used
          for controlling multiparty calls, but also for managing calls merged
          using <dfn>client side merge</dfn>, implemented by the
          <code>merge()</code> method of the <a><code>CallManager</code></a>
          interface, and which means the audio channels of
          the active call (be it simple or multiparty) is mixed with the audio
          channel of another call from a different <a>telephony service</a>,
          and the microphone is shared.
          This needs support from the underlying audio system and the
          telephony protocol stack, and it is managed completely on the client
          side, unlike <a>multiparty call</a>s, which are managed by the
          <a>telephony service</a>, i.e. the telephony network.
          Implementations are not required to support <a>client side merge</a>.
        </p>
        <p>
          Every multiparty call has a unique <dfn>conference id</dfn> that
          identifies a <a>multiparty call</a> in the system.
        </p>
        <p class="note">
          This of the API version supports GSM multiparty calls and CDMA 3-way
          calls.
        </p>
        <p>
          In the API, a multiparty call is represented by any object that
          implements the <a><code>ConferenceCall</code></a> interface.
        </p>
        <p>
          When a <a><code>ConferenceCall</code></a> object is created, the
          <a>user agent</a> MUST run the following steps:
          <ol id="conference-id-steps">
            <li>Generate an identifier stored in the <code>callId</code>
            attribute, which MUST be unique in the system and the local call
            history.
            </li>
            <li>Map this identifier to the transaction identifiers accepted by
            the telephony service.In GSM, the <code>callId</code> of any
            participating call could be used in a multiparty operation as a
            transaction identifier, and the telephony network will reply with
            using the same value.
            </li>
            <li>
            Also, the transaction identifiers received from the network MUST be
            mapped back by the implementation to the unique conference call
            identifier of the multiparty call.
            </li>
          </ol>
        </p>
      </section><!-- Multiparty calls -->

      <!-- - - - - - - - - - - - - - Call states  - - - - - - - - - - - - - - -
      ======= A short introducton on call state management for editors ========
      _________________________________________________________________________
      CDMA states for dialed calls       | Mapping to the API or [modem] state
      _________________________________________________________________________
          [ DIAL button pressed ]        | dialing
          -> channel request             |
          <- immediate assignment        |
          -> service request             |
          <- authentication request      |
          -> authentication response     |
          <- cyphering command           |
          -> cyphering complete          |
          -> setup                       |
          <- call confirmed              |
          <- assignment command          |
          -> assignment completed        |
          <- alerting                    | alerting
          <- connect                     |
          -> connect ack                 | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      CDMA states for received calls     | Mapping to the API or [modem] state
      _________________________________________________________________________
          <- paging request              |
          -> channel request             |
          <- immediate assignment        |
          -> paging response             |
          <- authentication request      |
          -> authentication response,    |
          <- cyphering command           |
          -> cyphering complete          |
          <- call setup                  |
          -> call confirmed              | incoming
          <- assignment command          |
          -> assignment complete         |
          -> call alerting               | [ringing]
          [ OK button pressed ]          | accepted
          -> connect                     |
          <- connect ack                 | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      GSM states for dialed calls        | Mapping to the API or [modem] state
      _________________________________________________________________________
          [ DIAL button pressed ]        | dialing
          -> channel request             |
          <- immediate assignment        |
          -> service request             |
          -> connection request          |
          <- cyphering command           |
          -> cyphering complete          |
          -> call setup                  |
          <- connecting                  | connecting
          [call mode: signaling -> voice]|
          [routing, voicemail, errors]   |
          <- call confirmed              |
          <- alerting                    | alerting
          <- connect                     |
          -> connect ack                 | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      GSM states for received calls      | Mapping to the API or [modem] state
      _________________________________________________________________________
          <- interrogation procedure     |
          <- paging request              |
          -> channel request             |
          <- immediate assignment        |
          -> paging response             |
          - cyphering                    |
          <- call setup                  | incoming
          -> call confirmed              |
          -> call alerting               | [ringing]
          [ OK button pressed ]          | accepted
          -> connect                     |
          <- connect ack                 | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      SIP/IMS states for dialed calls | Mapping to the API or [SIP stack] state
      _________________________________________________________________________
          [ DIAL button pressed ]        | dialing
          -> SIP Invite                  | [initializing]
          <- SIP 183 Session Progress    |
          [ SDP ]                        |
          -> PRACK                       | [initialized]
          [Caller PDP Context activation]|
          <- SIP 200 OK                  |
          -> UPDATE [ context ]          |
          <- SIP 200 OK                  |
          [ remote starts ringing ]      |
          <- SIP 180 RINGING             | alerting
          -> PRACK                       |
          [ remote accepts]              |
          <- SIP 200 OK                  |
          -> ACK                         | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      SIP states for received calls  | Mapping to the API or [SIP stack] state
      _________________________________________________________________________
          <- SIP Invite                  | incoming
          -> SIP 183 Session Progress    | [initializing]
          [ SDP ]                        |
          <- PRACK                       |
          -> SIP 200 OK                  | [initialized]
          [ PDP Context activation]      |
          <- UPDATE [ context ]          |
          -> SIP 200 OK                  |
          [ locally ringing ]            |
          -> SIP 180 RINGING             | [ringing]
          <- PRACK                       |
          [ accepts ]                    | accepted
          -> SIP 200 OK                  |
          <- ACK                         | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      XMPP states for dialed calls   | Mapping to the API or [XMPP stack] state
      [ XMPP XEP-0166 Jingle ]       | (may depend on XMPP implementation)
      _________________________________________________________________________
          DIAL button pressed            | dialing
          -> session-initiate            |
          <- ack                         |
          <- session-accept              | alerting
          -> ack                         | active (connected)
          <-> media session              |
          <- session-terminate           |
          -> ack                         | disconnected
      _________________________________________________________________________
      XMPP states for received calls | Mapping to the API or [XMPP stack] state
      [ XMPP XEP-0166 Jingle ]       | (may depend on XMPP implementation)
      _________________________________________________________________________
          <- session-initiate            | incoming
          -> ack                         |
          [ locally ringing ]            | [ringing]
          [ user accepts ]               | accepted
          -> session-accept              |
          <- ack                         | active (connected)
          <-> media session              |
          -> session-terminate           | disconnecting
          <- ack                         | disconnected
      _________________________________________________________________________

      ## Multiparty call sequences and states

          GSM TS 24.084.
          "There are four auxiliary states associated with the MPTY service:
          - Idle;
          - MPTY request; A request has been made to add this call to the MPTY.
          - Call in MPTY; This call is in the MPTY.
          - Split request; A request has been made to remove this call from the
          MPTY.
          These Auxiliary states apply in addition to the GSM 04.08 call control
          states and the GSM 04.83 call hold states. Thus for example, an active
          call in a held MPTY has the state (Active, Call held, Call in MPTY).
          Not all states are allowed, for example an MPTY cannot be split while
          it is held, so (Active, Call held, Split request) is forbidden."

          Instead of this, we offer a model when states describe valid
          multiparty states. Valid state transitions for a multiparty call are:
          * joining -> active
          * active -> holding -> held
          * held -> resuming -> active (connected)
          * any state -> [disconnecting]-> disconnected
      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   -->

      <section> <h2>Call states</h2>
        <p>
          A <dfn>call state</dfn> represents the state of interaction between a
          <a>telephony service</a>, the telephony network, the API, and
          one or more remote parties.
        </p>
        <p>
          Within the API, the call states are represented by the
          <code><a>CallState</a></code> enum.
        </p>
        <!-- - - - - - - - - - -  CallState Enum  - - - - - - - - - - - - - -->
        <section> <h3><dfn>CallState</dfn> enum</h3>
          <dl title="enum CallState" class="idl">
            <dt><a>dialing</a></dt>
            <dt><a>connecting</a></dt>
            <dt><a>alerting</a></dt>
            <dt><a>active</a></dt>
            <dt><a>incoming</a></dt>
            <dt><a>waiting</a></dt>
            <dt><a>accepted</a></dt>
            <dt><a>holding</a></dt>
            <dt><a>held</a></dt>
            <dt><a>resuming</a></dt>
            <dt><a>redirecting</a></dt>
            <dt><a>transferring</a></dt>
            <dt><a>disconnecting</a></dt>
            <dt><a>disconnected</a></dt>
            <dt><a>joining</a></dt>
            <dt><a>multiparty</a></dt>
            <dt><a>splitting</a></dt>
          </dl>
          <p>
            The meaning of the call states referenced in this API is the
            following:
          </p>
          <dl>
            <dt><dfn>dialing</dfn></dt>
            <dd>An outbound call is being dialed by a telephony service.</dd>

            <dt><dfn>connecting</dfn></dt>
            <dd>A request to establish the call has been made and it is
              progressing.
            </dd>

            <dt><dfn>alerting</dfn></dt>
            <dd>The destination number has been reached and alerting is taking
              place.
            </dd>

            <dt><dfn>active</dfn></dt>
            <dd>The call is ongoing.</dd>

            <dt><dfn>incoming</dfn></dt>
            <dd>An incoming call is being received whilst no other call is
              progressing.
            </dd>

            <dt><dfn>waiting</dfn></dt>
            <dd>An incoming call that has been received whilst there was another
              call progressing, and the call waiting service is active.
            </dd>

            <dt><dfn>accepted</dfn></dt>
            <dd>An incoming call has been accepted and is being connected.</dd>

            <dt><dfn>holding</dfn></dt>
            <dd>The call is being put on hold.</dd>

            <dt><dfn>held</dfn></dt>
            <dd>The call has been put on hold.</dd>

            <dt><dfn>resuming</dfn></dt>
            <dd>The call, which was on hold, is being resumed.</dd>

            <dt><dfn>redirecting</dfn></dt>
            <dd>The call is being redirected to another remote party from the same
              <a>telephony service</a>.
            </dd>

            <dt><dfn>transferring</dfn></dt>
            <dd>The call is being transferred to another remote party from the
              same <a>telephony service</a>.
            </dd>

            <dt><dfn>disconnecting</dfn></dt>
            <dd>A request to disconnect the call has been made and it is
              progressing.
            </dd>

            <dt><dfn>disconnected</dfn></dt>
            <dd>The call has been disconnected and this object is invalid for call
              control.
            </dd>

            <dt><dfn>joining</dfn></dt>
            <dd>The call is being joined with another call to become a multiparty
              call.
            </dd>

            <dt><dfn>multiparty</dfn></dt>
            <dd>The call is a multiparty call.</dd>

            <dt><dfn>splitting</dfn></dt>
            <dd>The call is being split from a multiparty call.</dd>
          </dl>
          <p>
            Some of these states are <dfn>soft states</dfn>, that is,
            transitory states in which the application is placed after making a
            request to the telephony system and until it is completed. For
            instance the application remains in <a><code>holding</code></a>
            state since it invokes the <a><code>hold()</code></a> method and
            until the telephony system actually holds the call. In some
            implementations these soft states can be skipped. The following are
            the soft states defined by this specification:
            <a><code>accepted</code></a>, <a><code>disconnecting</code></a>,
            <a><code>holding</code></a>, <a><code>resuming</code></a>.
          </p>
          <p>
            On the contrary, <dfn>hard states</dfn> MUST be supported by the
            implementation: <a><code>dialing</code></a>,
            <a><code>alerting</code></a>, <a><code>active</code></a>,
            <a><code>disconnected</code></a>, <a><code>incoming</code></a>,
            <a><code>waiting</code></a>, <a><code>held</code></a>.
            For calls participating in multiparty calls, the following
            additional call states MUST be supported:
            <a><code>joining</code></a>, <a><code>splitting</code></a>,
            <a><code>multiparty</code></a>. For call transfer functionality, the
            additional <a><code>transferring</code></a> state MUST be supported.
          </p>
        </section><!-- CallState Enum -->

        <!-- - - - - - - - - - -  State changes - - - - - - - - - - - - - - -->
        <section> <h3>State changes</h3>
          <p>
            Whenever there is a change in the <a>state</a> attribute the
            <a>user agent</a> MUST run the following steps:
          </p>
          <ol id="steps-call-statechange-event">
            <li>
              <a>Queue a task</a> to <a>fire an event</a> named
              <a><code>statechange</code></a> with the new value of the state
              attribute.
            </li>
            <li>
              <a>Queue a task</a> to <a>fire an event</a> named with the state
              name, e.g. <a><code>active</code></a>.
            </li>
          </ol>
          <p>
            Since call state transitions depend on protocol, network equipment,
            modem, etc., the implementation MUST always re-synchronize any
            eventual internal states to the current call state reported by the
            telephony system. The implementation MUST NOT set the call state to
            any other value than specified in the descriptions of the methods
            of this interface.
          </p>
          <p class="note">
            Since <a title="call state">call states</a> can have slightly
            different semantics depending on the telephony protocol, the
            <a><code>serviceId</code></a> and the <code>protocol</code>
            properties can be used for interpreting the call state in the
            implementation. See
            <a href="https://github.com/sysapps/telephony/issues/125">issue
            125</a>.
          </p>
          <p class="issue">
            Note that compliant implementations may not be reporting events
            exactly when they occur, and the implementations may have to poll
            for these (e.g. OTA SIM update or hot-swappable SIM cards). See
            <a href="https://github.com/sysapps/telephony/issues/127">issue
            127</a>.
          </p>
        </section><!-- state changes -->
      </section><!-- call states -->

      <!-- - - - - - - - - - - - - - Receiving calls  - - - - - - - - - - - -->
      <section> <h3>States when receiving calls (inbound states)</h3>
        <p>
          The device can receive phone calls from any active telephony service,
          even simultaneously, in which case the user agent arbitrates the
          calls either by a policy, or by the user by choosing which call to
          accept.
        </p>
        <p>
          For call setup on received calls, the following call states MUST be
          supported in this order:
        </p>
        <ol>
          <li>"<a>incoming</a>" or "<a>waiting</a>"</li>
          <li>"<a>accepted</a>"</li>
          <li>"<a>active</a>".</li>
        </ol>
        <p class="note">
          On received calls, telephony protocols also use a <dfn>ringing</dfn>
          state, set by the mobile terminal when local call alerting starts, in
          order to notify the remote party about the ongoing alerting (ringing
          can actually be e.g. a beep, ring tone, or vibration pattern). This
          is considered to be responsibility of implementations: if the modem
          expects this state to be set, implementations MUST make sure to set
          it. Dialer applications are not expected to set this state in the
          current version of the specification.
        </p>
        <p class='note'>
          CDMA cannot report all these states in the expected sequence. The
          ‘connected’ network state (i.e. when the mobile station send the
          Service Connect Completion Message or Connect Order, depending on
          whether the call is mobile originated or terminated) is immediately
          followed by voice media transmission – there is no transition to
          ‘active’ before the media arrives. Therefore it should be up to the
          implementation to determine which events to fire and in which order.
          Dialer applications need to be prepared to handle such cases.
        </p>
        <figure>
          <img src="images/inbound_call_state_diagram.gif" alt="">
          <figcaption>
            The figure depicts the most usual state transitions for received
            calls.
          </figcaption>
        </figure>
      </section><!-- Inbound states -->

      <!-- - - - - - - - - -  Making calls (outbound states)  - - - - - - - -->
      <section> <h3>States when making calls (outbound states)</h3>
        <div class="issue">
          <p>
            The following needs to be redefined algorithmically in terms of the
            telephony service.
          </p>
          <p>
            To <dfn>make a call</dfn> with a <a><var>remote party
            identifier</var></a>, optionally a <var>telephony service</var>,
            and optionally a <var>hide caller id</var>, the user agent MUST ...
          </p>
        </div>
        <p>
          For making a call, the <a>telephony service</a> transitions through
          the following states in order. Errors can occur at each state, which
          can result in the call becoming <a>disconnected</a>:
        </p>
        <ol>
          <li><a>dialing</a></li>
          <li><a>alerting</a></li>
          <li><a>active</a></li>
        </ol>
        <p class="note">
          On the telephony services which support the "<a>connecting</a>" call
          state (e.g. GSM and CDMA, for call routing, forwarding, voicemail
          handling etc), implementations SHOULD support this state too, between
          the "<a>dialing</a>" and "<a>alerting</a>" states. Dialer
          applications can associate the protocol with the <a>telephony
          service</a> used for the call.
        </p>
        <figure>
          <img src="images/outbound_call_state_diagram.gif" alt="">
          <figcaption>
            The figure depicts the most usual state transitions for dialed
            calls.
          </figcaption>
        </figure>
      </section><!-- Making calls (Outbound states) -->

      <!-- - - - - - - - - - - Disconnect reason  - - - - - - - - - - - - - -->
      <section> <h2>Disconnect reason</h2>
        <p>
          The reasons why a call can become <a>disconnected</a> are as follows.
          Within the API the following disconnection reasons are represented by
          the the <code><a>DisconnectReason</a></code> enum.
        </p>
        <!-- - - - - - - - - - -  DisconnectReason Enum - - - - - - - - - - -->
        <section> <h3><code><a>DisconnectReason</a></code> enum</h3>
          <dl title="enum DisconnectReason" class="idl">
            <dt>local</dt>
            <dt>remote</dt>
            <dt>network</dt>
            <dt>busy</dt>
            <dt>rejected</dt>
            <dt>redirected</dt>
            <dt>unreachable</dt>
            <dt>no-answer</dt>
            <dt>network-unreachable</dt>
            <dt>barred</dt>
            <dt>no-service</dt>
            <dt>invalid-number</dt>
          </dl>
          <p>
            The meaning of the disconnect reasons in this API is the following:
          </p>
          <dl>
            <dt><dfn id="disconnect-local">local</dfn></dt>
            <dd>The call was disconnected by the user, or the device, and no
              more specific reason is known.
            </dd>

            <dt><dfn id="disconnect-remote">remote</dfn></dt>
            <dd>The call was disconnected by the remote party, and no more
              specific reason is known.
            </dd>

            <dt><dfn id="disconnect-network">network</dfn></dt>
            <dd>The call was disconnected by the network, and no more specific
              reason is known.
            </dd>

            <dt><dfn id="disconnect-busy">busy</dfn></dt>
            <dd>The call was disconnected by the network, because the remote
              party was busy.
            </dd>

            <dt><dfn id="disconnect-rejected">rejected</dfn></dt>
            <dd>The call was disconnected because the remote party rejected the
              call.
            </dd>

            <dt><dfn id="disconnect-redirected">redirected</dfn></dt>
            <dd>The call has been redirected to another subscriber.</dd>

            <dt><dfn id="disconnect-unreachable">unreachable</dfn></dt>
            <dd>The call was disconnected by the network, because the remote
              party was unreachable by the network.
            </dd>

            <dt><dfn id="disconnect-no-answer">no-answer</dfn></dt>
            <dd>The call was disconnected by the network, because the remote
              party has not answered and the call has timed out.
            </dd>

            <dt>
              <dfn id="disconnect-network-unreachable">network-unreachable</dfn>
            </dt>
            <dd>The call was disconnected because the network was unreachable.
            </dd>

            <dt><dfn id="disconnect-barred">barred</dfn></dt>
            <dd>The call was disconnected because it was barred.</dd>

            <dt><dfn id="disconnect-no-service">no-service</dfn></dt>
            <dd>The call was not made because there is no telephony service set
              up and enabled (e.g. no SIM card).
            </dd>

            <dt><dfn id="disconnect-invalid-number">invalid-number</dfn></dt>
            <dd>The call was disconnected by the network, because the remote
              party identifier was invalid.
            </dd>
          </dl>
        </section><!-- DisconnectReason Enum -->
      </section><!-- disconnecting calls -->
    </section> <!-- definitions -->

    <!-- - - - - - - - - - - - - Interface CallManager  - - - - - - - - - - -->
    <section> <h2>The <a>CallManager</a> Interface</h2>
      <p>
        The <a>CallManager</a> interface provides access to telephony
        functionality related to given <a>telephony service</a>s, and manages
        the lifecycle of the <a>Call</a> objects.
      </p>
      <dl title="interface CallManager : EventTarget" class="idl">
        <dt>readonly attribute Call? activeCall   </dt>
        <dt>  // on success, getCalls() returns an array of TelephonyCall's</dt>
        <dt>Promise getCalls()</dt>
        <dt>
          Call? getCall(DOMString remoteParty, optional DOMString serviceId)
        </dt>
        <dt>  // on success, dial() returns a TelephonyCall</dt>
        <dt>
          Promise dial (DOMString remoteParty, optional DialOptions options)
        </dt>
        <dt> // on success, createConference() returns a ConferenceCall</dt>
        <dt>
          Promise createConference(optional DOMString remote,
                                   optional DialOptions options)
        </dt>
        <dt> // on success, merge() returns a ConferenceCall</dt>
        <dt>Promise merge(Call call)</dt>
        <dt>attribute EventHandler oncalladded     </dt>
        <dt>attribute EventHandler oncallremoved   </dt>
        <dt>attribute EventHandler onactivechanged </dt>
      </dl>

      <!-- - - - - - - - - - -  Event handlers  - - - - - - - - - - - - - - -->
      <section> <h2>Event handlers</h2>
        <p>
          The following are the event handlers implemented by the
          <a>CallManager</a> interface.
        </p>
        <table class="simple">
          <tr>
            <th>event handler</th>
            <th>event name   </th>
            <th>event type   </th>
            <th>description  </th>
          </tr>
          <tr>
            <td>
              <dfn id="widl-CallManager-oncalladded"><code>oncalladded</code>
              </dfn>
            </td>
            <td><dfn><code>calladded</code></dfn></td>
            <td><a>TelephonyEvent</a></td>
            <td>handles incoming and waiting calls, and creation of multiparty
              calls, hence a change in the calls managed by this object
            </td>
          </tr>
          <tr>
            <td>
              <dfn
                id="widl-CallManager-oncallremoved"><code>oncallremoved</code>
              </dfn>
            </td>
            <td><dfn><code>callremoved</code></dfn></td>
            <td><a><code>TelephonyEvent</code></a></td>
            <td>handles call disconnection and when calls are moved to
              conference calls, hence a change in the calls managed by this
              object
            </td>
          </tr>
          <tr>
            <td>
         <dfn id="widl-CallManager-onactivechanged"><code>onactivechanged</code>
              </dfn>
            </td>
            <td><dfn><code>activechanged</code></dfn></td>
            <td><a>TelephonyEvent</a></td>
            <td>handles a change of the <code>activeCall</code> property
            </td>
          </tr>
          </table>

          <!-- - - - - - - - - - calladded event  - - - - - - - - - - - - - -->
          <section> <h3>The <code>oncalladded</code> event</h2>
          <p>The <code>oncalladded</code> event MUST be raised either when there
            is an incoming or waiting call, or when a new conference call is
            created, i.e. when the list of <a><code>Call</code></a> objects
            managed by the <a><code>CallManager</code></a> changes.
          <p>
            Upon a new incoming or waiting call, the <a>user agent</a> MUST
            execute the following <df>onincoming steps</dfn>:
          </p>
          <ol id="steps-onincoming">
          <li>Let <var>incomingCall</var> be a new instance of
            <a>TelephonyCall</a>.
          </li>
          <li>Set the <code>state</code> of <var><code>incomingCall</code></var>
            to <a><code>incoming</code></a> in case the underlying telephony
            system reports that state (which happens when there is no other call
            in <a><code>active</code></a> state).
          </li>
          <li>Alternatively, set the <code>state</code> of
            <var><code>incomingCall</code></var> to <a><code>waiting</code></a>,
            in case the underlying telephony system reports that state (which
            happens if the call waiting service is active and there is already
            an <a>active</a> call).
          </li>
          <li>Otherwise, if there already is an <a>active</a> call and the call
            waiting service is not enabled, the telephony system will disconnect
            the call, the implementation MUST follow the
            <a href="steps-ondisconnected">disconnect steps</a> and terminate
            these steps.
          </li>
          <li>If the <code>state</code> of <var>incomingCall</var> is set
            to either <a><code>incoming</code></a> or
            <a><code>waiting</code></a>, then add <var>incomingCall</var> to the
            list of calls managed by <a><code>CallManager</code></a>.
          </li>
          <li>
            <a>Queue a task</a> to <a>fire an event</a> named
            <code>statechange</code> at the <var>incomingCall</var> object.
          </li>
          <li>
            <a>Queue a task</a> to <a>fire an event</a> named
            <code>calladded</code> at all the <a>CallManager</a> objects, with
            its <var>call</var> argument set to <var>incomingCall</var>.
          </li>
          </ol>
          </section>

          <!-- - - - - - - - - - - oncallremoved event  - - - - - - - - - - -->
          <section> <h3>The <code>callremoved</code> event</h3>
          <p>
            The <code>callremoved</code> event MUST be raised either when a
            <a><code>Call</code></a> object managed by the <a>CallManager</a>
            object is disconnected, or when it is moved to be part of a
            <a>ConferenceCall</a>, i.e. when the list of
            <a><code>Call</code></a> objects managed by the
            <a><code>CallManager</code></a> changes.
          <p>
            When a <a>telephony service</a> is notified of call disconnection of
            the <a>Call</a> object <var>telCall</var>, the user agent MUST run
            the following <dfn>ondisconnected steps</dfn>:
          </p>
          <ol id="steps-ondisconnected">
            <li><a>Queue a task</a> to:
             <ol>
              <li>Remove the <var>telCall</var> object from all internal lists
                of <a><code>CallManager</code></a>
              </li>
              <li>set the <code>state</code> of <var>telCall</var> to
                "<a>disconnected</a>".
              </li>
              <li>
                fire a <a><code>TelephonyStateEvent</code></a>
                named <code>statechange</code> at the <var>telCall</var>
                object, with the <code>name</code> property set to
                <code>'disconnected'</code> and the <code>reason</code>
                property set to the <a>DisconnectReason</a>, if available,
                or otherwise it MUST be set to <code>null</code>. At least the
                following values MUST be supported for the disconnect reason:
                "<a>local</a>", "<a>remote</a>" and "<a>network</a>".
                The rest of the <a>DisconnectReason</a> values SHOULD be
                supported.
              <li>
                fire the <var>callremoved</var> event at all the
                <a><code>CallManager</code></a> objects.
              </li>
             </ol>
            </li>
          </ol>
          </section>

        <!-- - - - - - - - Active call change event steps - - - - - - - - - -->
        <section> <h3>Handling the <code>activechanged</code> event</h3>
        <p>
          When the the <code>activeCall</code> of a
          <a><code>CallManager</code></a> object changed, the user agent MUST
          run the following steps:
        </p>
        <ol id="steps-call-onactivechanged">
          <li>let <var>callManager</var> denote the
            <a><code>CallManager</code></a> instance on which the
            <code>activeCall</code> was changed
          </li>
          <li><a>Queue a task</a> to <a>fire an event</a> named
            <code>activechanged</code> at all the  instances of
            <a><code>CallManager</code></a>, except <var>callManager</var>.
          </li>
        </ol>
        </section>
      </section><!-- event handers -->

      <!-- - - - - - - - - - - - Interface TelephonyEvent - - - - - - - - - - -->
      <section> <h2><a>TelephonyEvent</a> Interface</h2>
        <p>
          Defines telephony events for <a>TelephonyCall</a> state changes,
          including handling incoming and waiting calls.
        </p>
        <dl title="interface TelephonyEvent : Event" class="idl">
          <dt>readonly attribute Call call</dt>
        </dl>
        <!-- - - - - - - - - - - - call attribute - - - - - - - - - - - - - - -->
        <section> <h3>The <code>call</code> attribute</h3>
          <p>
            When getting the <dfn id="widl-TelephonyEvent-call">call</dfn>
            attribute, the user agent MUST return the <a>Call</a> that
            triggered the event.
          </p>
        </section>
      </section><!-- interface TelephonyEvent -->

      <!-- - - - - - - - - - - - -  activeCall attribute  - - - - - - - - - -->
      <section> <h3>The <code>activeCall</code> attribute</h3>
        <p>
          When getting the <dfn id=
          "widl-CallManager-activeCall">activeCall</dfn> attribute, the
          user agent MUST return the <a>Call</a> object that represents the
          <a>active call</a>. If there is no active <a>Call</a>, return
          <code>null</code>.
        </p>
      </section>

      <!-- - - - - - - - - - - - - getCalls() method  - - - - - - - - - - - -->
      <section> <h3>The <code>getCalls()</code> method</h3>
        <p>
          When the <dfn id="widl-CallManager-getCalls-Promise">getCalls()</dfn>
          method is invoked, the user agent MUST return a <code>Promise</code>
          object, which in case of success resolves to an array, which can be
          empty, of <a>Call</a> objects managed by this object.
        </p>
        <p class="Note">
          <a>TelephonyCall</a> objects belonging to a multiparty call are
          managed by the corresponding <a>ConferenceCall</a> object and won't
          be present in this array.
        </p>
      </section>

      <!-- - - - - - - - - - - -  DialOptions Dictionary  - - - - - - - - - -->
      <section> <h3><a>DialOptions</a> Dictionary</h3>
        <dl title="dictionary DialOptions" class="idl">
          <dt>boolean hideCallerId </dt>
          <dt>DOMString serviceId  </dt>
        </dl>
        <!-- - - - - - - - - - - -  hideCallerId member - - - - - - - - - - -->
        <section> <h3>The <code>hideCallerId</code> member</h3>
          <p>
            The <dfn id="widl-DialOptions-hideCallerId">hideCallerId</dfn>
            member represents whether the local party identifier is to be
            hidden or displayed to the remote party being called. If missing,
            the user agent uses the default configuration for the <a>telephony
            service</a> that initiated the call.
          </p>
          <p class="note">
            Only some protocols support hidding the identity of the local party
            when making a call.
          </p>
        </section>
        <!-- - - - - - - - - - - -  serviceId member  - - - - - - - - - - - -->
        <section> <h3>The <code>serviceId</code> member</h3>
          <p>
            The <dfn id="widl-DialOptions-serviceId">serviceId</dfn> member
            represents the <a>telephony service id</a> of the <a>telephony
            service</a> to be used when dialing.
          </p>
        </section><!-- serviceId member -->
      </section><!-- DialOptions Dictionary -->

      <!-- - - - - - - - - - - dial() method  - - - - - - - - - - - - - - - -->
      <section><h3>The <code>dial()</code> method</h3>
        <p>
          The <dfn id="widl-CallManager-dial-Promise-DOMString-remoteParty-DialOptions-options">dial()</dfn>
          method initiates a new <a>telephony call</a>. When
          invoked, the user agent MUST run the following <dfn>dial steps</dfn>:
        </p>
        <p class="note">
          Note that verification of the format of the <var>remoteParty</var>
          argument is left to the <a>telephony service</a>. Providing an
          <var>remoteParty</var> in the invalid format will generally result in
          the call disconnecting because the <a>telephony service</a> or
          telephony network will deem it an invalid number.
        </p>
        <ol id="steps-dial">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Let <var>service</var> initially be either the default telephony
          service id, if one is available to the <a href=
          "http://dom.spec.whatwg.org/#concept-document">document</a>'s
            <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/origin-0.html#effective-script-origin">
            effective script origin</a>, or <code>null</code> otherwise.
          </li>
          <li>If the <var>options</var> argument is used, and it has a
            <var>serviceId</var> member specified, then:
            <ol>
              <li>If the value of <var>serviceId</var> matches a valid
              telephony service id accessible to the <a href=
              "http://dom.spec.whatwg.org/#concept-document">document</a>'s
              <a href=
              "http://www.whatwg.org/specs/web-apps/current-work/multipage/origin-0.html#effective-script-origin">
                effective script origin</a>, then set <var>service</var> to
                that value.
              </li>
              <li>Otherwise, set <var>service</var> to <code>null</code></li>
            </ol>
          </li>
          <li>
            If <var>service</var> is <code>null</code>, then
            call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"NotFoundError"</code>, and terminate this algorithm.
          </li>
          <li>Let <var>telCall</var> be a new instance of <a>TelephonyCall</a>.
          </li>
          <li>Set <var>telCall</var>'s <a>remoteParty</a> attribute to <a><var>
            remote party id</var></a>.
          </li>
          <li>Make a request to the underlying telephony system to
            <a>make a call</a> using <var>service</var> as
            <a>telephony service id</a>, and if the <var>options</var> argument
            is specified, and it has a <var>hideCallerId</var> member, then use
            that value, otherwise by default use <code>false</code> for hiding
            the caller id.
          </li>
          <li>Wait for response from the underlying system.
          </li>
          <li>If it's not possible to fulfill the request for whatever reason:
            timeout, security, etc., then
            call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"NoModificationAllowedError"</code>, and terminate this
            algorithm.
          </li>
          <li>Otherwise, <a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept(value)</code> method with <var>telCall</var> as
            <var>value</var> argument.
          </li>
        </ol>
      </section><!--dial() method-->

      <!-- - - - - - - - - createConference() method  - - - - - - - - - - - -->
      <section><h3>The <code>createConference()</code> method</h3>
        <p>
          When the <dfn id="widl-CallManager-createConference-Promise-DOMString-remote-DialOptions-options">createConference()</dfn>
          method is invoked, the user agent MUST run the following
          <dfn>createconference steps</dfn>:
        </p>
        <ol id="steps-createconference">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Let <var>service</var> initially be either the default telephony
          service id, if one is available to the <a href=
          "http://dom.spec.whatwg.org/#concept-document">document</a>'s
            <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/origin-0.html#effective-script-origin">
            effective script origin</a>, or <code>null</code> otherwise.
          </li>
          <li>If the <var>options</var> argument is used, and it has a
            <var>serviceId</var> member specified, then:
            <ol>
              <li>If the value of <var>serviceId</var> matches a valid
              telephony service id accessible to the <a href=
              "http://dom.spec.whatwg.org/#concept-document">document</a>'s
              <a href=
              "http://www.whatwg.org/specs/web-apps/current-work/multipage/origin-0.html#effective-script-origin">
                effective script origin</a>, then set <var>service</var> to
                that value.
              </li>
              <li>Otherwise, set <var>service</var> to <code>null</code></li>
            </ol>
          </li>
          <li>
            If <var>service</var> is <code>null</code>, then
            call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"NotFoundError"</code>, and terminate this algorithm.
          </li>
          <li>Let <var>confCall</var> be a new instance of <a>ConferenceCall</a>
            with a unique <code>conferenceId</code> property.
          </li>
          <li>If the <var>remote</var> parameter was not specified, i.e. there
          were no parameters, then follow these sub-steps:
            <ol>
              <li>set the <code>conferenceId</code> property of
                <var>confCall</var> to a unique value.
              </li>
              <li>Set the <code>state</code> of <var>confCall</var> to
              "<a>joining</a>".
              </li>
              <li>Then, in the telephony service specified by <var>service</var>
                make a request to the telephony system to create a conference
                call, and wait for the response.
                In cellular telephony (such as GSM and CDMA) this will mean
                joining the active and held calls into a multiparty call. In a
                SIP service it will create an new conference focus. In other
                telephony services which require at least another participant to
                be specified, this request may fail.
              </li>
              <li>If the request fails, call <var>resolver</var>'s
              <code>reject(value)</code> method with the <var>value</var>
                argument set to a new <code>DOMError</code> object whose name is
                set to <code>"NoModificationAllowedError"</code>, and terminate
                this algorithm.
              </li>
              <li>Otherwise, if the request has successfully completed, then
                execute the steps for <a>finishing conference call creation</a>
                and terminate this algorithm.
              </li>
            </ol>
          </li>
          <li>Otherwise if there is no <a>active call</a>, then resolve
            <var>promise</var> with a <code>"NoModificationAllowedError"</code>
              error, and terminate this algorithm.
          </li>
          <li>Otherwise, if the <var>options</var> parameter was specified, and
            it has a <var>serviceId</var> member specified which is not equal to
            the <a>telephony service id</a> of the <a>active call</a>, then
            resolve <var>promise</var> with a
            <code>"NoModificationAllowedError"</code> error, and terminate
            this algorithm.
          </li>
          <li>Otherwise execute the steps for making a multiparty call with
           the specified <var>remote</var>. The exact steps will differ
           depending on the <var>service</var> protocol used. In telephony
           services like SIP or XMPP it means making an asynchronous
           request to the underlying telephony system for setting up a
           conference call with the specified <var>remote</var>.
           In cellular telephony this is not possible with one transaction,
           and the implementations SHOULD execute the following steps:
           <ol>
             <li>if the implementation chooses to not support the following
               steps in one transaction: programmatically dialing
               <var>remote</var> by using the <a>dial steps</a>, then putting
               the <a>active call</a> on hold by using the <a>hold steps</a>,
               and finally joining the active and held calls,
               then resolve <var>promise</var> with a
               <code>"NoModificationAllowedError"</code> error, and
               terminate this algorithm.
             </li>
             <li>otherwise, make a request to the underlying telephony
               system to dial a call by using the <a>dial steps</a> to
               <var>remote</var> and wait until the call denoted by a new
               <var>telCall</var> object is connected and the
               <a>active call</a> is put in <a><code>hold</code></a> state.
             </li>
             <li>for all calls in the given <a>telephony service</a>,
               save the value of the <code>state</code> property, then set it to
               <a><code>joining</code></a>
             </li>
             <li>make a a request to the telephony system to join the
               active and held calls into a multiparty call and wait for
               the response
             </li>
             <li>If the request fails for any reason, then restore the
               <code>state</code> of all calls to the value saved before
               the request, then resolve <var>promise</var> with a
               <code>"NoModificationAllowedError"</code> error, and
               terminate this algorithm.
             </li>
             <li>Otherwise, if the request has successfully completed, then
               execute the steps for <a>finishing conference call creation</a>
               and terminate this algorithm.
             </li>
           </ol>
         </li>
       </ol>
       <p>
         The steps for <dfn>finishing conference call creation</dfn> are the
         following:
       </p>
       <ol>
         <li>set the <code>conferenceId</code> attribute of the
           participating calls to the unique identifier generated for the
           multiparty call <var>confCall</var>.
         </li>
         <li>Add the calls participating in the multiparty call to the
           <code>calls</code> attribute of the <var>confCall</var> object, and
           set their <code>state</code> to <a><code>multiparty</code></a>.
         </li>
         <li>Add the <var>confCall</var> object to all the <a>CallManager</a>
           objects, and <a>queue a task</a> to fire a <code>calladded</code>
           event with its <var>call</var> set to <var>confCall</var> on each
           of these
         </li>
         <li>Remove all calls participating in the multiparty call from all
           <a><code>CallManager</code></a> objects, and <a>queue a task</a> to
           fire a <code>callremoved</code> event with its <var>call</var> set to
           the removed call object
         </li>
         <li>Set the <code>state</code> of <var>confCall</var> to
           <a><code>active</code></a>.
         </li>
         <li>
           <a>Queue a task</a> to <a>fire an event</a> named
           <code>participantadded</code> at <var>confCall</var>.
         </li>
         <li>Follow the state changes of <var>confCall</var> through the
           state change events.
         </li>
       </ol>
      </section><!--createConference() method-->
    </section><!-- CallManager -->

    <!-- - - - - - - - - - - merge() method - - - - - - - - - - - - - - - - -->
    <section><h3>The <code>merge()</code> method</h3>
      <p>
        The <dfn id="widl-CallManager-merge-Promise-Call-call">merge()</dfn>
        method initiates a <a>client side merge</a> of the <a>active call</a>
        and the call specified as argument.
        When invoked, the user agent MUST run the following steps:
      </p>
      <ol id="steps-merge">
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
          object and <var>resolver</var> its associated resolver.
        </li>
        <li>If there is no <a>active call</a>, then resolve
        <var>promise</var> with a <code>"NoModificationAllowedError"</code>
          error, and terminate this algorithm.
        </li>
        <li>Otherwise return <var>promise</var> and continue the following steps
          asynchronously.
        </li>
        <li>Make a request to the underlying audio system to merge the audio
          channels between the <a>active call</a> and <var>call</var>, and a
          request to share the microphone between the two calls. These two
          requests SHOULD be handled as one transaction.
        </li>
        <li>Wait for response from the underlying system.
        </li>
        <li>If it's not possible to fulfill either request for whatever reason:
          timeout, security, etc., then
          call <var>resolver</var>'s <code>reject(value)</code>
          method with the <var>value</var> argument set to a new
          <code>DOMError</code> object whose name is set to
          <code>"NoModificationAllowedError"</code>, and terminate this
          algorithm.
        </li>
        <li>Otherwise, <a>queue a task</a> to invoke <var>resolver</var>'s
          <code>accept()</code> method.
        </li>
      </ol>
    </section><!--merge() method-->

    <!-- - - - - - - - - - - -  Interface CallHandler - - - - - - - - - - - -->
    <section> <h2><a>CallHandler</a> interface</h2>
      <p>
        The <code>CallHandler</code> interface provides common properties and
        event handling infrastructure that is <a href=
        "http://www.w3.org/TR/WebIDL/#idl-implements-statements">implemented</a>
        by other interfaces in this specification, e.g. <a>TelephonyCall</a>
        and <a>ConferenceCall</a>. It serves as an editorial aid in this
        specification, and has no functional utility on its own.
      </p>
      <dl title="[NoInterfaceObject] interface CallHandler" class="idl">
        <dt>readonly attribute DOMString callId    </dt>
        <dt>readonly attribute DOMString serviceId </dt>
        <dt>readonly attribute CallState state     </dt>
        <dt>Promise resume()                       </dt>
        <dt>Promise hold()                         </dt>
        <dt>Promise disconnect()                   </dt>
        <dt>attribute EventHandler onstatechange   </dt>
      </dl>
      <!-- - - - - - - - - - - -  event handlers  - - - - - - - - - - - - - -->
      <section id="callhandler-eventhandlers"> <h3>Event handlers</h3>
        <p>
          The following are the event handlers are exposed by the
          CallHandler interface. The event type is
          <a><code>TelephonyStateEvent</code></a>.
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>event handler</th>
              <th>event name</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
               <dfn id=
               "widl-CallHandler-onstatechange"><code>onstatechange</code></dfn>
              </td>
              <td><dfn><code>statechange</code></dfn></td>
            </tr>
          </tbody>
        </table>
        <!-- - - - - - - - - - Interface TelephonyStateEvent  - - - - - - - -->
        <section> <h2>The <a>TelephonyStateEvent</a> Interface</h2>
          <p>
            Defines a telephony event for notifying a changed state for a
            telephony call.
          </p>
          <dl title="interface TelephonyStateEvent : Event"
          class="idl">
            <dt>readonly attribute DOMString state</dt>
            <dt>readonly attribute DOMString reason</dt>
          </dl>
          <!-- - - - - - - - - - state attribute  - - - - - - - - - - - - - -->
          <section> <h3>The <code>state</code> attribute</h3>
            <p>
            <p>
              When getting the <dfn id=
              "widl-TelephonyStateEvent-state">state</dfn>, the user agent
              MUST return the new <a>call state</a> causing the state change.
            </p>
          </section>
          <!-- - - - - - - - - - reason attribute - - - - - - - - - - - - - -->
          <section>
            <h3>The <code>reason</code> attribute</h3>
            <p>
              When getting the <dfn id=
              "widl-TelephonyStateEvent-reason">reason</dfn>, the user
              agent MUST return a reason for the new telephony call state
              of the <a>telephony call</a> if the reason is available, or
              <code>null</code> otherwise. In this version, only
              the <code>'disconnected'</code> state reasons are specified, as
              described in <a><code>DisconnectReason</code></a>.
            </p>
          </section>
        </section><!-- interface TelephonyStateEvent -->

      </section><!-- Event Handlers -->

      <!-- - - - - - - - - - - -  hold() method - - - - - - - - - - - - - -->
      <section> <h3>The <code>hold()</code> method</h3>
        <p>
          The <dfn id="widl-CallHandler-hold-void">hold()</dfn> method requests
          the telephony system put the <a>Call</a> on hold. When
          invoked, the user agent MUST run the following <dfn>hold steps</dfn>:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If <code>state</code> is not equal to <a><code>active</code></a>,
            then call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Set the <code>state</code> of the call to <code>holding</code>
          </li>
          <li>Make a request to the telephony system to put the call on hold.
          </li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the <code>state</code> of the
            call to <a><code>active</code></a>. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then set <code>state</code> to
            <a><code>held</code></a>, and  <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section> <!-- hold() method -->

      <!-- - - - - - - - - - - -  resume() method - - - - - - - - - - - - -->
      <section> <h3>The <code>resume()</code> method</h3>
        <p>
          The <dfn id="widl-CallHandler-resume-void">resume()</dfn> method
          requests the telephony system to resume resume a held <a>Call</a>.
          When invoked, the user agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If <code>state</code> is not equal to <a><code>held</code></a>,
            then call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of the call</li>
          <li>Set the <code>state</code> of the call to
            <a><code>resuming</code></a>
          </li>
          <li>Make a request to the telephony system to resume the call.</li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the <code>state</code> of the
            call to <a><code>held</code></a>. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then set <code>state</code> to
            <a><code>active</code></a>, and  <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- resume() method -->

      <!-- - - - - - - - - - - -  disconnect() method - - - - - - - - - - - -->
      <section> <h3>The <code>disconnect</code> method</h3>
        <p>
          The <dfn id="widl-CallHandler-disconnect-void">disconnect</dfn>
          method, if invoked on a <a>TelephonyCall</a>, it initiates releasing
          of the telephony call. If invoked on a <a>ConferenceCall</a>, it
          MUST initiate releasing the multiparty call, and each participating
          <a>TelephonyCall</a> object.
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of the call</li>
          <li>Set the <code>state</code> of the call to
            <code>disconnecting</code>
          </li>
          <li>Make a request to the telephony system to disconnect the call</li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the <code>state</code> of the
            call to the saved value. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then execute the
            <a>ondisconnected steps</a>, and and  <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
        <p class="note">
          Depending on the protocol, there may be restrictions on methods. For
          instance, GSM does not permit disconnecting a held call. Also,
          disconnecting a participant in a held multiparty call is not
          supported. Also, if the controlling party disconnects in IS-41 3-way
          call in CDMA, then all parties are disconnected, and it is not
          possible for the controlling party to disconnect only one participant
          (that participant must choose to hang up).
        </p>
      </section><!-- disconnect() method -->

      <!-- - - - - - - - - - - - callId attribute - - - - - - - - - - - - - -->
      <section> <h3>The <code>callId</code> attribute</h3>
        <p>
          When getting the <dfn id="widl-CallHandler-callId">callId</dfn>
          attribute, the user agent MUST return the <a>call id</a>.
        </p>
      </section><!-- callId attribute -->

      <!-- - - - - - - - - - - -  serviceId attribute - - - - - - - - - - - -->
      <section> <h3>The <code>serviceId</code> attribute</h3>
        <p>
          When getting the <dfn id="widl-CallHandler-serviceId">serviceId</dfn>
          attribute, the user agent MUST return the <a>telephony service id</a>
          of the <a>telephony service</a> associated with this call.
        </p>
      </section><!-- serviceId attribute -->

      <!-- - - - - - - - - - - -  state attribute - - - - - - - - - - - - - -->
      <section> <h3>The <code>state</code> attribute</h3>
        <p>
          When getting the <dfn id="widl-CallHandler-state">state</dfn>
          attribute, the user agent MUST return the <a>CallState</a> value that
          represents the state of for the <a>Call</a>.
        </p>
      </section><!-- state attribute -->      
    </section><!-- CallHandler Interface -->

    <!-- - - - - - - - - - - -  Interface TelephonyCall - - - - - - - - - - -->
    <section> <h2><a>TelephonyCall</a> Interface</h2>
      <p>
        Defines the object structure for controlling calls.
      </p>
      <dl title="TelephonyCall implements CallHandler" class="idl"></dl>
      <dl title="interface TelephonyCall : EventHandler" class="idl">
        <dt> readonly attribute DOMString? remoteParty   </dt>
        <dt> readonly attribute DOMString? conferenceId  </dt>
        <dt> Promise accept()                            </dt>
        <dt> Promise redirect(DOMString remoteParty)     </dt>
        <dt> Promise transfer(DOMString thirdParty)      </dt>
      </dl>

      <!-- - - - - - - - - - - - remoteParty attribute  - - - - - - - - - - -->
      <section> <h3>The <code>remoteParty</code> attribute</h3>
        <p>
          When getting the <dfn id=
          "widl-TelephonyCall-remoteParty">remoteParty</dfn> attribute, the
          user agent MUST return the <a>remote party id</a> (e.g. telephone
          number) of the call participant. If not available (e.g. callerId has
          been hidden), return <code>null</code>.
        </p>
      </section>

      <!-- - - - - - - - - - - - conferenceId attribute - - - - - - - - - - -->
      <section> <h3>The <code>conferenceId</code> attribute</h3>
        <p>
          When getting the <dfn id=
          "widl-TelephonyCall-conferenceId">conferenceId</dfn> attribute, if
          this call is managed as a part of a multiparty call then the user
          agent MUST return the value of the <code>conferenceId</code>
          attribute of the <a>ConferenceCall</a> multiparty call to which this
          call is part of. Otherwise, return <code>null</code>.
        </p>
      </section>

      <!-- - - - - - - - - - - - accept() method  - - - - - - - - - - - - - -->
      <section> <h3>The <code>accept()</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-accept-void">accept()</dfn> method
          accepts an incoming or waiting <a>telephony call</a>. When invoked,
          the user agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If <code>state</code> is not equal to <a><code>incoming</code></a>
            or <a><code>waiting</code></a>, then
            call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of the call</li>
          <li>Make a request to the telephony system to accept the call.</li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the call state to the value saved before the request. Then,
            call <var>resolver</var>'s <code>reject(value)</code> method with
            the <var>value</var> argument set to a new <code>DOMError</code>
            object whose name is set to
            <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then set <code>state</code> to
            <a><code>accepted</code></a>, and  <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- accept() method -->

      <!-- - - - - - - - - - - - redirect() method  - - - - - - - - - - - - -->
      <section> <h3>The <code>redirect()</code> method</h3>
        <p class="note">
          The telephony service in use needs to have the call deflection
          feature enabled in order for this method to succeed. For instance, in
          GSM, the Call Deflection supplementary service needs to be active.
        </p>
        <p>
          The <dfn id=
          "widl-TelephonyCall-redirect-void-DOMString-remoteParty">redirect()</dfn>
          method initiates deflecting an incoming or waiting telephone call to
          a remote party. The method takes one argument, which represents the
          remote party to which the call is redirected. When invoked, the user
          agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If the <a>state</a> is not <a><code>incoming</code></a> or
            <a><code>waiting</code></a>,
            then call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of the call</li>
          <li>Make a request to the telephony system to redirect the
           call to the number indicated in the <var>remoteParty</var> parameter
          </li>
          <li>Set the <code>state</code> of the call to
            <a><code>redirecting</code></a>
          </li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the state before the request.
            Then call <var>resolver</var>'s <code>reject(value)</code> method
            with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"NoModificationAllowedError"</code>, and terminate this
            algorithm.
          </li>
          <li>If the request is successful, then set <code>state</code> to
            <a><code>disconnected</code></a>, and  <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- redirect() method -->

      <!-- - - - - - - - - - - - transfer() method  - - - - - - - - - - - - -->
      <section> <h3>The <code>transfer()</code> method</h3>
        <p class="note">
          The <a>telephony service</a> needs to have the call transfer feature
          enabled in order for this method to succeed. For instance, in GSM,
          the Call Transfer supplementary service needs to be active.
        </p>
        <p>
          The <dfn id=
          "widl-TelephonyCall-transfer-void-DOMString-thirdParty">transfer()</dfn>
          method Initiates transferring the call to a new call between the
          remote party of this call and another remote party, then disconnects
          the call. The method takes one argument, which represents the remote
          party to which the call is transferred. When invoked, the user agent
          MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If <code>state</code> is not equal to <a><code>active</code></a>
            or <a><code>held</code></a>, then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of the call</li>
          <li>Set the <code>state</code> of the call to
            <a><code>transferring</code></a>
          </li>
          <li>Make a request to the telephony system to transfer the
            call to the number indicated in the <var>thirdParty</var> parameter.
            Note that in GSM this requires putting the current call on hold,
            dialing a new call to the third party, then initiating the call
            transfer procedure.
          </li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the <code>state</code> of the call to the value saved before
            the request. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code> and terminate
            this algorithm.
          </li>
          <li>If the transfer request is successful, then execute the
            <a>ondisconnected steps</a>, and <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- transfer() method -->
    </section><!-- TelephonyCall -->

    <!-- - - - - - - - - - - -  Interface ConferenceCall  - - - - - - - - - -->
    <section> <h2>The <a>ConferenceCall</a> Interface</h2>
      <p>
        Describes the object controlling multiparty calls, and managing the
        <a>TelephonyCall</a> objects participating in the multiparty call.
      </p>
      <dl title="ConferenceCall implements CallHandler" class="idl"></dl>
      <dl title="interface ConferenceCall : EventTarget" class="idl">
        <dt> readonly attribute DOMString conferenceId       </dt>
        <dt>  // on success, getCalls() returns an array of TelephonyCall's</dt>
        <dt> Promise getCalls()                              </dt>
        <dt> Promise split(TelephonyCall call)               </dt>
        <dt> Promise invite(DOMString remoteParty,
                            optional DialParams params)      </dt>
        <dt> attribute EventHandler onparticipantadded       </dt>
        <dt> attribute EventHandler onparticipantremoved     </dt>
      </dl>

      <!-- - - - - - - - - - - - Event handlers - - - - - - - - - - - - - - -->
      <section> <h3>Event handlers</h3>
        <p>
          To handle changes in <a>call state</a>s, the
          <a>ConferenceCall</a> interface implements the following <a>event
          handlers</a>. The event type for the events is
          <a><code>Event</code></a>.
        </p>
        <table class="simple">
          <tr>
            <th>event handler </th>
            <th>event name</th>
          </tr>
          <tr>
            <td>
              <code><dfn id=
              "widl-ConferenceCall-onparticipantadded">onparticipantadded</dfn>
              </code>
            </td>
            <td>participantadded</td>
          </tr>
          <tr>
            <td>
              <code><dfn id=
              "widl-ConferenceCall-onparticipantremoved">onparticipantremoved</dfn></code>
            </td>
            <td>participantremoved</td>
          </tr>
        </table>
      </section>

      <!-- - - - - - - - - - - -  conferenceId attribute  - - - - - - - - - -->
      <section> <h3>The <code>conferenceId</code> attribute</h3>
        <p>
          When getting the <dfn id=
          "widl-ConferenceCall-conferenceId">conferenceId</dfn> attribute, the
          user agent MUST return the conference identifier unique in the system
          and in call history. It MUST NOT be the empty string.
        </p>
      </section><!-- conferenceId attribute -->

      <!-- - - - - - - - - - - - - getCalls() method  - - - - - - - - - - - -->
      <section> <h3>The <code>getCalls()</code> method</h3>
        <p>
          When the <dfn
          id="widl-ConferenceCall-getCalls-Promise">getCalls()</dfn>
          method is invoked, the user agent MUST return a <code>Promise</code>
          object, which in case of success resolves to an array, which can be
          empty, of <a>Call</a> objects managed by this object.
        </p>
        <p class="Note">
          <a><code>Call</code></a> objects belonging this multiparty
          call won't be present in <a><code>CallManager</code></a> objects.
        </p>
      </section>

      <!-- - - - - - - - - - - - split() method - - - - - - - - - - - - - - -->
      <section> <h3>The <code>split()</code> method</h3>
        <p>
          The <dfn id=
          "widl-ConferenceCall-split-Promise-TelephonyCall-call">split()</dfn>
          method requests the telephony system split the specified participant
          <a>TelephonyCall</a> object, activate it and put this multiparty call
          on hold. The method takes one argument, which represents the
          <a>TelephonyCall</a> object of the call participant to be split from
          the multiparty call. When invoked, the user agent MUST run the
          following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If the provided <var>call</var> does not identify a
            valid <a>TelephonyCall</a> object which is part of this multiparty
            call, then call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidModificationError"</code>, and terminate this
            algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Set the <code>state</code> of the <var>call</var> and
            set the state of the <a>ConferenceCall</a> object to
            <a></code>splitting</code></a>.
          </li>
          <li>Make a request to the telephony system to split the call
            participant from the multiparty call.
          </li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the <code>state</code> of the <var>call</var>
            and the state of the multiparty call to
            <a><code>multiparty</code></a>. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request was successful, reset the <code>conferenceId</code>
            of the split call to <code>null</code>.
            The telephony system will put the multiparty call on hold and
            activate the split call. The implementation MUST follow the state
            transitions on the calls as described in this specification.
          </li>
          <li> <a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept()</code> method.
          </li>
        </ol>
        <p class='note'>
          In CDMA, only 3-way calling is supported. This is an IS-41 CN
          limitation (see Network Interworking between GSM-MAP and TIA-41,
          <a href='http://www.scribd.com/doc/7029977/Network-Inter-Working-Between-GSM-MAP-and-ANSI41-CDMA'>3GPP2 document</a>, p. 1-50 provides a
          comparison of multiparty call and 3-way call.
        </p>
      </section><!-- split() method -->

      <!-- - - - - - - - - - - invite() method  - - - - - - - - - - - - - - -->
      <section><h3>The <code>invite()</code> method</h3>
        <p>
          The <dfn id="widl-ConferenceCall-invite-Promise-DOMString-remoteParty-DialParams-params">invite()</dfn>
          method is equivalent to invoking the <code>createConference</code>
          method with the parameters given to <code>invite()</code>. When
          invoked, the user agent MUST run the following steps:
        </p>
        <ol id="steps-invite">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>
            If this call is not the <a>active call</a>, then
            call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"NoModificationAllowedError"</code>, and terminate this
            algorithm.
          </li>
          <li>Otherwise, execute the <a>createconference steps</a> with the
            parameters given to this method.
          </li>
        </ol>
      </section><!--invite() method-->
    </section><!-- ConferenceCall -->
    </section><!-- Telephony Calls -->

    <!-- - - - - - - - - - - -  Tone management - - - - - - - - - - - - - - -->
    <section> <h2>Tone Management</h3>
      <section> <h2>The <a>ToneManager</a> Interface</h2>
        <p>
          The <a>ToneManager</a> interface provides [[!DTMF]] related
          functionality, such as sending a series of tones, and starting and
          stopping a single tone.
        </p>
        <p>
          Tone value can be any of the following characters: 0-9; A-D; *; #.
        </p>
        <p class="issue">
          The above needs to be converted to ABNF
        </p>
        <dl title="interface ToneManager" class="idl">
          <dt>
            Promise sendTones(DOMString tones, optional ToneOptions options)
          </dt>
          <dt>
            Promise startTone(DOMString tone, optional ToneOptions options)
          </dt>
          <dt>
            Promise stopTone(optional DOMString serviceId)
          </dt>
        </dl>
        </section>

        <!-- - - - - - - - - - - -  sendTones() - - - - - - - - - - - - - - -->
        <section> <h3>The <code>sendTones()</code> method</h3>
          <p>
            The <dfn id=
            "widl-ToneManager-sendTones-Promise">sendTones()</dfn> method
            requests a telephony service emit one or more [[!DTMF]] tones. When
            invoked, the user agent MUST run the following steps:
          </p>
          <ol id="steps-sendtones">
            <li>If the <a>ToneOptions</a> parameter specifies the
            <a>serviceId</a> to be used, then validate and use that value,
            otherwise use the <a>default telephony service</a> for sending the
            tones.
            </li>
            <li>If the <a>ToneOptions</a> parameter specifies the tone
            <code>duration</code>, then validate and use that value, otherwise
            use a default value.
            </li>
            <li>If the <a>ToneOptions</a> parameter specifies the tone
            <code>gap</code>, then validate and use that value, otherwise use a
            default value.
            </li>
            <li>Request from the telephony system to send the specified tones.
            </li>
            <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated
              <a><code>resolver</code></a>.
            </li>
            <li>Return <var>promise</var> to the caller and continue the
              following steps asynchronously.
            </li>
            <li>If the request to the telephony system is successful, or if the
              telephony system does not support feedback about the result of the
              request, invoke <var>resolver</var>'s <code>accept()</code> method
              with no arguments.
            </li>
            <li>If the request to the telephony system is unsuccessful, invoke
              <var>resolver</var>'s <code>reject()</code> method, with no
              arguments.
            </li>
          </ol>
          </section>

          <!-- - - - - - - - - - - -  startTone() - - - - - - - - - - - - - -->
          <section> <h3>The <code>startTone()</code> method</h3>
            <p>
              The <dfn id=
              "widl-ToneManager-startTone-Promise">startTone()</dfn> method
              starts emitting a [[!DTMF]] tone with the platform default or
              specified delay, in the platform default or the specified
              telephony service. A <a><code>Promise</code></a> object will be
              returned in order to notify the result of the request.
            </p>
            <p>
              When the <code>startTone</code> method is invoked, the user agent
              MUST run the following steps:
            </p>
            <ol id="steps-starttone">
              <li>If the platform does not support long press [[!DTMF]] tones,
              throw a <code>NotSupported</code> error and finish these steps. In
              this case applications may then use the <code>sendTones</code>
              method for sending [[!DTMF]].
              </li>
              <li>If the <a>ToneOptions</a> parameter specifies the
              <a>serviceId</a> to be used, then validate and use that value,
              otherwise use the <a>default telephony service</a> for sending the
              tones.
              </li>
              <li>If the <a>ToneOptions</a> parameter specifies the tone
              <code>duration</code>, then ignore that value.
              </li>
              <li>If the <a>ToneOptions</a> parameter specifies the tone
              <code>gap</code>, meaning the delay before sending the tone, then
              validate and use that value, otherwise use a default value.
              </li>
              <li>Request from the telephony system to start sending the
              specified tone. The tone SHOULD play until the
              <code>stopTone</code> method is called.
              </li>
              <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated
              <a><code>resolver</code></a>.
              </li>
              <li>Return <var>promise</var> to the caller and continue the
              following steps asynchronously.
              </li>
              <li>If the request to the telephony system is successful, or if
              the telephony system does not support feedback about the result of
              the request, invoke <var>resolver</var>'s <code>accept()</code>
              method with no arguments.
              </li>
              <li>If the request to the telephony system is unsuccessful, invoke
              <var>resolver</var>'s <code>reject()</code> method, with no
              arguments.
              </li>
            </ol>
          </section>

          <!-- - - - - - - - - - - -  stopTone()  - - - - - - - - - - - - - -->
          <section> <h3>The <code>stopTone()</code> method</h3>
            <p>
              The <dfn
              id="widl-ToneManager-stopTone-Promise-DOMString-serviceId">
              stopTone()</dfn>
              method stops emitting a [[!DTMF]] tone in the default or the
              specified telephony service. When invoked, the user agent MUST run
              the following steps:
            </p>
            <ol id="steps-stoptone">
              <li>If the platform does not support long press [[!DTMF]] tones,
              throw a <code>NotSupported</code> error.
              </li>
              <li>If the provided parameters are invalid, or there is no tone
              playing on the specified telephony service, throw an
              <code>InvalidStateError</code> error.
              </li>
              <li>Otherwise, request from the telephony system to stop sending
              the specified tone.
              </li>
              <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated
              <a><code>resolver</code></a>.
              </li>
              <li>Return <var>promise</var> to the caller and continue the
              following steps asynchronously.
              </li>
              <li>If the request to the telephony system is successful, or if
              the telephony system does not support feedback about the result of
              the request, invoke <var>resolver</var>'s <code>accept()</code>
              method with no arguments.
              </li>
              <li>If the request to the telephony system is unsuccessful, invoke
              <var>resolver</var>'s <code>reject()</code> method, with no
              arguments.
              </li>
            </ol>
          </section>

          <!-- - - - - - - - - - - -  ToneOptions - - - - - - - - - - - - - -->
          <section> <h3><a>ToneOptions</a> Dictionary</h3>
            <dl title="dictionary ToneOptions" class="idl">
              <dt> unsigned long duration </dt>
              <dt> unsigned long gap      </dt>
              <dt> DOMString serviceId     </dt>
            </dl>
            <section> <h3>The <code>duration</code> member</h3>
              <p>
                The <dfn id="widl-ToneOptions-duration">duration</dfn> member
                represents the duration (mark) in milliseconds of the [[!DTMF]]
                tones to be sent.
              </p>
            </section>
            <section> <h3>The <code>gap</code> member</h3>
              <p>
                The <dfn id="widl-ToneOptions-gap">gap</dfn> member represents
                the duration in milliseconds of the time gap (space) before a
                [[!DTMF]] tone.
              </p>
            </section>
            <section> <h3>The <code>serviceId</code> member</h3>
              <p>
                The <dfn id="widl-ToneOptions-serviceId">serviceId</dfn> member
                represents the <a>telephony service id</a> of the <a>telephony
                service</a> to be used when dialing.
              </p>
            </section>
          </section>
    </section> <!-- Tone management -->

    <!-- - - - - - - - - - - -  Emergency numbers - - - - - - - - - - - - - -->
    <section> <h2>The <a>EmergencyManager</a> Interface</h2>
      <p>
        This interface provides access for reading emergency numbers from the
        available <a>telephony service</a>s.
      </p>
      <dl title="interface EmergencyManager" class="idl">
        <dt> // on success returns emergency numbers as sequence of DOMString
        <dt>Promise getEmergencyNumbers(optional DOMString serviceId)</dt>
        <dt>attribute EventHandler onupdated</d>
      </dl>
      <!-- - - - - - - - - - - EmergencyManager Event handlers  - - - - - - -->
      <section> <h2>Event handlers</h2>
      <p>
        The following are the <a>event handler</a>s implemented by the
        <a>ServiceManager</a> interface.
      </p>
      <table class="simple">
        <tr>
          <th>event handler    </th>
          <th>event name       </th>
        </tr>
        <tr>
          <td>
            <dfn id="widl-EmergencyManager-onupdated">
                 <code>onupdated</code>
            </dfn>
          </td>
          <td>
            <dfn><code>updated</code></dfn>
          </td>
        </tr>
      </table>
      <p>
        When emergency numbers have changed, the <code>updated</code> event of
        type <a><code>Event</code></a> MUST be fired at the object implementing
        this interface. The applications SHOULD read the emergency numbers
        by the <code>getEmergencyNumbers()</code> method.
      </p>
    </section>
    <section> <h3>The <code>getEmergencyNumbers()</code> method</h3>
      <p>
        When the <dfn id=
        "widl-EmergencyManager-getEmergencyNumbers-Promise-DOMString-serviceId">getEmergencyNumbers()</dfn> method is invoked, the user agent MUST
        run the following steps:
      </p>
      <ol id="steps-getemergencynumbers">
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
          object and <var>resolver</var> its associated resolver.
        </li>
        <li>Return <var>promise</var> and continue the following steps
          asynchronously.
        </li>
        <li> If the parameter <var>serviceId</var> has been specified, then
          make a request to the underlying telephony system to provide the
          list of emergency numbers only from the corresponding
          <a>telephony service</a>, otherwise request the list from all enabled
          <a>telephony service</a>s.
        </li>
        <li>Wait for response from the underlying system.
        </li>
        <li>If it's not possible to retrieve the list of telephony service
        identifiers for whatever reason: timeout, security, etc., then run the
        following sub-steps and terminate this algorithm:
          <ol>
            <li>Let <var>error</var> be a new DOMError object whose name is
            <code>"NoModificationAllowedError"</code>.
            </li>
            <li>Call <var>resolver</var>'s <code>reject(value)</code> method
            with <var>error</var> as the <var>value</var> argument.
            </li>
          </ol>
        </li>
        <li>Otherwise, combine the emergency numbers into a sequence of
          distinct <code>DOMString</code> strings, and <a>queue a task</a> to
          invoke <var>resolver</var>'s <code>accept(value)</code> method with
          the sequence of emergency numbers in the current geographical area,
          as the <var>value</var> argument. The list can be empty.
        </li>
      </ol>
      </p>
    </section>
    </section> <!-- Emergency numbers -->

    <!-- - - - - - - - - - - - Command parser - - - - - - - - - - - - - - - -->
    <section> <h2>Managing telephony commands</h2>
      <p>
        This interface provides a method for parsing and classifying user input.
        Applications can use this for dispatching these user inputs to relevant
        handlers. This is a helper interface for dialer applications, in order
        to avoid parsing user input to resolve commands in various telephony
        service specific contexts.
        For example, dialers could accept an emergency number typed in a PIN
        code dialog and display a button for making the emergency call.
        Another example is in a running dialer application, user input can be a
        phone number, an emergency number, or an MMI command, which enables
        the application know which API methods to use in continuation, i.e.
        which interfaces can accept the given user input. For instance, in the
        case of an MMI command the implementation of this interface can tell
        whether the command is valid and could be forwarded to the telephony
        service.
      </p>
      <section> <h3>The <a>TelephonyCommandParser</a> Interface</h3>
      <dl title="interface TelephonyCommandParser" class="idl">
        <dt>// on success returns TelephonyCommandType</dt>
        <dt>
          Promise parseCommand(DOMString input, optional DOMString serviceId)
        </dt>
      </dl>
      <section> <h3>The <code>parseCommand()</code> method</h3>
      <p>
        When the <code>parseCommand()</code> method is invoked, the user agent
        MUST run the following steps:
      </p>
      <ol id="steps-parsecommand">
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
          object and <var>resolver</var> its associated resolver.
        </li>
        <li>Return <var>promise</var> and continue the following steps
          asynchronously.
        </li>
        <li>If the parameter <var>serviceId</var> has been specified, then
          restrict the following steps to the corresponding
          <a>telephony service</a>.
        </li>
        <li>Make a request to the underlying system to parse the user input
          given in <var>input</var>.
        </li>
        <li>Wait for response from the underlying system.
        </li>
        <li>If it's not possible to retrieve the list of telephony service
        identifiers for whatever reason: timeout, security, etc., then run the
        following sub-steps and terminate this algorithm:
          <ol>
            <li>Let <var>error</var> be a new DOMError object whose name is
            <code>"NoModificationAllowedError"</code>.
            </li>
            <li>Call <var>resolver</var>'s <code>reject(value)</code> method
            with <var>error</var> as the <var>value</var> argument.
            </li>
          </ol>
        </li>
        <li>Otherwise, <a>queue a task</a> to invoke <var>resolver</var>'s
          <code>accept(value)</code> method with the result as string, i.e. a
          <a><code>TelephonyCommandType</code></a> enumeration value as
          <var>value</var> argument.
        </li>
      </ol>
      </section>
      <section> <h3>The <a><code>TelephonyCommandType</code></a> enum</h3>
      <p>
        The return value of the <code>parseCommand()</code> method
        through the <code>Promise</code> is a string enumeration value of
        the input classification.
      </p>
      <dl title="enum TelephonyCommandType" class="idl">
        <dt>emergency</dt>
        <dt>smmi</dt>
        <dt>mmi</dt>
        <dt>invalid</dt>
        <dt>number</dt>
        <dt>unknown</dt>
      </dl>
      <p> The supported command type values are the following:</p>
      <dl>
        <dt>"emergency"</dt>
        <dd>The user input matches to a known emergency number.</dd>

        <dt>"smmi"</dt>
        <dd>The user input matched to a standalone MMI command.</dd>

        <dt>"mmi"</dt>
        <dd>The user input matched to a sendable MMI command.</dd>

        <dt>"invalid"</dt>
        <dd>
          The user input is invalid (e.g. too long or contains invalid
          characters).
        </dd>

        <dt>"number"</dt>
        <dd>The user input matched to a remote party id of known
          format.</dd>

        <dt>"unknown"</dt>
        <dd>The user input matched does not match to a known command, nor to a
          known number format. The input may be usable, depending on the
          telephony service.</dd>
      </dl>
      </section>
      </section>
    </section> <!-- Command parser -->

    <!-- - - - - - - - - - - - Security and privacy - - - - - - - - - - - - -->
    <section> <h2>Security and privacy considerations</h2>
      <div class="issue">
        <p>
          To be improved. See <a href=
          "https://github.com/sysapps/telephony/issues/26">bug 26</a>.
        </p>
      </div>
      <p>
        This API provides access to a potentially dangerous and valuable
        feature of a device. As a result, misuse of the API would have a large
        cost to users and other system stakeholders. This API should,
        therefore, not be implemented without careful consideration of security
        and privacy issues.
      </p>
      <p>
        This section provides a limited overview of security and privacy
        considerations relevant for this API. It includes a set of threats to
        users and other stakeholders, as well as requirements for mitigating
        them.
      </p>
      <p>
        However, this section cannot cover all of the potential threats, nor
        can it reflect the context in which a conformant implementation may be
        operating. As a result, this security section should be considered only
        the starting point for implementers.
      </p>
      <!-- - - - - - - - - - - - Threats  - - - - - - - - - - - - - - - - - -->
      <section> <h3>Threats</h3>
        <p>
          The following list of threats should be considered by the
          implementer. Note that these are not given in any order.
        </p>
        <ul>
          <li>The API could be used by a malicious application to deny other
          system applications access to the device's telephony services,
          creating an availability problem. This is a safety, as well as
          security, concern.
          </li>
          <li>The API could be used by a malicious application as part of a
          distributed denial of service attack, making frequent calls to a
          remote call system such as an emergency response number.
          </li>
          <li>The API could be used by an application to list the telephone
          numbers that the end user has called and is, at any time, calling.
          This information ought to be considered private, and could also be
          used as part of a social engineering attack, or for identity theft.
          </li>
          <li>The API could be used to make unwanted calls to premium-rate
          telephone numbers. A malicious application could use this to earn
          money at the user's expense. Similarly, this API could be misused to
          enrol the user into a premium-rate calling service, which would then
          charge the end user when calls are received.
          </li>
          <li>The API could be used to make unwanted advertising calls, in a
          similar manner to spam email campaigns. When combined with access to
          the user's contact list, this would be both expensive and embarassing
          for the user, and could result in their telephony service being
          terminated by the network operator.
          </li>
          <li>The API could be used by a malicious application to make
          telephone calls impersonating the end user, or as part of a process
          to defeat a two-factor authentication system.
          </li>
          <li>A poorly implemented application could misuse this API to make
          unnecessary or unexpected calls, costing the user money or
          embarassing them.
          </li>
          <li>This API could be used to call a number other than the one that
          the user was expecting, routing calls to an unknown
          man-in-the-middle. This could be used to eavesdrop on the user. When
          used in combination with recordings from the microphone, this API
          could be used to covertly survey the end user.
          </li>
          <li>This API could be used to send USSD messages to the service
          provider and invoke functions such as wiping the handset or accessing
          security settings.
          </li>
          <li>The API could be misused to access the user's voicemail
          recordings.
          </li>
          <li>The API could be misused as part of a DDoS attack on an operator
          or service provider, flooding the network with calls at certain
          times.
          </li>
          <li>The API could cost the end user money by making outgoing calls
          when the user is roaming, or on an expensive network.
          </li>
        </ul>
      </section><!-- threats -->
      <!-- - - - - - - - - - - - Mitigations  - - - - - - - - - - - - - - - -->
      <section> <h3>Mitigations</h3>
        <p>
          The following mechanisms may be employed to help an implementer
          mitigate the threats outlined in the previous section.
        </p>
        <ul>
          <li>The user agent should only expose this API to <em>privileged</em>
          applications, as defined in the <a href=
          "http://www.w3.org/TR/runtime/">Runtime and Security Model</a>.
          </li>
          <li>The user agent should only expose this API to applications which
          were distributed by an institution that the handset recognises as a
          valid source. For example, the API might only be accessible to
          applications distributed by the handset manufacturer.
          </li>
          <li>All applications with access to this API should be reviewed
          before they are made available. A mechanism for remote update of
          applications with access to this API should be provided to allow for
          identified security issues to be fixed.
          </li>
          <li>The user agent should maintain the integrity of any application
          with access to this API when initially downloaded, as well as when it
          is stored offline.
          </li>
          <li>The user agent should only expose this API to downloaded, offline
          applications which are not modifiable by external web servers. A
          restrictive content security policy should be used to enforce that
          application with external content (such as scripts) cannot access
          this API.
          </li>
          <li>The API implementation should have different behaviour when used
          with premium-rate numbers. Accessing premium-rate numbers may require
          an additional permission to be listed in the manifest, a different
          (or additional) warning to be displayed to users, or place an
          additional requirement on the valid distributors of the application.
          It is up to the implementing user agent to identify whether a remote
          party identifier is premium-rate or not.
          </li>
          <li>The API implementation should have different behaviour when the
          user is roaming on a network with a different (less favourable)
          service-level agreement. For example, presenting a different warning
          to the user, or denying access to this API from certain applications
          altogether.
          </li>
          <li>User consent must be captured when a call is made. For example,
          the user must press a 'dial' button, or equivalent, before the call
          is placed. The user must also be shown the recipients of the call,
          and the numbers that have and will be dialled as part of placing it.
          </li>
          <li>It should be obvious, visually, when a call is being invoked, is
          in progress, and has ended. This should be visible to the end user
          and it must not be possible for applications to hide or obscure this
          indicator.
          </li>
          <li>The user agent should introduce rate limiting to prevent an
          application from making too many calls in too short a period of time.
          </li>
        </ul>
      </section><!-- Mitigations -->

      <!-- - - - - - - - - - - - User interaction guidelines  - - - - - - - -->
      <section> <h2>User interaction guidelines</h2>
        <p>
          This API has been designed to facilitate typical telephony interaction
          scenarios, such as:
          <ol>
            <li>incoming call dialog</li>
            <li>ongoing call dialog</li>
            <li>request PIN code dialog</li>
            <li>typing emergency numbers in PIN code dialog</li>
            <li>typing phone numbers, remote party id's and MMI commands in
              dialer
            </li>
          </ol>
        </p>
        <p>
          Implementations SHOULD make sure the phone calls are controllable by
          the user at any point in time while the call is active.
        </p>
        <p>
          Implementations SHOULD validate user input using the
          <code>parseCommand()</code> method of the
          <a><code>TelephonyCommandParser</code></a> interface.
        </p>
      </section><!-- User interaction guidelines -->
    </section><!-- Security and privacy -->

    <!-- - - - - - - - - - -  Managing Call History   - - - - - - - - - - - -->
    <section class="appendix"> <h2>Managing call history</h2>
      <p>
        The <a>CallHistoryEntry</a> interface describes the minimum set of
        properties which a user agent would need to support for call history
        entries. For multiparty call there needs to be a separate
        <a>CallHistoryEntry</a> object for each call participant, sharing the
        same value for the <a>conferenceId</a> attribute.
      </p>
      <p class='note'>
        It is up the the implementations and applications how to store and
        access call history. This document only specifies the minimum content
        of the data to be saved.
      </p>
      <!-- - - - - - - - - - - CallHistoryEntry Interface - - - - - - - - - -->
      <section> <h3><code>CallHistoryEntry</code> interface</h3>
        <dl title="interface CallHistoryEntry" class="idl">
          <dt> readonly attribute DOMString          remoteParty      </dt>
          <dt> readonly attribute DOMString          serviceId        </dt>
          <dt> readonly attribute DOMString?         conferenceId     </dt>
          <dt> readonly attribute Date               startTime        </dt>
          <dt> readonly attribute unsigned long long duration         </dt>
          <dt> readonly attribute CallDirection      direction        </dt>
          <dt> readonly attribute DisconnectReason?  disconnectReason </dt>
          <dt> readonly attribute boolean            emergency        </dt>
        </dl>
        <!-- - - - - - - - - - -  remoteParty attribute - - - - - - - - - - -->
        <section> <h3>The <code>remoteParty</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-remoteParty">remoteParty</dfn> attribute, the
            user agent MUST return the <a>remote party id</a> (e.g. telephone
            number) of the call participant.
          </p>
        </section><!-- remoteParty attribute -->
        <!-- - - - - - - - - - -  serviceId attribute - - - - - - - - - - - -->
        <section> <h3>The <code>serviceId</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-serviceId">serviceId</dfn> attribute, the user
            agent MUST return the <a>telephony service id</a> of the
            <a>telephony service</a> used for the call.
          </p>
        </section><!-- serviceId attribute -->
        <!-- - - - - - - - - - -  conferenceId attribute  - - - - - - - - - -->
        <section> <h3>The <code>conferenceId</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-conferenceId">conferenceId</dfn> attribute, the
            user agent MUST return the <a>conference id</a> of the call, if the
            call has participated in a multiparty call. Otherwise, return
            <code>null</code>. string.
          </p>
        </section><!-- conferenceId attribute -->
        <!-- - - - - - - - - - - startTime attribute  - - - - - - - - - - - -->
        <section> <h3>The <code>startTime</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-startTime">startTime</dfn> attribute, the user
            agent MUST return the starting time of the call, measured from when
            the call is in <a>active</a> state.
          </p>
        </section><!-- startTime attribute -->
        <!-- - - - - - - - - - -  duration attribute  - - - - - - - - - - - -->
        <section> <h3>The <code>duration</code> attribute </h3>
          <p>
            When getting the <dfn id="CallHistoryEntry-duration">duration</dfn>
            attribute, the user agent MUST return the duration of the call
            expressed in milliseconds.
          </p>
        </section><!-- duration attribute -->
        <!-- - - - - - - - - - -  CallDirection attribute - - - - - - - - - -->
        <section> <h3>The <code>direction</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-direction">direction</dfn> attribute, the user
            agent MUST return the <a>CallDirection</a>.
          </p>
        </section><!-- CallDirection attribute -->
        <!-- - - - - - - - - - - disconnectReason attribute  - - - -  - - - -->
        <section> <h3>The <code>disconnectReason</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-disconnectReason">disconnectReason</dfn>
            attribute, the user agent MUST return the <a>DisconnectReason</a>
            if available, or return <code>null</code> otherwise.
          </p>
        </section><!-- disconnectReason attribute -->
        <!-- - - - - - - - - - -   emergency attribute  - - - - - - - - - - -->
        <section> <h3>The <code>emergency</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-emergency">emergency</dfn> attribute, the user
            agent MUST return <code>true</code> if the call was an emergency
            call, or <code>false</code> otherwise.
          </p>
        </section><!-- emergency attribute -->
      </section><!-- CallHistoryEntry Interface-->
      <!-- - - - - - - - - - -  CallDirection Enum  - - - - - - - - - - - - -->
      <section> <h2><a>CallDirection</a> enum</h2>
        <dl class="idl" title="enum CallDirection">
          <dt>dialed</dt>
          <dt>received</dt>
          <dt>missed</dt>
          <dt>missed-new</dt>
        </dl>
        <p>The call direction can take the following values:</p>
        <dl>
          <dt>"dialed"</dt>
          <dd>The call has been dialed.</dd>

          <dt>"received"</dt>
          <dd>The call has been received.</dd>

          <dt>"missed"</dt>
          <dd>The call has been missed.</dd>

          <dt>"missed-new"</dt>
          <dd>The call was a missed call not seen yet by the user.</dd>
        </dl>
      </section><!-- CallDirection Enum -->
    </section><!-- Managing Call History -->


    <!-- - - - - - - - - - - - - -  Changes - - - - - - - - - - - - - - - - -->
    <section class="appendix" id="Changes">
      <h2>
        Changes
      </h2>
      <p>
        The following is a list of substantial changes to the document. For a
        complete list of changes, see the <a href=
        "https://github.com/sysapps/telephony/commits/gh-pages">change log on
        Github</a>. You can also view the <a href=
        "https://github.com/sysapps/telephony/issues?page=1&amp;state=closed">
        recently closed bugs</a>.
      </p>
      <ul>
        <li>No changes yet.
        </li><!-- 
        <li><a href="">Link to bug that documents the change</a></li>
        -->
      </ul>
    </section>
    <!-- - - - - - - - - - - - - - Acknowledgements - - - - - - - - - - - - -->
    <section>
      <h2>
        Acknowledgements
      </h2>
      <p>
        The editors would like to express their gratitude to the Mozilla B2G
        Team for their technical guidance, implementation work and support,
        especially to Ben Turner and Jonas Sicking, the authors of the
        <cite><a href="https://wiki.mozilla.org/WebAPI/WebTelephony">B2G
        WebTelephony API</a></cite>. Also, thanks to Denis Kenzior
        (<cite><a href="https://ofono.org/">ofono</a></cite> maintainer) and
        Oleg Zhurakivskyy of Intel Open Source Technology Center, and many
        others for their advice and support.
      </p>
    </section>
  </body>
</html>

<!--

GSM TS 04.08 call control states
GSM TS 04.83 call hold states
GSM TS 04.80 error values
GSM TS 24.084 Phase-4 MPTY
GSM TS 23.018 Basic call handling; Technical realization
      http://www.3gpp.org/ftp/Specs/html-info/23018.htm
IMS TS 23.228 IP Multimedia Subsystem (IMS); Stage 2
      http://www.3gpp.org/ftp/Specs/html-info/23228.htm

- any call ID will serve as a transaction ID
- implementation to generate a MPTY_ID which refers to the list of all active
call ID's in the mpty call

-->
