<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>
      Web Telephony API
    </title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            class='remove'>
    </script>
    <script class="remove">
    /*Respec configuration*/
    var respecConfig = {
          specStatus:           "ED",
          shortName:            "telephony",
          noLegacyStyle:        true,
          publishDate:          "",
          previousPublishDate:  "",
          previousMaturity:     "",
          edDraftURI:           "http://www.w3.org/2012/sysapps/telephony/",
          // lcEnd:                "",
          crEnd:                "",
          editors: [
            { name: "Marcos Cáceres", company: "Mozilla",
                    companyURL: "http://www.tid.es/" },
            { name: "José M. Cantera", company: "Telefónica",
                    companyURL: "http://www.tid.es/" },
            { name: "Eduardo Fullea", company: "Telefónica",
                    companyURL: "http://www.tid.es/" },
            { name: "Zoltan Kis", company: "Intel",
                    companyURL: "http://www.intel.com/" },
            { name: "John Lyle", company: "University of Oxford",
                    companyURL: "http://www.cs.ox.ac.uk/" },
          ],
          inlineCSS:    true,
          noIDLIn:      true,
          // extraCSS:     ["../ReSpec.js/css/respec.css"],
          wg:           "System Applications Working Group",
          wgURI:        "http://www.w3.org/2012/sysapps/",
          wgPublicList: "public-sysapps",
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/58119/status",
          otherLinks: [{
            key: "Repository",
            data: [{
                    value: "We are on Github.",
                    href: "https://github.com/sysapps/telephony"
                }, {
                    value: "File a bug.",
                    href: "https://github.com/sysapps/telephony/issues"
                }, {
                    value: "Commit history.",
                   href: "https://github.com/sysapps/telephony/commits/gh-pages"
                }
            ]
        }]
    };
    </script>
    <style>
    /*HTML5 Tidy screws up if this line is missing.*/
    figure{
        display: block;
        width: auto;
        margin: 2em auto;
        text-align: center;
    }
    figcaption{
        display: block;
        margin-top: 1em;
    }
    </style>
  </head>
  <body>
    <!-- - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - -->
    <section id="abstract">
      <p>
        This specification defines an API to manage telephony related
        functionality. The main targeted use case is enabling implementations
        of 'dialer' applications, supporting conference calls and multiple
        <a>telephony service</a>s.
      </p>
      <p>
        In addition, a larger group of applications may benefit from knowing telephony related contextual information, such as the presence of a
        telephony call in the system, and what media is connected to it. This
        would require lesser API permissions.
      </p>
      <p>
        This API does not specify how to invoke the system dialer application
        with a URI of the remote party, as this use case is supposed to be
        handled by a different API.
      </p>
    </section>

    <!-- - - - - - - - - - -  Status of this document - - - - - - - - - - - -->
    <section id="sotd">
      <p>
        Implementors should be aware that this specification is not stable.
        <strong>Implementors who are not taking part in the discussions are
        likely to find the specification changing out from under them in
        incompatible ways.</strong> Vendors interested in implementing this
        specification before it eventually reaches the Candidate Recommendation
        stage should join the aforementioned mailing lists and take part in the
        discussions.
      </p>
      <p>
        Significant changes to this document since last publication are
        documented in the <a href="#Changes">Changes section</a>.
      </p>
    </section>

    <!-- - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - -->
    <section class="informative"> <h2>Introduction</h2>
      <p>
        The <cite>Web Telephony API</cite> allows applications to manage
        interaction with telephony call signaling, but does not handle audio
        channels management.
      </p>
      <p>
        A simple example for making a telephony call is provided below:
      </p>
      <pre title="Dialing a call" class="example highlight">
        var call = new TelephonyCall('+1234567890');
        call.dial().then(function() { console.log("Call active"); });
      </pre>
      <p>
        A simple example for receiving a telephony call is provided below:
      </p>
      <pre title="Receiving calls" class="example highlight">
        navigator.telephony.addEventListener("calladded",
          function(evt) {
            evt.call.addEventListener("statechange", stateHandler, true);
            if (call.state == 'incoming') {
              // display the dialog for 'incoming call'
              // at some point call one of these methods:
              // call.accept(), call.disconnect(), call.hold()
            }
          }, true);  // capture if we are the dialer

        function stateHandler(TelephonyCall call) {
          // ...
          if (call.state == 'active')
             window.console.log('Connected!');
          else if(call.state == 'disconnected') {
             window.console.log('Disconnected!');
             // update call history
          }
          // ...
        }

      </pre>
      <p>
        A simple example for subscribing to telephony contextual information is
        provided below:
      </p>
      <pre title="Telephony information" class="example highlight">
        navigator.telephony.addEventListener("calladded",
          function(evt) {
            console.log("New telephony call, now I need to adapt");
          }, false);  // don't capture!

        navigator.telephony.addEventListener("active",
          function(evt) {
            console.log("A call became active, that's why I can't play music");
          }, false);

        navigator.telephony.addEventListener("callremoved",
          function(evt) {
            if (navigator.telephony.active)
              console log("There is no active call, I can safely work");
            else
              console.log("There is still an active call");
          }, false);
      </pre>
      <!--p>
        The use cases for this specification are collected in the <a href=
        'http://www.w3.org/wiki/System_Applications_WG:_Telephony_API'>wiki
        page</a> of this API.
      </p-->
      <p>
        The following specifications informed the design of the <cite>Web
        Telephony API</cite>: for <abbr title=
        "Global System for Mobile Communications">GSM</abbr> the [[!GSM-CALL]]
        suite, for IMS/SIP the [[!IMS]] suite, for <abbr title=
        "Extensible Messaging and Presence Protocol ">XMPP</abbr> the
        [[!JINGLE]] specification.
        This API has been designed to be forward compatible with
        <abbr title="Session Initiation Protocol">SIP</abbr> and
        <abbr title="Extensible Messaging and Presence Protocol ">XMPP</abbr>
        calls, by adding properties to later versions of the API, but currently
        IMS/SIP and XMPP calls are not explicitly supported in this version.
      </p>
      <!--p class='issue'>
        It is under discussion whether a system message should be propagated
        when a CDMA telephony call is active, since not all CDMA networks
        support concurrent services. Therefore, many applications will lose
        their data connection when the end user is in a voice call. However,
        such message should be sent whenever the data connection is lost for any
        reason, so such a system message should be issued by the implementation
        of the data connection handling.
      </p-->
    </section>

    <!-- - - - - - - - - - - - - - Use cases  - - - - - - - - - - - - - - - -->
    <section class="informative"> <h2>Use cases</h2>
      <section> <h3>Generic use cases</h3>
      <p>
        Use cases requiring lower privilege levels are the following:
        <ol>
          <li>determine if there is an <a>active call</a> in the system</li>
          <li>determine when a new call is added, or removed</li>
          <li>get basic and impersonal information about ongoing calls, such as
            call id, call state, and <a>telephony service id</a>, etc.</li>
        </ol>
        These are referred to as <dfn>call contextual information</dfn> in this
        specification. The primary reason to follow call contextual information
        is to optimize resource usage during telephony calls are being managed.
        For instance, a media player may stop receiving data while there is an
        active call, since the media stream is corked by the system anyway.
      </p>
      <p class="issue">
        The permission model is not finished yet and it will affect the later
        decision on how to expose lower vs higher privilege functionality in
        this API.
      </p>
      </section>
      <section> <h3>Dialer specific use cases</h3>
      <p>
        This API has been designed to facilitate typical telephony interaction
        scenarios, such as:
        <ol>
          <li>incoming call dialog</li>
          <li>ongoing call dialog, which may differ for different protocols
            (e.g. GSM and CDMA)</li>
          <li>outgoing call (dialer) dialog</li>
          <li>dialing emergency numbers in PIN code dialog</li>
          <li>typing remote party identifiers (phone numbers) and MMI commands
            in dialer</li>
          <li>support <a>telephony service</a> (subscriber identity) selection
            for dual-SIM and multi-SIM phones. Note that dual-SIM allows both
            services being active (i.e. receive and dial calls), whereas
            multi-SIM allows only one active service at a time.</li>
          <li>support <a>default telephony service</a> selection.</li>
          </li>
        </ol>
      </p>
      <p>
        The technical use cases requiring elevated permissions are the
        following:
        <ul>
         <li>Call management
          <ol>
          <li>make a call to a remote party and subscribe to notifications about
            the state changes of the call</li>
          <li>when making a call, if multiple subscriber identities are
            configured, optionally choose which identity should be used for a
            dialed call, otherwise a default identity is used</li>
          <li>when making a call, optionally hide the caller identity, if the
            <a>telephony service</a> supports it </li>
          <li>list the ongoing telephony calls</li>
          <li>retrieve the active call, if any</li>
          <li>receive phone calls and subscribe to notifications about incoming
            calls and their state changes</li>
          <li>handle waiting calls, when the service is available and enabled
            </li>
          <li>put calls on hold</li>
          <li>resume held calls</li>
          <li>create phone conference, when the device and
            <a>telephony service</a> supports it</li>
          <li>deflect an incoming or waiting call to be handled by another
            remote party, when the <a>telephony service</a> supports it</li>
          <li>transfer an ongoing call with a remote party to become a call
            between the remote party and a third party, if the
            <a>telephony service</a> supports it</li>
          <li>provide sufficient instrumentation that applications could handle
            user interaction differences for different telephony protocols
            (such as CDMA 3-way calling vs. GSM Multiparty calls.</li>
          </ol>
         </li>
         <li>Tone management
          <ol>
          <li>send DTMF tones to the telephony network, and optionally set
          DTMF mark and space parameters.</li>
          </ol>
         </li>
         <li>Emergency calls
          <ol>
          <li>dial an emergency call, even without having a SIM card, if it is
            technically possible (e.g. there is a telephony modem or service to support it)</li>
          <li>list the usable emergency numbers for a given
            <a>telephony service</a>, if supported by the device and the
            telephony network</li>
          <li>subscribe to notification when the list of emergency numbers
            changes</li>
          </ol>
         </li>
         <li>Man-Machine Interface (MMI) Code Support
           Global Certification Forum compliancy requires support for MMI codes
           by dialer applications. Hence dialers need to handle multiple types
           of input, which can be dialed numbers, MMI codes, PIN codes and other
           input, all handled by different telephony services, e.g. MMI codes
           are handled by Supplementary Services in GSM. The API should provide
           pre-validating and parsing user input in order to determine whether
           does it match a MMI code sendable to Supplementary Services
           (otherwise all applications would need to parse all MMI codes
           themselves). Codes not matched by the implementation need to be
           handled by the applications using this API.
         </li>
         <li>Telephony service management
          <ol>
          <li>set a default subscriber identity, so that the identity is
            optional to provide before dialing </li>
          <li>list the available <a>telephony service</a>s</li>
          <li>subscribe to notifications about the activation of new telephony
            services in the system</li>
          <li>subscribe to notifications about the removal of telehony services
            in the system</li>
          </ol>
         </li>
        </ul>
      </p>
      </section>
      <section> <h3>Omitted use cases</h3>
        <p>
          Further telephony use cases which are currently <b>not</b> explicitly handled by this API:
          <ol>
          <li>start the system dialer with a given phone number or phone URI
            </li>
          <li>set the default sound volume for telephony</li>
          <li>set the sound volume during a call</li>
          <li>mute and unmute the microphone for a call</li>
          <li>use headphones with calls</li>
          <li>use external displays with calls </li>
          <li>select between audio sources</li>
          <li>select between audio targets (speaker, headphones, etc)</li>
          <li>see and manage call capabilities during a call, such as is
            conference call possible, is video call possible, etc </li>
          <li>set and check network services, such as call forwarding, call
            barring, network selection mode, call counters, etc.</li>
          <li>save the list of past calls into call history.</li>
          </ol>
        </p>
      </section>
    </section>

    <!-- - - - - - - - - - - - - - Permissions  - - - - - - - - - - - - - - -->
    <section class="informative"> <h2>Permissions</h2>
      <p>
        This API conforms to the permission model defined for System
        Applications, with 2 targeted levels of permission: one generic
        permission which could be used by any page or application in order to
        obtain <a>call contextual information</a>, and one restricted permission
        level, which enables access to the full API specified in this document.
      </p>
    </section>

    <!-- - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - -->
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in
        this specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]],
        as this specification uses that specification and terminology.
      </p>
    </section>

    <!-- - - - - - - - - - - - - -  Dependencies  - - - - - - - - - - - - - -->
    <section> <h2>Dependencies</h2>
      <p>
        This specification depends on the following interfaces and concepts
        defined in other specifications.
      </p>
      <p>
        The following dependencies are defined in [[!HTML]]:
        <dfn><code><a
        href="http://www.whatwg.org/specs/web-apps/current-work/#eventhandler">
        EventHandler</a></code></dfn> interface, <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#queue-a-task">queue
        a task</a></dfn>, <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#event-handlers">
        event handler</a></dfn>, <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#origin">origin</a>
        </dfn>,
        <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#task-source">task
        source</a></dfn>.
      </p>
      <p>
        The following dependencies are defined in [[!DOM4]]: the <dfn><a href=
        "http://dom.spec.whatwg.org/#event"><code>Event</code></a></dfn> and
        the <dfn><a href=
        "http://dom.spec.whatwg.org/#promise"><code>Promise</code></a></dfn>
        interfaces, the concepts of a <a href=
        "http://dom.spec.whatwg.org/#concept-resolver"><dfn>resolver</dfn></a>,
        <dfn><a href="http://dom.spec.whatwg.org/#concept-event-fire">fire an
        event</a></dfn>.
      </p>
    </section> <!-- Dependencies -->

    <!-- - - - - - - - - - -  Task Source - - - - - - - - - - - - - - - - - -->
    <section> <h2>Task Source</h2>
      <p>
        The <a>task source</a> for all <a title="queue a task">tasks queued</a>
        in this specification is the <dfn>telephony task source</dfn>.
      </p>
    </section>

    <!-- - - - - - - - - - - Extended interface Navigator - - - - - - - - - -->
    <section> <h2>Extensions to <code>Navigator</code> object</h2>
      <p>
        The <a>TelephonyManager</a> interface is exposed on [[!HTML]]'s
     <a href="http://www.whatwg.org/specs/web-apps/current-work/#dom-navigator">
        <code>Navigator</code></a> object.
      </p>
      <dl title="partial interface Navigator" class="idl">
        <dt>
          readonly attribute TelephonyManager telephony
        </dt>
      </dl>
      <!-- - - - - - - - - - - - telephony attribute  - - - - - - - - - - - -->
      <section> <h3>The <code>telephony</code> attribute</h3>
      <p>
        When getting the <dfn id="widl-Navigator-telephony">telephony</dfn>
        attribute, the user agent MUST return the <a>TelephonyManager</a>
        object, which provides telephony related functionality.
      </p>
      </section> <!-- telephony attribute -->
    </section> <!-- Navigator -->


    <!-- - - - - - - - - - - - Interface TelephonyManager - - - - - - - - - -->
    <section> <h2>The <a>TelephonyManager</a> Interface</h2>
      <p>
        The <dfn>TelephonyManager</dfn> interface provides access to telephony
        functionality related to <a>telephony call</a> management,
        sending [[!DTMF]] tones, and handling emergency numbers and calls.
      </p>
      <dl title="TelephonyManager implements CallManager" class="idl"></dl>
      <dl title="TelephonyManager implements ToneManager" class="idl"></dl>
      <dl title="interface TelephonyManager" class="idl">
        <dt>readonly attribute EmergencyManager emergency</dt>
        <dt>readonly attribute CommandParser command</dt>
        <dt>readonly attribute ServiceManager service</dt>
      </dl>
      <p>
        Each of these interfaces will be expanded in the following sections.
      </p>
    </section> <!-- TelephonyManager -->

    <!-- - - - - - - - - - - - - - Telephony Calls  - - - - - - - - - - - -->
    <section> <h2>Telephony Calls</h2>
      <section> <h3>Definitions</h3>
      <section><h3>Telephony call</h3>
      <p>
          A <dfn>telephony call</dfn> results from a <a>telephony service</a>'s
          attempt to establish a connection for communication between two or
          more parties. Telephony calls involving more than two parties are
          referred to as a <a>conference call</a>.
      </p>
      </section>
      <section><h3>Call state</h3>
      <p>
          In the process of establishing and maintaining a connection between
          multiple parties, a telephony call transitions through various
          <a>call state</a>s. A <a>telephony call</a> is always in a defined
          <a>call state</a>, which can change over time.
      </p>
      </section>
      <section><h3>Outbound and inbound call</h3>
      <p>
          Telephony calls initiated by a telephony service of the system is an
          <dfn>outbound call</dfn>. Conversely, a telephony call from a remote
          party is an <dfn>inbound call</dfn>.
      </p>
      </section>
      <section><h3>Call id</h3>
      <p>
          Every telephony call has a <dfn>call id</dfn>, which is a string that
          uniquely identifies the call and call history.
      </p>
      </section>
      <section><h3>Active call</h3>
      <p>
          An <dfn>active call</dfn> is a <a>telephony call</a> in the
          <a>active</a> state representing a connected call which is bound to
          the media input and output devices (e.g. microphone, speaker, tone generator). Note that a call on hold is also active from a call
          signaling point of view, but not bound to media input and output
          devices.
      </p>
      </section>
      <section><h3>Remote party id</h3>
      <p>
          A <dfn>remote party id</dfn> uniquely identifies a participant
          (a.k.a. remote party) in a telephony call in the given
          <a>telephony service</a>, such as a phone number.
      </p>
      </section>

      <!-- - - - - - - - - - - - - -  Conference calls  - - - - - - - - - - -->
      <section> <h3>Conference calls</h3>
        <p>
          A <dfn>conference call</dfn> is a <a>telephony call</a> with multiple
          remote party participants. The way conference calls are handled are
          quite much different depending on the telephony protocol.
        </p>
        <p class="note">
          This of the API version supports GSM multiparty calls and CDMA 3-way
          calls. Supporting SIP and XMPP conferences is possible in the future,
          and would require additional method parameters to conference creation.
        </p>
        <p>
         Creating GSM multiparty calls involve the following user interaction:
         <ol>
           <li>dial the first number</li>
           <li>when the call is active, put the call on hold</li>
           <li>dial the second number</li>
           <li>when the second call is active, press the 'Conference' button
             </li>
           <li>optionally repeat the steps so far to add more calls</li>
           <li>any participating call can be split from the conference call
             for private chat, during which the conference call is put on hold
             </li>
           <li>during private chat, it is possible to re-merge the call into the
             conference call using the same procedure as before</li>
           <li>disconnecting a GSM conference call will disconnect all member
             calls.</li>
         </ol>
        </p>
        <p>
         In CDMA, only a limited form of conference call is supported, called
         3-way call, which is usually mapped to multiple presses of the 'Call'
         button, which in background uses modem AT commands (ATD, ATH and flash)
         to achieve the desired action. Handling 3-way calls involve the
         following user interactions:
         <ol>
           <li>dial the first number (involves the ATD command)</li>
           <li>when the call is active, dial the second number (by sending a
             "flash" command with the second number), which automatically puts
             the first call on hold</li>
           <li>when the second call is active, press the 'Call' button to make
             3-way call (by sending a "flash" command)</li>
           <li>while the 3-way call is active, press the 'Call' button to
             disconnect the second call (which sends a "flash" command</li>
           <li>while the 3-way call is active, any incoming call SHOULD be
             rejected</li>
           <li>while the 3-way call is active, pressing 'Hangup' (ATH command)
           will disconnect all calls.</li>
         </ol>
        </p>
        <p>
         The common way to support these user interactions by this API, there is
         possible programmatic support for the following actions:
         <ol>
           <li>dial the first call by calling the <code>dial()</code> method
             </li>
           <li>dial the second call, which puts the first call on hold</li>
           <li>create the conference call from the held and active calls by
             calling the <code>createConference()</code> method</li>
           <li>disconnecting the second call works from both CDMA and GSM, by
             calling the <code>disconnect()</code> method on the second call
             object</li>
           <li>disconnecting any other than the last call will work in GSM, but
             will hang up all calls in CDMA.</li>
         </ol>
        </p>
        <p>
          This API has been designed so that conference calls could be
          controlled as a single telephony call by a
          <a><code>TelephonyCall</code></a> object, i.e. could be <a>held</a>,
          made <a>active</a>, <a>disconnected</a> from all participants in one
          transaction. If the <a>telephony service</a> supports it, other
          participants (modeled with <a><code>TelephonyCall</code></a> objects)
          can be joined with a conference call, and a participant can be
          split off the conference call for a private conversation, while the conference call is put on hold. This model is closest to GSM
          multiparty calls, but it can handle CDMA 3-way calls (and later SIP and
          XMPP conferencing too, by adding an optional parameter to the
          <code>createConference</code> method).
        </p>
        <p class="note">Conference calls can be used for managing calls merged
          using <dfn>client side merge</dfn>, implemented by the
          <code>merge()</code> method of the <a><code>CallManager</code></a>
          interface, and which in fact means the User Agent implements a local
          conference control point, with the audio channels of the active call
          (be it simple or conference) mixed with the audio channels of another
          call from a different <a>telephony service</a>.
          This needs support from the underlying audio system and the
          telephony protocol stack, and it is managed completely on the client
          side, unlike <a>conference call</a>s, which are managed by the
          <a>telephony service</a>.
          Implementations are not required to support <a>client side merge</a>.
        </p>
        <p>
          Every conference call has a unique <dfn>conference id</dfn> that
          identifies a <a>conference call</a> in the system.
        </p>
        <p>
          When a <a>conference call</a> control object <var>confCall</var> of
          type <a><code>TelephonyCall</code></a> is created, the
          <a>user agent</a> MUST run the following steps:
          <ol id="conference-id-steps">
            <li>Generate an identifier stored in the <code>callId</code>
              attribute, which MUST be unique in the system and the local call
              history.</li>
            <li>The implementation SHOULD map this identifier to the transaction
              identifiers accepted by the telephony service.
              In GSM, the <code>callId</code> of any participating call
              could be used in a multiparty operation as a transaction
              identifier. The transaction identifiers received from the network
              SHOULD be mapped back by the implementation to the unique
              conference call identifier.
              In CDMA, the <a>user agent</a> SHOULD track the call objects
              participating in 3-way calling, in addition to the conference
              control object, therefore the <code>callId</code> is generated and
              maintained by the <a>user agent</a>, without support from the
              telephony protocol.
            </li>
            <li>The conference id MUST be used as the value for the
              <code>conferenceId</code> property of the
              <a><code>TelephonyCall</code></a> objects participating in the
              conference call, and also for <var>confCall</var>. Therefore the
              <code>callId</code> and the <code>conferenceId</code> properties
              of <var>confCall</var> MUST have the same value.</li>
          </ol>
        </p>
      </section><!-- Multiparty calls -->

      <!-- - - - - - - - - - - - - - Call states  - - - - - - - - - - - - - - -
      ======= A short introducton on call state management for editors ========
      _________________________________________________________________________
      CDMA states for dialed calls       | Mapping to the API or [modem] state
      _________________________________________________________________________
          [ DIAL button pressed ]        | dialing
          -> channel request             |
          <- immediate assignment        |
          -> service request             |
          <- authentication request      |
          -> authentication response     |
          <- cyphering command           |
          -> cyphering complete          |
          -> setup                       |
          <- call confirmed              |
          <- assignment command          |
          -> assignment completed        |
          <- alerting                    | alerting
          <- connect                     |
          -> connect ack                 | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      CDMA states for received calls     | Mapping to the API or [modem] state
      _________________________________________________________________________
          <- paging request              |
          -> channel request             |
          <- immediate assignment        |
          -> paging response             |
          <- authentication request      |
          -> authentication response,    |
          <- cyphering command           |
          -> cyphering complete          |
          <- call setup                  |
          -> call confirmed              | incoming
          <- assignment command          |
          -> assignment complete         |
          -> call alerting               | [ringing]
          [ OK button pressed ]          | accepted
          -> connect                     |
          <- connect ack                 | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      GSM states for dialed calls        | Mapping to the API or [modem] state
      _________________________________________________________________________
          [ DIAL button pressed ]        | dialing
          -> channel request             |
          <- immediate assignment        |
          -> service request             |
          -> connection request          |
          <- cyphering command           |
          -> cyphering complete          |
          -> call setup                  |
          <- connecting                  | connecting
          [call mode: signaling -> voice]|
          [routing, voicemail, errors]   |
          <- call confirmed              |
          <- alerting                    | alerting
          <- connect                     |
          -> connect ack                 | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      GSM states for received calls      | Mapping to the API or [modem] state
      _________________________________________________________________________
          <- interrogation procedure     |
          <- paging request              |
          -> channel request             |
          <- immediate assignment        |
          -> paging response             |
          - cyphering                    |
          <- call setup                  | incoming
          -> call confirmed              |
          -> call alerting               | [ringing]
          [ OK button pressed ]          | accepted
          -> connect                     |
          <- connect ack                 | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      SIP/IMS states for dialed calls | Mapping to the API or [SIP stack] state
      _________________________________________________________________________
          [ DIAL button pressed ]        | dialing
          -> SIP Invite                  | [initializing]
          <- SIP 183 Session Progress    |
          [ SDP ]                        |
          -> PRACK                       | [initialized]
          [Caller PDP Context activation]|
          <- SIP 200 OK                  |
          -> UPDATE [ context ]          |
          <- SIP 200 OK                  |
          [ remote starts ringing ]      |
          <- SIP 180 RINGING             | alerting
          -> PRACK                       |
          [ remote accepts]              |
          <- SIP 200 OK                  |
          -> ACK                         | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      SIP states for received calls  | Mapping to the API or [SIP stack] state
      _________________________________________________________________________
          <- SIP Invite                  | incoming
          -> SIP 183 Session Progress    | [initializing]
          [ SDP ]                        |
          <- PRACK                       |
          -> SIP 200 OK                  | [initialized]
          [ PDP Context activation]      |
          <- UPDATE [ context ]          |
          -> SIP 200 OK                  |
          [ locally ringing ]            |
          -> SIP 180 RINGING             | [ringing]
          <- PRACK                       |
          [ accepts ]                    | accepted
          -> SIP 200 OK                  |
          <- ACK                         | active (connected)
          <-> dataspeech                 |
      _________________________________________________________________________
      XMPP states for dialed calls   | Mapping to the API or [XMPP stack] state
      [ XMPP XEP-0166 Jingle ]       | (may depend on XMPP implementation)
      _________________________________________________________________________
          DIAL button pressed            | dialing
          -> session-initiate            |
          <- ack                         |
          <- session-accept              | alerting
          -> ack                         | active (connected)
          <-> media session              |
          <- session-terminate           |
          -> ack                         | disconnected
      _________________________________________________________________________
      XMPP states for received calls | Mapping to the API or [XMPP stack] state
      [ XMPP XEP-0166 Jingle ]       | (may depend on XMPP implementation)
      _________________________________________________________________________
          <- session-initiate            | incoming
          -> ack                         |
          [ locally ringing ]            | [ringing]
          [ user accepts ]               | accepted
          -> session-accept              |
          <- ack                         | active (connected)
          <-> media session              |
          -> session-terminate           | disconnecting
          <- ack                         | disconnected
      _________________________________________________________________________

      ## Multiparty call sequences and states

      * GSM TS 24.084.
          "There are four auxiliary states associated with the MPTY service:
          - Idle;
          - MPTY request; A request has been made to add this call to the MPTY.
          - Call in MPTY; This call is in the MPTY.
          - Split request; A request has been made to remove this call from the
          MPTY.
          These Auxiliary states apply in addition to the GSM 04.08 call control
          states and the GSM 04.83 call hold states. Thus for example, an active
          call in a held MPTY has the state (Active, Call held, Call in MPTY).
          Not all states are allowed, for example an MPTY cannot be split while
          it is held, so (Active, Call held, Split request) is forbidden."

          Instead of this, we offer a model when states describe valid
          multiparty states. Valid state transitions for a multiparty call are:
          * joining -> active
          * active -> holding -> held
          * held -> resuming -> active (connected)
          * any state -> [disconnecting]-> disconnected

       * Creating GSM multiparty calls:
         - dial first number, then put on hold
         - dial second number, then press 'Multiparty' button


       * CDMA 3-way calling is mapped to multiple presses of the 'call' button:
         - dial the first number
         - when call active, press 'call' to put the first call on hold
         - dial the second number
         - when second call is active, press 'call' button to make 3-way call
         - while 3-way call active, press 'call' button to disconnect the
           second call
         - while 3-way call active, any incoming call should be rejected
         - while 3-way call active, pressing 'hangup' will hangup all calls.

       * The common way to handle by the API:
         - dial first call
         - hold first call
         - dial second call
         - create the conference call from the held and active calls
         - disconnecting the second call is OK from both CDMA and GSM
         - disconnecting the first call is OK in GSM, but will hang up all calls
           in CDMA
         - in GSM, any participating call can be split from the conference call
           for private chat, during which the conference call is on hold
         - during private chat, it is possible to re-merge the call into the
           conference
         - disconnecting a GSM conference call will disconnect all member calls.

      - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   -->
      <section> <h2>Call states</h2>
        <p>
          A <dfn>call state</dfn> represents the state of interaction between a
          <a>telephony service</a>, the telephony network, the API, and
          one or more remote parties.
        </p>
        <p>
          in GSM, there are 3 kinds of call states:
          <ul>
            <li>GSM TS 04.08 defines call <i>control</i> states,</li>
            <li>GSM TS 04.83 defines call <i>hold</i> states, and </li>
            <li>GSM TS 24.084 defines auxiliary states associated with a
              multiparty call.</li>
          </ul>
          This would result in a 3-dimensional call state space, where not all
          combinations are allowed, for example a call cannot be split from a conference call while it is held.
        </p>
        <p>
          Instead of using a 3-dimensional call state space, this API uses a one
          dimensional call state model, in which call states map to valid
          combinations in of 3-dimensional states, and are able to describe
          valid state transitions.
        </p>
        <p>
          Within the API, the call states are represented by the
          <code><a>CallState</a></code> enum.
        </p>
        <!-- - - - - - - - - - -  CallState Enum  - - - - - - - - - - - - - -->
        <section> <h3><dfn>CallState</dfn> enum</h3>
          <dl title="enum CallState" class="idl">
            <dt><a>dialing</a></dt>
            <dt><a>connecting</a></dt>
            <dt><a>alerting</a></dt>
            <dt><a>active</a></dt>
            <dt><a>incoming</a></dt>
            <dt><a>waiting</a></dt>
            <dt><a>accepted</a></dt>
            <dt><a>holding</a></dt>
            <dt><a>held</a></dt>
            <dt><a>resuming</a></dt>
            <dt><a>redirecting</a></dt>
            <dt><a>transferring</a></dt>
            <dt><a>disconnecting</a></dt>
            <dt><a>disconnected</a></dt>
            <dt><a>joining</a></dt>
            <dt><a>conference</a></dt>
            <dt><a>splitting</a></dt>
          </dl>
          <p>
            The meaning of the call states referenced in this API is the
            following:
          </p>
          <dl>
            <dt><dfn>dialing</dfn></dt>
            <dd>An outbound call is being dialed by a telephony service.</dd>

            <dt><dfn>connecting</dfn></dt>
            <dd>A request to establish the call has been made and it is
              progressing.
            </dd>

            <dt><dfn>alerting</dfn></dt>
            <dd>The destination number has been reached and alerting is taking
              place.
            </dd>

            <dt><dfn>active</dfn></dt>
            <dd>The call is ongoing.</dd>

            <dt><dfn>incoming</dfn></dt>
            <dd>An incoming call is being received whilst no other call is
              progressing.
            </dd>

            <dt><dfn>waiting</dfn></dt>
            <dd>An incoming call that has been received whilst there was another
              call progressing, and the call waiting service is active.
            </dd>

            <dt><dfn>accepted</dfn></dt>
            <dd>An incoming call has been accepted and is being connected.</dd>

            <dt><dfn>holding</dfn></dt>
            <dd>The call is being put on hold.</dd>

            <dt><dfn>held</dfn></dt>
            <dd>The call has been put on hold.</dd>

            <dt><dfn>resuming</dfn></dt>
            <dd>The call, which was on hold, is being resumed.</dd>

            <dt><dfn>redirecting</dfn></dt>
            <dd>The call is being redirected to another remote party from the
              same <a>telephony service</a>.
            </dd>

            <dt><dfn>transferring</dfn></dt>
            <dd>The call is being transferred to another remote party from the
              same <a>telephony service</a>.
            </dd>

            <dt><dfn>disconnecting</dfn></dt>
            <dd>A request to disconnect the call has been made and it is
              progressing.
            </dd>

            <dt><dfn>disconnected</dfn></dt>
            <dd>The call has been disconnected and this object is invalid for
              call control.
            </dd>

            <dt><dfn>joining</dfn></dt>
            <dd>The call is being joined with another call to become a
              conference call.
            </dd>

            <dt><dfn>conference</dfn></dt>
            <dd>The call is a conference call.</dd>

            <dt><dfn>splitting</dfn></dt>
            <dd>The call is being split from a conference call.</dd>
          </dl>
          <p>
            Some of these states are <dfn>soft states</dfn>, that is,
            transitory states in which the application is placed after making a
            request to the telephony system and until it is completed. For
            instance the application remains in <a><code>holding</code></a>
            state since it invokes the <a><code>hold()</code></a> method and
            until the telephony system actually holds the call. In some
            implementations these soft states can be skipped. The following are
            the soft states defined by this specification:
            <a><code>accepted</code></a>, <a><code>disconnecting</code></a>,
            <a><code>holding</code></a>, <a><code>resuming</code></a>.
          </p>
          <p>
            On the contrary, <dfn>hard states</dfn> MUST be supported by the
            implementation: <a><code>dialing</code></a>,
            <a><code>alerting</code></a>, <a><code>active</code></a>,
            <a><code>disconnected</code></a>, <a><code>incoming</code></a>,
            <a><code>waiting</code></a>, <a><code>held</code></a>.
            For calls participating in conference calls, the following
            additional call states MUST be supported:
            <a><code>joining</code></a>, <a><code>splitting</code></a>,
            <a><code>conference</code></a>. For call transfer functionality, the
            additional <a><code>transferring</code></a> state MUST be supported.
          </p>
        </section><!-- CallState Enum -->

        <!-- - - - - - - - - - -  State changes - - - - - - - - - - - - - - -->
        <section> <h3>State changes</h3>
          <p>
            Whenever there is a change in the <code>state</code> attribute of a
            <a><code>TelephonyCall</code></a> object, the <a>user agent</a>
            MUST run the following steps:
          </p>
          <ol id="steps-call-statechange-event">
            <li>
              <a>Queue a task</a> to <a>fire an event</a> named
              <a><code>statechange</code></a> with the new value of the state
              attribute, and the state change reason, if available.
            </li>
          </ol>
          <p>
            Since call state transitions depend on protocol, network equipment,
            modem, etc., the implementation MUST always re-synchronize any
            eventual internal states to the current call state reported by the
            telephony system. The implementation MUST NOT set the call state to
            any other value than specified in the descriptions of the methods
            of this interface.
          </p>
          <p class="note">
            Since <a title="call state">call states</a> can have slightly
            different semantics depending on the telephony protocol, the
            <code>serviceId</code> and the <code>protocol</code>
            properties can be used for interpreting the call state in the
            implementation. See
            <a href="https://github.com/sysapps/telephony/issues/125">issue
            125</a>.
          </p>
          <p class="issue">
            Note that compliant implementations may not be reporting events
            exactly when they occur, and the implementations may have to poll
            for these (e.g. OTA SIM update or hot-swappable SIM cards). See
            <a href="https://github.com/sysapps/telephony/issues/127">issue
            127</a>.
          </p>
        </section><!-- state changes -->
      </section><!-- call states -->

      <!-- - - - - - - - - - - - - - Receiving calls  - - - - - - - - - - - -->
      <section> <h3>States when receiving calls (inbound states)</h3>
        <p>
          The device can receive phone calls from any active telephony service,
          even simultaneously, in which case the user agent arbitrates the
          calls either by a policy, or by the user by choosing which call to
          accept.
        </p>
        <p>
          For call setup on received calls, the following call states MUST be
          supported in this order:
        </p>
        <ol>
          <li>"<a>incoming</a>" or "<a>waiting</a>"</li>
          <li>"<a>accepted</a>"</li>
          <li>"<a>active</a>".</li>
        </ol>
        <p class="note">
          On received calls, telephony protocols also use a <dfn>ringing</dfn>
          state, set by the mobile terminal when local call alerting starts, in
          order to notify the remote party about the ongoing alerting (ringing
          can actually be e.g. a beep, ring tone, or vibration pattern). This
          is considered to be responsibility of implementations: if the modem
          expects this state to be set, implementations MUST make sure to set
          it. Dialer applications are not expected to set this state in the
          current version of the specification.
        </p>
        <p class='note'>
          CDMA cannot report all these states in the expected sequence. The
          ‘connected’ network state (i.e. when the mobile station send the
          Service Connect Completion Message or Connect Order, depending on
          whether the call is mobile originated or terminated) is immediately
          followed by voice media transmission – there is no transition to
          ‘active’ before the media arrives. Therefore it should be up to the
          implementation to determine which events to fire and in which order.
          Dialer applications need to be prepared to handle such cases.
        </p>
        <figure>
          <img src="images/inbound_call_state_diagram.gif" alt="">
          <figcaption>
            The figure depicts the most usual state transitions for received
            calls.
          </figcaption>
        </figure>
      </section><!-- Inbound states -->

      <!-- - - - - - - - - -  Making calls (outbound states)  - - - - - - - -->
      <section> <h3>States when making calls (outbound states)</h3>
        <!--div class="issue">
          <p>
            The following needs to be redefined algorithmically in terms of the
            telephony service.
          </p>
          <p>
            To <dfn>make a call</dfn> with a
            <a><var>remote party id</var></a>, optionally a
            <var>telephony service</var>, and optionally a
            <var>hide caller id</var>, the user agent MUST ...
          </p>
        </div-->
        <p>
          For making a call, the <a>telephony service</a> transitions through
          the following states in order. Errors can occur at each state, which
          can result in the call becoming <a>disconnected</a>:
        </p>
        <ol>
          <li><a>dialing</a></li>
          <li><a>alerting</a></li>
          <li><a>active</a></li>
        </ol>
        <p class="note">
          On the telephony services which support the "<a>connecting</a>" call
          state (e.g. GSM and CDMA, for call routing, forwarding, voicemail
          handling etc), implementations SHOULD support this state too, between
          the "<a>dialing</a>" and "<a>alerting</a>" states. Dialer
          applications can associate the protocol with the <a>telephony
          service</a> used for the call.
        </p>
        <figure>
          <img src="images/outbound_call_state_diagram.gif" alt="">
          <figcaption>
            The figure depicts the most usual state transitions for dialed
            calls.
          </figcaption>
        </figure>
      </section><!-- Making calls (Outbound states) -->

      <!-- - - - - - - - - Conference calls states  - - - - - - - - - - - - -->
      <section> <h3>Conference call states</h3>
        <p>
          Valid state transitions for a conference call are:
          <ul>
            <li>from <code>'joining'</code> to <code>'active'</code></li>
            <li>from <code>'active'</code> to <code>'holding'</code> to
              <code>'held'</code></li>
            <li>from <code>'held'</code> to <code>'resuming'</code> to
              <code>'active'</code></li>
            <li>from any state to <code>'disconnected'</code>.</li>
          </ul>
          In addition, <code>Promise</code> objects are used for tracking the
          protocol transactions, resolving either to success or error.
        </p>
      </section>

      <!-- - - - - - - - - - - Disconnect reason  - - - - - - - - - - - - - -->
      <section> <h2>Disconnect reason</h2>
        <p>
          The reasons why a call can become <a>disconnected</a> are as follows.
          Within the API the following disconnection reasons are represented by
          the the <code><a>DisconnectReason</a></code> enum.
        </p>
        <!-- - - - - - - - - - -  DisconnectReason Enum - - - - - - - - - - -->
        <section> <h3><code><a>DisconnectReason</a></code> enum</h3>
          <dl title="enum DisconnectReason" class="idl">
            <dt>local</dt>
            <dt>remote</dt>
            <dt>network</dt>
            <dt>busy</dt>
            <dt>rejected</dt>
            <dt>redirected</dt>
            <dt>unreachable</dt>
            <dt>no-answer</dt>
            <dt>network-unreachable</dt>
            <dt>barred</dt>
            <dt>no-service</dt>
            <dt>invalid-number</dt>
          </dl>
          <p>
            The meaning of the disconnect reasons in this API is the following:
          </p>
          <dl>
            <dt><dfn id="disconnect-local">local</dfn></dt>
            <dd>The call was disconnected by the user, or the device, and no
              more specific reason is known.
            </dd>

            <dt><dfn id="disconnect-remote">remote</dfn></dt>
            <dd>The call was disconnected by the remote party, and no more
              specific reason is known.
            </dd>

            <dt><dfn id="disconnect-network">network</dfn></dt>
            <dd>The call was disconnected by the network, and no more specific
              reason is known.
            </dd>

            <dt><dfn id="disconnect-busy">busy</dfn></dt>
            <dd>The call was disconnected by the network, because the remote
              party was busy.
            </dd>

            <dt><dfn id="disconnect-rejected">rejected</dfn></dt>
            <dd>The call was disconnected because the remote party rejected the
              call.
            </dd>

            <dt><dfn id="disconnect-redirected">redirected</dfn></dt>
            <dd>The call has been redirected to another subscriber.</dd>

            <dt><dfn id="disconnect-unreachable">unreachable</dfn></dt>
            <dd>The call was disconnected by the network, because the remote
              party was unreachable by the network.
            </dd>

            <dt><dfn id="disconnect-no-answer">no-answer</dfn></dt>
            <dd>The call was disconnected by the network, because the remote
              party has not answered and the call has timed out.
            </dd>

            <dt>
              <dfn id="disconnect-network-unreachable">network-unreachable</dfn>
            </dt>
            <dd>The call was disconnected because the network was unreachable.
            </dd>

            <dt><dfn id="disconnect-barred">barred</dfn></dt>
            <dd>The call was disconnected because it was barred.</dd>

            <dt><dfn id="disconnect-no-service">no-service</dfn></dt>
            <dd>The call was not made because there is no telephony service set
              up and enabled (e.g. no SIM card).
            </dd>

            <dt><dfn id="disconnect-invalid-number">invalid-number</dfn></dt>
            <dd>The call was disconnected by the network, because the remote
              party identifier was invalid.
            </dd>
          </dl>
        </section><!-- DisconnectReason Enum -->
      </section><!-- disconnecting calls -->
    </section> <!-- definitions -->

    <!-- - - - - - - - - - - - - Interface CallManager  - - - - - - - - - - -->
    <section> <h2>The <a>CallManager</a> Interface</h2>
      <p>
        The <a>CallManager</a> interface provides access to telephony
        functionality related to given <a>telephony service</a>s, and manages
        the lifecycle of the <a><code>TelephonyCall</code></a> objects.
      </p>
      <dl title="interface CallManager: EventTarget" class="idl">
        <dt>readonly attribute TelephonyCall? activeCall</dt>
        <dt>Promise getCalls()</dt>
        <dt>TelephonyCall? getCall(DOMString callId)</dt>
        <dt>Promise createConference()</dt>
        <dt>Promise getParticipants(DOMString conferenceId)</dt>
        <dt>Promise split(TelephonyCall call)</dt>
        <dt>attribute EventHandler oncalladded   </dt>
        <dt>attribute EventHandler oncallremoved </dt>
        <dt>attribute EventHandler oncallactive  </dt>
      </dl>

      <!-- - - - - - - - - - -  Event handlers  - - - - - - - - - - - - - - -->
      <section> <h2>Event handlers</h2>
        <p>
          The following are the event handlers implemented by the
          <a>CallManager</a> interface.
        </p>
        <table class="simple">
          <tr>
            <th>event handler</th>
            <th>event name   </th>
            <th>event type   </th>
            <th>description  </th>
          </tr>
          <tr>
            <td>
              <dfn id="widl-CallManager-oncalladded"><code>oncalladded</code>
              </dfn>
            </td>
            <td><dfn><code>calladded</code></dfn></td>
            <td><a>TelephonyCallEvent</a></td>
            <td>handles incoming and waiting calls, and creation of conference
              calls
            </td>
          </tr>
          <tr>
            <td>
              <dfn
                id="widl-CallManager-oncallremoved"><code>oncallremoved</code>
              </dfn>
            </td>
            <td><dfn><code>callremoved</code></dfn></td>
            <td><a><code>TelephonyCallEvent</code></a></td>
            <td>handles call disconnection
            </td>
          </tr>
          <tr>
            <td>
         <dfn id="widl-CallManager-oncallactive"><code>oncallactive</code>
              </dfn>
            </td>
            <td><dfn><code>callactive</code></dfn></td>
            <td><a>TelephonyCallEvent</a></td>
            <td>handles the call becoming an <a>active call</a>
            </td>
          </tr>
          </table>
          <p>Subscribing to notifications of these events SHOULD be permitted
            for lower privileged applications, in order to ba able to determine
            whether is there any call in the system.
          </p>

          <!-- - - - - - - - - - calladded event  - - - - - - - - - - - - - -->
          <section> <h3>The <code>oncalladded</code> event</h3>
          <p>
            The <code>oncalladded</code> event MUST be raised either when there
            is an incoming or waiting call, or when a new conference call is
            created.
          </p>
          <p>
            Upon a new incoming or waiting call, the <a>user agent</a> MUST
            execute the following <dfn>onincoming steps</dfn>:
          </p>
          <ol id="steps-onincoming">
          <li>Let <var>incomingCall</var> be a new instance of
            <a><code>TelephonyCall</code></a>.
          </li>
          <li>Set the <code>state</code> of <var><code>incomingCall</code></var>
            to <a><code>incoming</code></a> in case the underlying telephony
            system reports that state (which happens when there is no other call
            in <a><code>active</code></a> state).
          </li>
          <li>Alternatively, set the <code>state</code> of
            <var><code>incomingCall</code></var> to <a><code>waiting</code></a>,
            in case the underlying telephony system reports that state (which
            happens if the call waiting service is active and there is already
            an <a>active call</a>).
          </li>
          <li>Otherwise, if there already is an <a>active call</a> and the call
            waiting service is not enabled, the telephony system will disconnect
            the call, the implementation MUST follow the
            <a href="steps-ondisconnected">disconnect steps</a> and terminate
            these steps.
          </li>
          <li>If the <code>state</code> of <var>incomingCall</var> has been set
            to either <a><code>incoming</code></a> or
            <a><code>waiting</code></a>, then add <var>incomingCall</var> to the
            list of calls managed by <a><code>CallManager</code></a>.
          </li>
          <li>
            <a>Queue a task</a> to <a>fire an event</a> named
            <code>statechange</code> at the <var>incomingCall</var> object.
          </li>
          <li>
            <a>Queue a task</a> to <a>fire an event</a> named
            <code>calladded</code> at all the <a>CallManager</a> objects, with
            its <var>call</var> property set to <var>incomingCall</var>.
          </li>
          </ol>
          </section>

          <!-- - - - - - - - - - - oncallremoved event  - - - - - - - - - - -->
          <section> <h3>The <code>callremoved</code> event</h3>
          <p>
            The <code>callremoved</code> event MUST be raised either when a
            <a><code>TelephonyCall</code></a> object managed by the
            <a>CallManager</a> object is disconnected.
          </p>
          <p>
            When a <a>telephony service</a> is notified of call disconnection of
            the <a><code>TelephonyCall</code></a> object <var>telCall</var>, the
            user agent MUST run the following <dfn>ondisconnected steps</dfn>:
          </p>
          <ol id="steps-ondisconnected"> <a>Queue a task</a> to:
            <li>Remove the <var>telCall</var> object from all internal lists
              of <a><code>CallManager</code></a>
            </li>
            <li>set the <code>state</code> of <var>telCall</var> to
              "<a>disconnected</a>".
            </li>
            <li>
              fire a <a><code>TelephonyStateEvent</code></a>
              named <code>statechange</code> at the <var>telCall</var>
              object, with the <code>state</code> property set to
              <code>'disconnected'</code> and the <code>reason</code>
              property set to the <a>DisconnectReason</a>, if available,
              or otherwise it MUST be set to <code>null</code>. At least the
              following values MUST be supported for the disconnect reason:
              "<a>local</a>", "<a>remote</a>" and "<a>network</a>".
              The rest of the <a>DisconnectReason</a> values SHOULD be
              supported.
            </li>
            <li>
              fire the <var>callremoved</var> event at all the
              <a><code>CallManager</code></a> object managing the call, with
              the value of the <code>callId</code> property set to the
              <code>callId</code> of <var>telCall</var>.
            </li>
          </ol>
        </section>

        <!-- - - - - - - - Active call change event steps - - - - - - - - - -->
        <section> <h3>Handling the <code>callactive</code> event</h3>
        <p>
          When a telephony call becames the <a>active call</a>, the user agent
          MUST run the following steps:
        </p>
        <ol id="steps-call-onactivechanged">
          <li>Let <var>call</var> denote the <a><code>TelephonyCall</code></a>
          object which has become active.</li>
          <li>Change the value of the <code>activeCall</code> property of all
            instances of <a><code>CallManager</code></a>, to <var>call</var>.
          </li>
          <li><a>Queue a task</a> to <a>fire an event</a> named
            <code>callactive</code> at all the  instances of
            <a><code>CallManager</code></a>, with the value of the
            <code>call</code> property set to <var>call</var>.
          </li>
        </ol>
        </section>
      </section><!-- event handers -->

      <!-- - - - - - - - - - - - Interface TelephonyCallEvent - - - - - - - -->
      <section> <h2><a>TelephonyCallEvent</a> Interface</h2>
        <p>
          Defines telephony events for <a><code>TelephonyCall</code></a> state changes, including handling incoming and waiting calls.
        </p>
        <dl title="interface TelephonyCallEvent : Event"
        class="idl">
          <dt>readonly attribute TelephonyCall? call</dt>
        </dl>
        <!-- - - - - - - - - - - - call attribute - - - - - - - - - - - - - -->
        <section> <h3>The <code>call</code> attribute</h3>
          <p>
            When getting the <code>call</code> attribute, the
            <a>user agent</a> MUST return the <a><code>TelephonyCall</code></a>
            object that triggered the event.
          </p>
        </section>
      </section><!-- interface TelephonyCallEvent -->

      <!-- - - - - - - - - - - - -  activeCall attribute  - - - - - - - - - -->
      <section> <h3>The <code>activeCall</code> attribute</h3>
        <p>
          When getting the <dfn id=
          "widl-CallManager-activeCall">activeCall</dfn> attribute, the
          user agent MUST return the <a><code>TelephonyCall</code></a> object
          that represents the <a>active call</a>. If there is no active call,
          return <code>null</code>.
        </p>
      </section>

      <!-- - - - - - - - - - - - - getCalls() method  - - - - - - - - - - - -->
      <section> <h3>The <code>getCalls()</code> method</h3>
        <p>
          When the <code>getCalls()</code> method is invoked, the
          <a>user agent</a> MUST return a <code>Promise</code> object, which in
          case of success resolves to an array, which can be empty, of all
          <a><code>TelephonyCall</code></a> objects in the system which have the
          value of the <code>state</code> property different from
          <code>'initializing'</code> and <code>'disconnected'</code>, i.e. all
          telephony calls in progress. <a><code>TelephonyCall</code></a> objects belonging to a conference call are also listed here.
          The applications SHOULD check the <code>conferenceId</code> property
          of each <code>TelephonyCall</code> object in order to determine
          whether the call is part of a conference call, and if yes, which is
          the controlling object for the conference call.
        </p>
      </section>

      <!-- - - - - - - - - - - - - getCall() method - - - - - - - - - - - - -->
      <section> <h3>The <code>getCall()</code> method</h3>
        <p>
          When the <code>getCall(DOMString callId)</code> method is invoked, the
          <a>user agent</a> MUST return the unique <code>TelephonyCall</code>
          object whose <code>callId</code> property is equal with the parameter
          <var>callId</var>, or <code>null</code> if there is no match.
        </p>
      </section>

      <!-- - - - - - - - - createConference() method  - - - - - - - - - - - -->
      <section><h3>The <code>createConference()</code> method</h3>
        <p>
          When the <dfn>createConference()</dfn> method is invoked, the user
          agent MUST run the following <dfn>create conference steps</dfn>:
        </p>
        <ol id="steps-createconference">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>If there is no <a>active call</a>, then resolve
            <var>promise</var> with a <code>"NoModificationAllowedError"</code>
              error, and terminate this algorithm.
          </li>
          <li>Let <var>service</var> be the value of the <code>serviceId</code>
            property of the <a>active call</a>.
          </li>
          <li>Let <var>confCall</var> be a new instance of <a>TelephonyCall</a>
            with a unique <code>callId</code> property having the same value as
            the <code>conferenceId</code> property, and the value of the
            <code>serviceId</code> property set to <var>service</var>.
          </li>
          <li>Set the <code>state</code> of <var>confCall</var> to
            "<a>joining</a>".
          </li>
          <li>In the <a>telephony service</a> specified by the
            <code>serviceId</code> property of <var>service</var> make a request
            to the telephony system to create a conference call, and wait for
            the response. In GSM this will mean joining the active and held
            calls into a conference call.
            In CDMA, it means joining the <code>waiting</code> or
            <code>held</code> call with the <a>active call</a> into a 3-way
            call.
          </li>
          <li>If the request fails, call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var>
            argument set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>Set the <code>conferenceId</code> attribute of the
            participating calls to the unique identifier generated for the
            conference call <var>confCall</var>.
          </li>
          <li><a>queue a task</a> to fire a <code>calladded</code> event with
            its <var>call</var> set to the value of the <code>callId</code>
            property of <var>confCall</var>, to each instance of
            <a><code>CallManager</code></a> objects.
          </li>
          <li>Set the <code>state</code> of <var>confCall</var> to
            <a><code>active</code></a>.
          </li>
          <li>Follow the state changes of <var>confCall</var> through the
            state change events.
          </li>
        </ol>
      </section><!--createConference() method-->

      <!-- - - - - - - - getParticipants() method - - - - - - - - - - - - - -->
      <section> <h3>The <code>getParticipants()</code> method</h3>
        <p>
          When the <dfn
          id="widl-CallManager-getParticipants-Promise-DOMString">
          getParticipants()</dfn> method is invoked, the user agent MUST run the
          following steps:
          <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Let <var>confId</var> be the parameter of type
            <code>DOMString</code> of this method.
          </li>
          <li>Collect the list of <a><code>TelephonyCall</code></a> objects
            participating in the <a>conference call</a>
            whose <code>conferenceId</code> is equal with the parameter <var>
            conferenceId</var> into an array that can be empty.
          </li>
          <li><a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept()</code> method with the array as parameter.
          </li>
          </ol>
        </p>
      </section>

      <!-- - - - - - - - - - - - split() method - - - - - - - - - - - - - - -->
      <section> <h3>The <code>split()</code> method</h3>
        <p>
          The <dfn id=
          "widl-CallManager-split-Promise-TelephonyCall-call">split()</dfn>
          method requests the telephony system to split the specified participant
          <a><code>TelephonyCall</code></a> object from the
          <a>conference call</a> it is participating, activate it and put the conference call on hold. The method takes one argument, which
          represents the <a><code>TelephonyCall</code></a> object of the call participant to be split from the conference call. When invoked, the
          user agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If the provided <var>call</var> does not identify a
            valid <a><code>TelephonyCall</code></a> object with a valid
            <code>conferenceId</code> property denoting a <a>conference call</a>
            in progress, then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is set to
            <code>"InvalidModificationError"</code>, and terminate this
            algorithm.
          </li>
          <li>let <var>confCall</var> be the <a><code>TelephonyCall</code></a>
            object controlling the <a>conference call</a>, whose
            <code>callId</code> and <code>conferenceId</code> property is equal
            to the <code>conferenceId</code> property of <var>call</var>.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Set the <code>state</code> of the <var>call</var> and
            set the state of <var>confCall</var> to
            <a></code>splitting</code></a>.
          </li>
          <li>Make a request to the telephony system to split the call
            participant from the conference call and wait the response from the telephony system
          </li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the <code>state</code> of the <var>call</var>
            and the state of the conference call to
            <a><code>conference</code></a>. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request was successful, reset the <code>conferenceId</code>
            of the split call to <code>null</code>.
            The telephony system will put the conference call on hold and
            activate the split call. The implementation MUST follow the state
            transitions on the calls as described in this specification.
          </li>
          <li> <a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept()</code> method.
          </li>
        </ol>
        <p class='note'>
          In CDMA, only the last dialed call can be split off the 3-way call.
          For other call participants, calling this method MUST fail.
        </p>
      </section><!-- split() method -->
    </section><!-- CallManager -->

    <!-- - - - - - - - - - - -  Interface TelephonyCall - - - - - - - - - - -->
    <section> <h2><a><code>TelephonyCall</code></a> Interface</h2>
      <p>
        Defines the object structure for controlling calls.
      </p>
      <dl title="[Constructor(DOMString remote, optional DOMString serviceId)]
      interface TelephonyCall : EventHandler"
      "interface TelephonyCall: EventHandler" class="idl">
        <dt>readonly attribute DOMString? callId      </dt>
        <dt>readonly attribute DOMString? conferenceId</dt>
        <dt>readonly attribute DOMString? remoteParty </dt>
        <dt>readonly attribute DOMString serviceId    </dt>
        <dt>readonly attribute CallState state        </dt>
        <dt>Promise accept()                          </dt>
        <dt>Promise dial()                            </dt>
        <dt>Promise hold()                            </dt>
        <dt>Promise resume()                          </dt>
        <dt>Promise deflect(DOMString remoteParty)    </dt>
        <dt>Promise transfer(TelephonyCall call)      </dt>
        <dt>Promise disconnect()                      </dt>
        <dt>attribute EventHandler onstatechange      </dt>
      </dl>

      <!-- - - - - - - - - - - -  event handlers  - - - - - - - - - - - - - -->
      <section id="call-eventhandlers"> <h3>Event handlers</h3>
        <p>
          The following are the event handlers are exposed by the
          TelephonyCall interface. The event type is
          <a><code>TelephonyStateEvent</code></a>.
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>event handler</th>
              <th>event name</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
               <dfn id=
               "widl-CallHandler-onstatechange"><code>onstatechange</code></dfn>
              </td>
              <td><dfn><code>statechange</code></dfn></td>
            </tr>
          </tbody>
        </table>
        <!-- - - - - - - - - - Interface TelephonyStateEvent  - - - - - - - -->
        <section> <h2>The <a>TelephonyStateEvent</a> Interface</h2>
          <p>
            Defines a telephony event for notifying a changed state for a
            <a><code>TelephonyCall</code></a> object.
          </p>
          <dl title="interface TelephonyStateEvent : Event"
              class="idl">
            <dt>readonly attribute DOMString state</dt>
            <dt>readonly attribute DOMString? reason</dt>
          </dl>
          <!-- - - - - - - - - - state attribute  - - - - - - - - - - - - - -->
          <section> <h3>The <code>state</code> attribute</h3>
            <p>
              When getting the <code>state</code>, the <a>user agent</a>
              MUST return the new <a>call state</a> causing the state change.
            </p>
          </section>
          <!-- - - - - - - - - - reason attribute - - - - - - - - - - - - - -->
          <section>
            <h3>The <code>reason</code> attribute</h3>
            <p>
              When getting the <code>reason</code>, the user
              agent MUST return a reason for the new telephony call state
              of the <a>telephony call</a> if the reason is available, or
              <code>null</code> otherwise. In this version, only
              the <code>'disconnected'</code> state reasons are specified, as
              described in <a><code>DisconnectReason</code></a>.
            </p>
          </section>
        </section><!-- interface TelephonyStateEvent -->
      </section><!-- Event Handlers -->

      <!-- - - - - - - - - - - - callId attribute - - - - - - - - - - - - - -->
      <section> <h3>The <code>callId</code> attribute</h3>
        <p>
          When getting the <dfn id="widl-TelephonyCall-callId">callId</dfn>
          attribute, the user agent MUST return the unique <a>call id</a>.
          After construction, the value MUST be <code>null</code>.
          The implementation MUST assign a non-null value when the
          <code>state</code> property is assigned a value different from
          <code>'initializing'</code>.
        </p>
      </section><!-- callId attribute -->

      <!-- - - - - - - - - - - -  serviceId attribute - - - - - - - - - - - -->
      <section> <h3>The <code>serviceId</code> attribute</h3>
        <p>
          When getting the
          <dfn id="widl-TelephonyCall-serviceId">serviceId</dfn>
          attribute, the user agent MUST return the <a>telephony service id</a>
          of the <a>telephony service</a> associated with this call.
        </p>
      </section><!-- serviceId attribute -->

      <!-- - - - - - - - - - - -  state attribute - - - - - - - - - - - - - -->
      <section> <h3>The <code>state</code> attribute</h3>
        <p>
          When getting the <dfn id="widl-TelephonyCall-state">state</dfn>
          attribute, the user agent MUST return the <a>CallState</a> value that
          represents the state of for the <a>telephony call</a>.
        </p>
      </section><!-- state attribute -->

      <!-- - - - - - - - - - - - remoteParty attribute  - - - - - - - - - - -->
      <section> <h3>The <code>remoteParty</code> attribute</h3>
        <p>
          When getting the
          <dfn id="widl-TelephonyCall-remoteParty">remoteParty</dfn> attribute,
          the user agent MUST return the <a>remote party id</a> (e.g. telephone
          number) of the call participant. If not available (e.g. callerId has
          been hidden), return <code>null</code>.
        </p>
      </section>

      <!-- - - - - - - - - - - - conferenceId attribute - - - - - - - - - - -->
      <section> <h3>The <code>conferenceId</code> attribute</h3>
        <p>
          When getting the
          <dfn id="widl-TelephonyCall-conferenceId">conferenceId</dfn>
          attribute, the user agent MUST return the value of the
          <code>conferenceId</code> attribute of the <a>conference call</a>
          to which this call is part of, or <code>null</code> if it is not
          part of any <a>conference call</a>.
        </p>
      </section>

      <!-- - - - - - - - - - - - accept() method  - - - - - - - - - - - - - -->
      <section> <h3>The <code>accept()</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-accept-void">accept()</dfn> method
          accepts an incoming or waiting <a>telephony call</a>. When invoked,
          the user agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If <code>state</code> is not equal to <a><code>incoming</code></a>
            or <a><code>waiting</code></a>, then
            call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of the call</li>
          <li>Make a request to the telephony system to accept the call.</li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the call state to the value saved before the request. Then,
            call <var>resolver</var>'s <code>reject(value)</code> method with
            the <var>value</var> argument set to a new <code>DOMError</code>
            object whose name is set to
            <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then set <code>state</code> to
            <a><code>accepted</code></a>, and  <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- accept() method -->

      <!-- - - - - - - - - - - dial() method  - - - - - - - - - - - - - - - -->
      <section><h3>The <code>dial()</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-dial-void">dial()</dfn>
          method initiates a new <a>telephony call</a>. When
          invoked, the user agent MUST run the following <dfn>dial steps</dfn>:
        </p>
        <p class="note">
          Note that verification of the format of the <var>remoteParty</var>
          argument is left to the <a>telephony service</a>. Providing an
          <var>remoteParty</var> in the invalid format will generally result in
          the call disconnecting because the <a>telephony service</a> or
          telephony network will deem it an invalid number. However, the user
          agent SHOULD do a basic validation of the user input, e.g. using
          the <code>classify()</code> method.
        </p>
        <ol id="steps-dial">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>If the value of the <code>serviceId</code> property does not match
            a valid telephony service id accessible to the <a href=
            "http://dom.spec.whatwg.org/#concept-document">document</a>'s
            <a href=
            "http://www.whatwg.org/specs/web-apps/current-work/multipage/origin-0.html#effective-script-origin">
            effective script origin</a>, then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is set to
            <code>"NotFoundError"</code>, and terminate this algorithm.
          </li>
          <li>Optionally validate the value of the <code>remoteParty</code>
            property and if it is not valid, resolve <var>promise</var> with an
            <code>"InvalidCharacterError"</code> error, and terminate this
            algorithm.
          </li>
          <li>Make a request to the underlying telephony system to
            dial the call and wait for response from the underlying system.
          </li>
          <li>If it's not possible to fulfill the request for whatever reason:
            timeout, security, etc., then
            call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"NoModificationAllowedError"</code>, and terminate this
            algorithm.
          </li>
          <li>Otherwise, <a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept(value)</code> method.
          </li>
        </ol>
      </section><!--dial() method-->

      <!-- - - - - - - - - - - -  hold() method - - - - - - - - - - - - - -->
      <section> <h3>The <code>hold()</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-hold-void">hold()</dfn> method
          requests the telephony system put the call on hold. When
          invoked, the user agent MUST run the following <dfn>hold steps</dfn>:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If <code>state</code> is not equal to <a><code>active</code></a>,
            then call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Set the <code>state</code> of the call to <code>holding</code>
          </li>
          <li>Make a request to the telephony system to put the call on hold.
          </li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the <code>state</code> of the
            call to <a><code>active</code></a>. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then set <code>state</code> to
            <a><code>held</code></a>, and  <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section> <!-- hold() method -->

      <!-- - - - - - - - - - - -  resume() method - - - - - - - - - - - - -->
      <section> <h3>The <code>resume()</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-resume-void">resume()</dfn> method
          requests the telephony system to resume resume a held call.
          When invoked, the user agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If <code>state</code> is not equal to <a><code>held</code></a>,
            then call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of the call</li>
          <li>Set the <code>state</code> of the call to
            <a><code>resuming</code></a>
          </li>
          <li>Make a request to the telephony system to resume the call.</li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the <code>state</code> of the
            call to <a><code>held</code></a>. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then set <code>state</code> to
            <a><code>active</code></a>, and  <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- resume() method -->

      <!-- - - - - - - - - - - -  disconnect() method - - - - - - - - - - - -->
      <section> <h3>The <code>disconnect</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-disconnect-void">disconnect</dfn>
          method, if invoked on a <a><code>TelephonyCall</code></a> which is not
          controlling a <a>conference call</a> (i.e. its <code>callId</code> is
          different from its <code>conferenceId</code>), it initiates releasing
          of the telephony call. If the call is controlling a conference call,
          then initiates releasing the conference call, including each
          participating <a><code>TelephonyCall</code></a> object.
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of the call</li>
          <li>Set the <code>state</code> of the call to
            <code>disconnecting</code>
          </li>
          <li>Make a request to the telephony system to disconnect the call</li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the <code>state</code> of the
            call to the saved value. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then execute the
            <a>ondisconnected steps</a>, and and  <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
        <p class="note">
          Depending on the protocol, there may be restrictions on methods. For
          instance, GSM does not permit disconnecting a held call. Also,
          disconnecting a participant in a held GSM multiparty call is not
          supported. Also, if the controlling party disconnects a call
          participating in a IS-41 3-way call in CDMA which is not the last
          dialed call, then all parties are disconnected (other participants
          should choose to hang up).
        </p>
      </section><!-- disconnect() method -->

      <!-- - - - - - - - - - - - deflect() method - - - - - - - - - - - - - -->
      <section> <h3>The <code>deflect()</code> method</h3>
        <p class="note">
          The telephony service in use needs to have the call deflection
          feature enabled in order for this method to succeed. For instance, in
          GSM, the Call Deflection supplementary service needs to be active.
        </p>
        <p>
          The <dfn id=
          "widl-TelephonyCall-deflect-void-DOMString-remoteParty">redirect()</dfn>
          method initiates deflecting an incoming or waiting telephone call to
          a remote party. The method takes one argument, which represents the
          remote party to which the call is redirected. When invoked, the user
          agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If the <code>state</code> is not <a><code>incoming</code></a> or
            <a><code>waiting</code></a>,
            then call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of the call</li>
          <li>Make a request to the telephony system to redirect the
           call to the number indicated in the <var>remoteParty</var> parameter
          </li>
          <li>Set the <code>state</code> of the call to
            <a><code>redirecting</code></a>
          </li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the state before the request.
            Then call <var>resolver</var>'s <code>reject(value)</code> method
            with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"NoModificationAllowedError"</code>, and terminate this
            algorithm.
          </li>
          <li>If the request is successful, then set <code>state</code> to
            <a><code>disconnected</code></a>, and  <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- deflect() method -->

      <!-- - - - - - - - - - - - transfer() method  - - - - - - - - - - - - -->
      <section> <h3>The <code>transfer()</code> method</h3>
        <p class="note">
          The <a>telephony service</a> needs to have the call transfer feature
          enabled in order for this method to succeed. For instance, in GSM,
          the Call Transfer supplementary service needs to be active.
        </p>
        <p>
          The <dfn id=
          "widl-TelephonyCall-transfer-void-TelephonyCall-call">transfer()</dfn>
          method Initiates transferring the call to a new call between the
          remote party of this call and another remote party, then disconnects
          the call. The method needs the Explicit Call Transfer supplementary
          service to be active.The method takes one argument, which represents
          the held call whose remote party is connected with the remote party
          of this call (which MUST be the <a>active call</a>).
           When invoked, the user agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If <code>state</code> is not equal to <a><code>active</code></a>
            or if the <code>state</code> of the parameter <var>call</var> is not
            equal to <a><code>held</code></a>, then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of this call</li>
          <li>Set the <code>state</code> of this call to
            <a><code>transferring</code></a>
          </li>
          <li>Make a request to the telephony system to transfer the
            call to the remote party indicated in the <var>call</var> parameter,
            and wait for response from the telephony system
          </li>
          <li>If the request fails, then check if call state has changed, and if
            yes, then execute the steps relevant to that call state, otherwise
            restore the <code>state</code> of the call to the value saved before
            the request. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code> and terminate
            this algorithm.
          </li>
          <li>If the transfer request is successful, then execute the
            <a>ondisconnected steps</a>, and <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- transfer() method -->
    </section><!-- TelephonyCall -->
    </section><!-- Telephony Calls -->

    <!-- - - - - - - - - - - -  Tone management - - - - - - - - - - - - - - -->
    <section> <h2>Tone Management</h3>
      <section> <h2>The <a>ToneManager</a> Interface</h2>
        <p>
          The <a>ToneManager</a> interface provides [[!DTMF]] related
          functionality, such as sending a series of tones, and starting and
          stopping a single tone.
        </p>
        <p>
          Tone value can be any of the following characters: 0-9; A-D; *; #.
        </p>
        <p class="issue">
          The above needs to be converted to ABNF
        </p>
        <dl title="interface ToneManager" class="idl">
          <dt>
            Promise sendTones(DOMString tones, optional ToneOptions options)
          </dt>
          <dt>
            Promise startTone(DOMString tone, optional ToneOptions options)
          </dt>
          <dt>
            Promise stopTone(optional DOMString serviceId)
          </dt>
        </dl>
        </section>

        <!-- - - - - - - - - - - -  sendTones() - - - - - - - - - - - - - - -->
        <section> <h3>The <code>sendTones()</code> method</h3>
          <p>
            The <dfn id=
            "widl-ToneManager-sendTones-Promise">sendTones()</dfn> method
            requests a telephony service emit one or more [[!DTMF]] tones. When
            invoked, the user agent MUST run the following steps:
          </p>
          <ol id="steps-sendtones">
            <li>If the <a>ToneOptions</a> parameter specifies the
            <code>serviceId</code> to be used, then validate and use that value,
            otherwise use the <a>default telephony service</a> for sending the
            tones.
            </li>
            <li>If the <a>ToneOptions</a> parameter specifies the tone
            <code>duration</code>, then validate and use that value, otherwise
            use a default value.
            </li>
            <li>If the <a>ToneOptions</a> parameter specifies the tone
            <code>gap</code>, then validate and use that value, otherwise use a
            default value.
            </li>
            <li>Request from the telephony system to send the specified tones.
            </li>
            <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated
              <a><code>resolver</code></a>.
            </li>
            <li>Return <var>promise</var> to the caller and continue the
              following steps asynchronously.
            </li>
            <li>If the request to the telephony system is successful, or if the
              telephony system does not support feedback about the result of the
              request, invoke <var>resolver</var>'s <code>accept()</code> method
              with no arguments.
            </li>
            <li>If the request to the telephony system is unsuccessful, invoke
              <var>resolver</var>'s <code>reject()</code> method, with no
              arguments.
            </li>
          </ol>
          </section>

          <!-- - - - - - - - - - - -  startTone() - - - - - - - - - - - - - -->
          <section> <h3>The <code>startTone()</code> method</h3>
            <p>
              The <dfn id=
              "widl-ToneManager-startTone-Promise">startTone()</dfn> method
              starts emitting a [[!DTMF]] tone with the platform default or
              specified delay, in the platform default or the specified
              telephony service. A <a><code>Promise</code></a> object will be
              returned in order to notify the result of the request.
            </p>
            <p>
              When the <code>startTone</code> method is invoked, the user agent
              MUST run the following steps:
            </p>
            <ol id="steps-starttone">
              <li>If the platform does not support long press [[!DTMF]] tones,
              throw a <code>NotSupported</code> error and finish these steps. In
              this case applications may then use the <code>sendTones</code>
              method for sending [[!DTMF]].
              </li>
              <li>If the <a>ToneOptions</a> parameter specifies the
              <code>serviceId</code> to be used, then validate and use that
              value, otherwise use the <a>default telephony service</a> for
              sending the tones.
              </li>
              <li>If the <a>ToneOptions</a> parameter specifies the tone
              <code>duration</code>, then ignore that value.
              </li>
              <li>If the <a>ToneOptions</a> parameter specifies the tone
              <code>gap</code>, meaning the delay before sending the tone, then
              validate and use that value, otherwise use a default value.
              </li>
              <li>Request from the telephony system to start sending the
              specified tone. The tone SHOULD play until the
              <code>stopTone</code> method is called.
              </li>
              <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated
              <a><code>resolver</code></a>.
              </li>
              <li>Return <var>promise</var> to the caller and continue the
              following steps asynchronously.
              </li>
              <li>If the request to the telephony system is successful, or if
              the telephony system does not support feedback about the result of
              the request, invoke <var>resolver</var>'s <code>accept()</code>
              method with no arguments.
              </li>
              <li>If the request to the telephony system is unsuccessful, invoke
              <var>resolver</var>'s <code>reject()</code> method, with no
              arguments.
              </li>
            </ol>
          </section>

          <!-- - - - - - - - - - - -  stopTone()  - - - - - - - - - - - - - -->
          <section> <h3>The <code>stopTone()</code> method</h3>
            <p>
              The <dfn
              id="widl-ToneManager-stopTone-Promise-DOMString-serviceId">
              stopTone()</dfn>
              method stops emitting a [[!DTMF]] tone in the default or the
              specified telephony service. When invoked, the user agent MUST run
              the following steps:
            </p>
            <ol id="steps-stoptone">
              <li>If the platform does not support long press [[!DTMF]] tones,
              throw a <code>NotSupported</code> error.
              </li>
              <li>If the provided parameters are invalid, or there is no tone
              playing on the specified telephony service, throw an
              <code>InvalidStateError</code> error.
              </li>
              <li>Otherwise, request from the telephony system to stop sending
              the specified tone.
              </li>
              <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated
              <a><code>resolver</code></a>.
              </li>
              <li>Return <var>promise</var> to the caller and continue the
              following steps asynchronously.
              </li>
              <li>If the request to the telephony system is successful, or if
              the telephony system does not support feedback about the result of
              the request, invoke <var>resolver</var>'s <code>accept()</code>
              method with no arguments.
              </li>
              <li>If the request to the telephony system is unsuccessful, invoke
              <var>resolver</var>'s <code>reject()</code> method, with no
              arguments.
              </li>
            </ol>
          </section>

          <!-- - - - - - - - - - - -  ToneOptions - - - - - - - - - - - - - -->
          <section> <h3><a>ToneOptions</a> Dictionary</h3>
            <dl title="dictionary ToneOptions" class="idl">
              <dt> unsigned long duration </dt>
              <dt> unsigned long gap      </dt>
              <dt> DOMString serviceId    </dt>
            </dl>
            <section> <h3>The <code>duration</code> member</h3>
              <p>
                The <code>duration</code> member represents the duration (mark)
                in milliseconds of the [[!DTMF]] tones to be sent.
              </p>
            </section>
            <section> <h3>The <code>gap</code> member</h3>
              <p>
                The <code>gap</code> member represents
                the duration in milliseconds of the time gap (space) before a
                [[!DTMF]] tone.
              </p>
            </section>
            <section> <h3>The <code>serviceId</code> member</h3>
              <p>
                The <code>serviceId</code> member
                represents the <a>telephony service id</a> of the <a>telephony
                service</a> to be used when dialing.
              </p>
            </section>
          </section>
    </section> <!-- Tone management -->

    <!-- - - - - - - - - - - -  Emergency numbers - - - - - - - - - - - - - -->
    <section> <h2>The <a>EmergencyManager</a> Interface</h2>
      <p>
        This interface provides access for reading emergency numbers from the
        available <a>telephony service</a>s.
      </p>
      <dl title="interface EmergencyManager" class="idl">
        <dt> // on success returns emergency numbers as sequence of DOMString
        <dt>Promise getNumbers()</dt>
        <dt>attribute EventHandler onchanged</dt>
        <dt>Promise dial(DOMString number)</dt>
      </dl>
      <!-- - - - - - - - - - - EmergencyManager Event handlers  - - - - - - -->
      <section> <h2>Event handlers</h2>
      <p>
        The following are the <a>event handler</a>s implemented by the
        <a>ServiceManager</a> interface.
      </p>
      <table class="simple">
        <tr>
          <th>event handler    </th>
          <th>event name       </th>
        </tr>
        <tr>
          <td>
            <dfn id="widl-EmergencyManager-onchanged">
                 <code>onchanged</code>
            </dfn>
          </td>
          <td>
            <dfn><code>changed</code></dfn>
          </td>
        </tr>
      </table>
      <p>
        When emergency numbers have changed, the <code>changed</code> event of
        type <a><code>Event</code></a> MUST be fired at the object implementing
        this interface. The applications SHOULD read the emergency numbers
        by the <code>getNumbers()</code> method.
      </p>
    </section>
    <section> <h3>The <code>getNumbers()</code> method</h3>
      <p>
        When the <dfn id=
        "widl-EmergencyManager-getNumbers-Promise">getEmergencyNumbers()</dfn>
        method is invoked, the user agent MUST run the following steps:
      </p>
      <ol id="steps-getemergencynumbers">
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
          object and <var>resolver</var> its associated resolver.
        </li>
        <li>Return <var>promise</var> and continue the following steps
          asynchronously.
        </li>
        <li> make a request to the underlying telephony system to provide the
          list of emergency numbers from the <a>default telephony service</a>,
          and wait for response.
        </li>
        <li>If it's not possible to retrieve the list of telephony service
        identifiers for whatever reason: timeout, security, etc., then run the
        following sub-steps and terminate this algorithm:
          <ol>
            <li>Let <var>error</var> be a new DOMError object whose name is
            <code>"NoModificationAllowedError"</code>.
            </li>
            <li>Call <var>resolver</var>'s <code>reject(value)</code> method
            with <var>error</var> as the <var>value</var> argument.
            </li>
          </ol>
        </li>
        <li>Otherwise, combine the emergency numbers into a sequence of
          distinct <code>DOMString</code> strings, and <a>queue a task</a> to
          invoke <var>resolver</var>'s <code>accept(value)</code> method with
          the sequence of emergency numbers in the current geographical area,
          as the <var>value</var> argument. The list can be empty.
        </li>
      </ol>
      </p>
    </section>
    </section> <!-- Emergency numbers -->

    <!-- - - - - - - - - - - - Command parser - - - - - - - - - - - - - - - -->
    <section> <h2>Managing telephony commands</h2>
      <p>
        This interface provides a method for parsing and classifying user input.
        Applications can use this for dispatching these user inputs to relevant
        handlers. This is a helper interface for dialer applications, in order
        to avoid parsing user input to resolve commands in various telephony
        service specific contexts.
        For example, dialers could accept an emergency number typed in a PIN
        code dialog and display a button for making the emergency call.
        Another example is in a running dialer application, user input can be a
        phone number, an emergency number, or an MMI command, which enables
        the application know which API methods to use in continuation, i.e.
        which interfaces can accept the given user input. For instance, in the
        case of an MMI command the implementation of this interface can tell
        whether the command is valid and could be forwarded to the telephony
        service.
      </p>
      <section> <h3>The <a>CommandParser</a> Interface</h3>
      <dl title="interface CommandParser" class="idl">
        <dt>// on success returns TelephonyCommandType</dt>
        <dt>
          Promise classify(DOMString input, optional DOMString serviceId)
        </dt>
      </dl>
      <section> <h3>The <code>classify()</code> method</h3>
      <p>
        When the <code>classify()</code> method is invoked, the user agent
        MUST run the following steps:
      </p>
      <ol id="steps-parsecommand">
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
          object and <var>resolver</var> its associated resolver.
        </li>
        <li>Return <var>promise</var> and continue the following steps
          asynchronously.
        </li>
        <li>If the parameter <var>serviceId</var> has been specified, then
          restrict the following steps to the corresponding
          <a>telephony service</a>.
        </li>
        <li>Make a request to the underlying system to parse the user input
          given in <var>input</var>.
        </li>
        <li>Wait for response from the underlying system.
        </li>
        <li>If it's not possible to retrieve the list of telephony service
        identifiers for whatever reason: timeout, security, etc., then run the
        following sub-steps and terminate this algorithm:
          <ol>
            <li>Let <var>error</var> be a new DOMError object whose name is
            <code>"NoModificationAllowedError"</code>.
            </li>
            <li>Call <var>resolver</var>'s <code>reject(value)</code> method
            with <var>error</var> as the <var>value</var> argument.
            </li>
          </ol>
        </li>
        <li>Otherwise, <a>queue a task</a> to invoke <var>resolver</var>'s
          <code>accept(value)</code> method with the result as string, i.e. a
          <a><code>TelephonyCommandType</code></a> enumeration value as
          <var>value</var> argument.
        </li>
      </ol>
      </section>
      <section> <h3>The <a><code>TelephonyCommandType</code></a> enum</h3>
      <p>
        The return value of the <code>classify()</code> method
        through the <code>Promise</code> is a string enumeration value of
        the input classification.
      </p>
      <dl title="enum TelephonyCommandType" class="idl">
        <dt>emergency</dt>
        <dt>smmi</dt>
        <dt>mmi</dt>
        <dt>invalid</dt>
        <dt>number</dt>
        <dt>unknown</dt>
      </dl>
      <p> The supported command type values are the following:</p>
      <dl>
        <dt>"emergency"</dt>
        <dd>The user input matches to a known emergency number.</dd>

        <dt>"smmi"</dt>
        <dd>The user input matched to a standalone MMI command.</dd>

        <dt>"mmi"</dt>
        <dd>The user input matched to a sendable MMI command.</dd>

        <dt>"invalid"</dt>
        <dd>
          The user input is invalid (e.g. too long or contains invalid
          characters).
        </dd>

        <dt>"number"</dt>
        <dd>The user input matched to a remote party id of known
          format.</dd>

        <dt>"unknown"</dt>
        <dd>The user input matched does not match to a known command, nor to a
          known number format. The input may be usable, depending on the
          telephony service.</dd>
      </dl>
      </section>
      </section>
    </section> <!-- Command parser -->

    <!-- - - - - - - - - - - - Security and privacy - - - - - - - - - - - - -->
    <section> <h2>Security and privacy considerations</h2>
      <div class="issue">
        <p>
          To be improved. See <a href=
          "https://github.com/sysapps/telephony/issues/26">bug 26</a>.
        </p>
      </div>
      <p>
        This API provides access to a potentially dangerous and valuable
        feature of a device. As a result, misuse of the API would have a large
        cost to users and other system stakeholders. This API should,
        therefore, not be implemented without careful consideration of security
        and privacy issues.
      </p>
      <p>
        This section provides a limited overview of security and privacy
        considerations relevant for this API. It includes a set of threats to
        users and other stakeholders, as well as requirements for mitigating
        them.
      </p>
      <p>
        However, this section cannot cover all of the potential threats, nor
        can it reflect the context in which a conformant implementation may be
        operating. As a result, this security section should be considered only
        the starting point for implementers.
      </p>
      <!-- - - - - - - - - - - - Threats  - - - - - - - - - - - - - - - - - -->
      <section> <h3>Threats</h3>
        <p>
          The following list of threats should be considered by the
          implementer. Note that these are not given in any order.
        </p>
        <ul>
          <li>The API could be used by a malicious application to deny other
          system applications access to the device's telephony services,
          creating an availability problem. This is a safety, as well as
          security, concern.
          </li>
          <li>The API could be used by a malicious application as part of a
          distributed denial of service attack, making frequent calls to a
          remote call system such as an emergency response number.
          </li>
          <li>The API could be used by an application to list the telephone
          numbers that the end user has called and is, at any time, calling.
          This information ought to be considered private, and could also be
          used as part of a social engineering attack, or for identity theft.
          </li>
          <li>The API could be used to make unwanted calls to premium-rate
          telephone numbers. A malicious application could use this to earn
          money at the user's expense. Similarly, this API could be misused to
          enroll the user into a premium-rate calling service, which would then
          charge the end user when calls are received.
          </li>
          <li>The API could be used to make unwanted advertising calls, in a
          similar manner to spam email campaigns. When combined with access to
          the user's contact list, this would be both expensive and embarassing
          for the user, and could result in their telephony service being
          terminated by the network operator.
          </li>
          <li>The API could be used by a malicious application to make
          telephone calls impersonating the end user, or as part of a process
          to defeat a two-factor authentication system.
          </li>
          <li>A poorly implemented application could misuse this API to make
          unnecessary or unexpected calls, costing the user money or
          embarassing them.
          </li>
          <li>This API could be used to call a number other than the one that
          the user was expecting, routing calls to an unknown
          man-in-the-middle. This could be used to eavesdrop on the user. When
          used in combination with recordings from the microphone, this API
          could be used to covertly survey the end user.
          </li>
          <li>This API could be used to send USSD messages to the service
          provider and invoke functions such as wiping the handset or accessing
          security settings.
          </li>
          <li>The API could be misused to access the user's voicemail
          recordings.
          </li>
          <li>The API could be misused as part of a DDoS attack on an operator
          or service provider, flooding the network with calls at certain
          times.
          </li>
          <li>The API could cost the end user money by making outgoing calls
          when the user is roaming, or on an expensive network.
          </li>
        </ul>
      </section><!-- threats -->
      <!-- - - - - - - - - - - - Mitigations  - - - - - - - - - - - - - - - -->
      <section> <h3>Mitigations</h3>
        <p>
          The following mechanisms may be employed to help an implementer
          mitigate the threats outlined in the previous section.
        </p>
        <ul>
          <li>The user agent should only expose this API to <em>privileged</em>
          applications, as defined in the <a href=
          "http://www.w3.org/TR/runtime/">Runtime and Security Model</a>.
          </li>
          <li>The user agent should only expose this API to applications which
          were distributed by an institution that the handset recognises as a
          valid source. For example, the API might only be accessible to
          applications distributed by the handset manufacturer.
          </li>
          <li>All applications with access to this API should be reviewed
          before they are made available. A mechanism for remote update of
          applications with access to this API should be provided to allow for
          identified security issues to be fixed.
          </li>
          <li>The user agent should maintain the integrity of any application
          with access to this API when initially downloaded, as well as when it
          is stored offline.
          </li>
          <li>The user agent should only expose this API to downloaded, offline
          applications which are not modifiable by external web servers. A
          restrictive content security policy should be used to enforce that
          application with external content (such as scripts) cannot access
          this API.
          </li>
          <li>The API implementation should have different behaviour when used
          with premium-rate numbers. Accessing premium-rate numbers may require
          an additional permission to be listed in the manifest, a different
          (or additional) warning to be displayed to users, or place an
          additional requirement on the valid distributors of the application.
          It is up to the implementing user agent to identify whether a remote
          party identifier is premium-rate or not.
          </li>
          <li>The API implementation should have different behaviour when the
          user is roaming on a network with a different (less favourable)
          service-level agreement. For example, presenting a different warning
          to the user, or denying access to this API from certain applications
          altogether.
          </li>
          <li>User consent must be captured when a call is made. For example,
          the user must press a 'dial' button, or equivalent, before the call
          is placed. The user must also be shown the recipients of the call,
          and the numbers that have and will be dialled as part of placing it.
          </li>
          <li>It should be obvious, visually, when a call is being invoked, is
          in progress, and has ended. This should be visible to the end user
          and it must not be possible for applications to hide or obscure this
          indicator.
          </li>
          <li>The user agent should introduce rate limiting to prevent an
          application from making too many calls in too short a period of time.
          </li>
        </ul>
      </section><!-- Mitigations -->

      <!-- - - - - - - - - - - - User interaction guidelines  - - - - - - - -->
      <section> <h2>User interaction guidelines</h2>
        <p>
          Implementations SHOULD make sure the phone calls are controllable by
          the user at any point in time while the call is active.
        </p>
        <p>
          Implementations SHOULD validate user input using the
          <code>classify()</code> method of the
          <a><code>CommandParser</code></a> interface.
        </p>
      </section><!-- User interaction guidelines -->
    </section><!-- Security and privacy -->

    <!-- - - - - - - - - - -  Managing Call History   - - - - - - - - - - - -->
    <section class="appendix"> <h2>Managing call history</h2>
      <p>
        The <a>CallHistoryEntry</a> interface describes the minimum set of
        properties which a user agent would need to support for call history
        entries. For conference call there needs to be a separate
        <a>CallHistoryEntry</a> object for each call participant, sharing the
        same value for the <a>conferenceId</a> attribute.
      </p>
      <p class='note'>
        It is up the the implementations and applications how to store and
        access call history. This document only specifies the minimum content
        of the data to be saved.
      </p>
      <!-- - - - - - - - - - - CallHistoryEntry Interface - - - - - - - - - -->
      <section> <h3><code>CallHistoryEntry</code> interface</h3>
        <dl title="interface CallHistoryEntry" class="idl">
          <dt> readonly attribute DOMString          remoteParty      </dt>
          <dt> readonly attribute DOMString          serviceId        </dt>
          <dt> readonly attribute DOMString?         conferenceId     </dt>
          <dt> readonly attribute Date               startTime        </dt>
          <dt> readonly attribute unsigned long long duration         </dt>
          <dt> readonly attribute CallDirection      direction        </dt>
          <dt> readonly attribute DisconnectReason?  disconnectReason </dt>
          <dt> readonly attribute boolean            emergency        </dt>
        </dl>
        <!-- - - - - - - - - - -  remoteParty attribute - - - - - - - - - - -->
        <section> <h3>The <code>remoteParty</code> attribute</h3>
          <p>
            When getting the <code>remoteParty</code> attribute, the
            user agent MUST return the <a>remote party id</a> (e.g. telephone
            number) of the call participant.
          </p>
        </section><!-- remoteParty attribute -->
        <!-- - - - - - - - - - -  serviceId attribute - - - - - - - - - - - -->
        <section> <h3>The <code>serviceId</code> attribute</h3>
          <p>
            When getting the <code>serviceId</code> attribute, the user
            agent MUST return the <a>telephony service id</a> of the
            <a>telephony service</a> used for the call.
          </p>
        </section><!-- serviceId attribute -->
        <!-- - - - - - - - - - -  conferenceId attribute  - - - - - - - - - -->
        <section> <h3>The <code>conferenceId</code> attribute</h3>
          <p>
            When getting the <code>conferenceId</code> attribute, the
            user agent MUST return the <a>conference id</a> of the call, if the
            call has participated in a conference call. Otherwise, return
            <code>null</code>. string.
          </p>
        </section><!-- conferenceId attribute -->
        <!-- - - - - - - - - - - startTime attribute  - - - - - - - - - - - -->
        <section> <h3>The <code>startTime</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-startTime">startTime</dfn> attribute, the user
            agent MUST return the starting time of the call, measured from when
            the call is in <a>active</a> state.
          </p>
        </section><!-- startTime attribute -->
        <!-- - - - - - - - - - -  duration attribute  - - - - - - - - - - - -->
        <section> <h3>The <code>duration</code> attribute </h3>
          <p>
            When getting the <dfn id="CallHistoryEntry-duration">duration</dfn>
            attribute, the user agent MUST return the duration of the call
            expressed in milliseconds.
          </p>
        </section><!-- duration attribute -->
        <!-- - - - - - - - - - -  CallDirection attribute - - - - - - - - - -->
        <section> <h3>The <code>direction</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-direction">direction</dfn> attribute, the user
            agent MUST return the <a>CallDirection</a>.
          </p>
        </section><!-- CallDirection attribute -->
        <!-- - - - - - - - - - - disconnectReason attribute  - - - -  - - - -->
        <section> <h3>The <code>disconnectReason</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-disconnectReason">disconnectReason</dfn>
            attribute, the user agent MUST return the <a>DisconnectReason</a>
            if available, or return <code>null</code> otherwise.
          </p>
        </section><!-- disconnectReason attribute -->
        <!-- - - - - - - - - - -   emergency attribute  - - - - - - - - - - -->
        <section> <h3>The <code>emergency</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-emergency">emergency</dfn> attribute, the user
            agent MUST return <code>true</code> if the call was an emergency
            call, or <code>false</code> otherwise.
          </p>
        </section><!-- emergency attribute -->
      </section><!-- CallHistoryEntry Interface-->
      <!-- - - - - - - - - - -  CallDirection Enum  - - - - - - - - - - - - -->
      <section> <h2><a>CallDirection</a> enum</h2>
        <dl class="idl" title="enum CallDirection">
          <dt>dialed</dt>
          <dt>received</dt>
          <dt>missed</dt>
          <dt>missed-new</dt>
        </dl>
        <p>The call direction can take the following values:</p>
        <dl>
          <dt>"dialed"</dt>
          <dd>The call has been dialed.</dd>

          <dt>"received"</dt>
          <dd>The call has been received.</dd>

          <dt>"missed"</dt>
          <dd>The call has been missed.</dd>

          <dt>"missed-new"</dt>
          <dd>The call was a missed call not seen yet by the user.</dd>
        </dl>
      </section><!-- CallDirection Enum -->
    </section><!-- Managing Call History -->

    <!-- - - - - - - - - - - - - -  Telephony Services  - - - - - - - - - - -->
    <section  class="informative"> <h2>Telephony services</h2>
      <section> <h2>Definitions</h2>
      <section> <h3>Telephony service</h3>
      <p>
        A <dfn>telephony service</dfn> manages telephony operations associated
        with a subscriber identity, which is registered with a telephony
        service provider. For example, in cellular telephony, a telephony
        service is associated with <abbr title=
        "Subscriber Identity Module">SIM</abbr> card (Subscriber Identity
        Module). A telephony service can use different protocols for telephony
        signaling and media (e.g. GSM, CDMA, VoLTE, etc.) with the same
        subscriber identity.
      </p>
      <p>
        This section describes how dual-SIM and multiple-SIM card use case
        scenarios are supported. In dial-SIM use case the subscriber has two
        identities, which both can be active in the same time, i.e. could make
        and receive calls. In the multiple SIM card use case the subscriber has
        multiple identities, but only one can be active at a given time.
      </p>
      </section>
      <section> <h3>Telephony service id</h3>
      <p>
        A user agent can access zero or more <a>telephony service</a>s.
        Each telephony service has a unique <dfn>telephony service id</dfn>,
        which identifies a <a>telephony service</a> together with a user
        identity in the system.
      </p>
      <p>
        Access to a telephony service by any <a>origin</a> is restricted by a
        security policy. See the <strong>Security and privacy considerations
        </strong> section for more details.
      </p>
      <p>
        In the API, telephony services are represented by a DOMString that maps
        to a <a>telephony service id</a> for each <a>telephony service</a>
        available to an <a>origin</a>.
      </p>
      <p>
        It is strongly RECOMMENDED that implementations <strong>do not</strong>
        use use the MSISDN as the telephony service id. The <abbr
        title="Mobile Subscriber Integrated Services Digital Network-Number">
        MSISDN</abbr> cannot guarantee uniqueness. For telephony services that
        make use of a SIM card, it is RECOMMENDED that the ICC-ID be used for
        the service identifier. For reducing fingerprinting, implementations MAY
        choose to use generated UUID's or SHA signatures as service identifiers,
        associated in the implementation to the internal service identifiers
        such as ICC-ID.
      </p>
      </section>
      <section> <h3>Default telephony service</h3>
      <p>
        The <dfn>default telephony service</dfn> is the <a>telephony
        service</a> that is used as default for the <a>origin</a> when the
        service is not specified in the methods of this API.
      </p>
      <p>
        If there is no <a>default telephony service</a> set for the
        <a>origin</a>, the user agent SHOULD use the underlying system's default
        telephony service, if available and if allowed by policy.
        On implementations that have access to a hardware modem, regulations may
        require supporting emergency number dialing from PIN dialog or dialer
        interface. In this case even in the absence of a SIM card (subscriber
        identity) the implementations MUST implement a telephony service
        associated with only emergency dialing capability, and set it as default
        telephony service id even when no SIM card is present.
        When not even emergency calls are possible (e.g. it is a purely IP based
        implementation and there is no cellular modem), the implementation MAY
        use <code>null</code> for default <a>telephony service id</a>.
        In this case, also the <a>telephony</a> attribute of the <a
        href="http://www.whatwg.org/specs/web-apps/current-work/#dom-navigator">
        <code>Navigator</code></a> object object should be <code>null</code>,
        i.e. no telephony functionality is available.
      </p>
      <p>
        The default telephony service can be changed by the user through the
        <code>changeDefaultService()</code> method of the
        <a><code>ServiceManager</code></a> interface.
      </p>
      </section>
      </section> <!-- definitions -->

      <!-- - - - - - - - -  ServiceManager WebIDL definitions - - - - - - - -->
      <section> <h2>The <a>ServiceManager</a> Interface</h2>
        <p>
          The <a>ServiceManager</a> interface manages the state of the
          <a>TelephonyService</a> objects.
        </p>
        <dl title="interface ServiceManager : EventTarget" class="idl">
          <dt> readonly attribute DOMString?   defaultServiceId        </dt>
          <dt> Promise setDefaultService(DOMString serviceId)          </dt>
          <dt> Promise getServiceIds()                                 </dt>
          <dt> TelephonyService? getService(DOMString serviceId)       </dt>
          <dt> attribute EventHandler onserviceadded                   </dt>
          <dt> attribute EventHandler onserviceremoved                 </dt>
          <dt> attribute EventHandler ondefaultservicechanged          </dt>
        </dl>

      <!-- - - - - - - - - - - ServiceManager Event handlers  - - - - - - - -->
      <section> <h2>Event handlers</h2>
        <p>
          The following are the <a>event handler</a>s implemented by the
          <a>ServiceManager</a> interface.
        </p>
        <table class="simple">
          <tr>
            <th>event handler    </th>
            <th>event name       </th>
            <th>event type       </th>
            <th>short description</th>
          </tr>
          <tr>
            <td><dfn id="widl-ServiceManager-onserviceadded">
                   <code>onserviceadded</code></dfn>
            </td>
            <td><dfn><code>serviceadded</code></dfn></td>
            <td><a>TelephonyServiceEvent</a></td>
            <td>handles a new enabled telephony service.</td>
          </tr>
          <tr>
            <td> <dfn id="widl-ServiceManager-onserviceremoved">
                   <code>onserviceremoved</code></dfn>
            </td>
            <td><dfn><code>serviceremoved</code></dfn></td>
            <td><a>TelephonyServiceEvent</a></td>
            <td>handles a disabled telephony service.</td>
          </tr>
          <tr>
            <td><dfn id="widl-ServiceManager-ondefaultchanged">
                   <code>ondefaultservicechanged</code></dfn>
            </td>
            <td><dfn><code>defaultservicechanged</code></dfn></td>
            <td><a>TelephonyServiceEvent</a></td>
            <td>handles the change of default telephony service.</td>
          </tr>
        </table>
      </section>

      <!-- - - - - - - - -  Telephony service changes - - - - - - - - - - - -->
      <section> <h3>Handling events for changes in telephony services</h3>
        <p>
          Telephony services can be added or removed from the system at any
          time (e.g., the user pops out the SIM card or adds a different SIM
          card; the user tells the system to only allow certain applications to
          access a particular telephony service, etc.).
        </p>
        <p>
          The functionality related to managing telephony services is described
          in the <a><code>ServiceManager</code></a> interface.
          <a><code>TelephonyManager</code></a> implements the the
          <a><code>ServiceManager</code></a> interface.
        </p>
        <p>
          When a <a>telephony service</a> is either added or removed in the
          system, or the <a>default telephony service</a> is changed, the user
          agent MUST run the steps to change the telephony service:
        </p>
        <ol id="steps-ServiceManager-change-events">
          <li>Let <var>event</var> be a new <a>TelephonyServiceEvent</a>, with
          the event name set to <code>serviceremoved</code> if the telephony
          service was removed, or <code>serviceadded</code> if it was added, or
          <code>defaultservicechanged</code> if the
          <a>default telephony service</a> has changed.
          This event does not bubble, is not cancelable, has no default action,
          and its <code>serviceId</code> attribute is set to the
          <a>telephony service id</a> of the <a>telephony service</a> that
          initiated this algorithm.
          </li>
          <li>If the service has been removed and it's been the default
          telephony service for the <a>origin</a>, then change default telephony
          service.
          </li>
          <li>
            <a>Queue a task</a> to fire an event <var>event</var> at the
            <a>TelephonyManager</a>.
          </li>
        </ol>
      </section>

      <!-- - - - - - - - - - -  Default Telephony Service - - - - - - - - - -->
      <section> <h3>The <a><code>defaultServiceId</code></a> property</h3>
        <p>
          When getting the <dfn id=
          "widl-ServiceManager-defaultServiceId">defaultServiceId</dfn>
          attribute, the user agent MUST return the <code>DOMString</code> that
          represents the <a>telephony service id</a> of the
          <a>default telephony service</a> (if any).
          Otherwise, it returns <code>null</code>.
        </p>
      </section>

      <!-- - - - - - - - - Setting the default TelephonyService - - - - - - -->
      <section> <h3>The <code>setDefaultService()</code> method</h3>
        <p>
          The <dfn id=
          "widl-ServiceManager-setDefaultService-Promise-DOMString-serviceId">
          setDefaultService()</dfn> method provides a means to change the
          <a>default telephony service</a> used by the user agent. When
          invoked, the user agent MUST run the the following steps:
        </p>
        <ol id="steps-set-default-service">
          <li>Let <var>serviceId</var> be the first argument passed to
          this operation.
          </li>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
          object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
          asynchronously.
          </li>
          <li>If <var>serviceId</var> does not exactly match the identifier of
          any <a>telephony service</a> known to the user agent,run the following
          error steps and terminate this algorithm:
            <ol id="steps-promise-error">
              <li>Let <var>error</var> be a new <a href=
              "http://dom.spec.whatwg.org/#domerror"><code>DOMError</code></a>
              object whose name is <a href=
              "http://dom.spec.whatwg.org/#notfounderror">
              <code>NotFoundError</code></a>.
              </li>
              <li>Invoke <var>resolver</var>'s reject(value) method with <var>
                error</var> as the value argument.
              </li>
            </ol>
          </li>
          <li>If <var>serviceId</var> exactly matches the
            <a>telephony service id</a> of the current
            <a>default telephony service</a>, run the following
            sub-steps and terminate this algorithm:
            <ol>
              <li>Invoke <var>resolver</var>'s accept(value) method with
                  <var>serviceId</var> as the value argument.
              </li>
            </ol>
          </li>
          <li>Otherwise, make a request to the underlying system to change from
          the current default telephony service to the one identified by
          <var>serviceId</var>.
          </li>
          <li>Wait for response from the underlying system.
          </li>
          <li>If it's not possible to change the default telephony service for
          whatever reason: timeout, security, etc., then run the following
          sub-steps and terminate this algorithm:
            <ol>
              <li>Let <var>error</var> be a new DOMError object whose name is
              <code>"NoModificationAllowedError"</code>.
              </li>
              <li>Call <var>resolver</var>'s <code>reject(value)</code> method
              with <var>error</var> as the <var>value</var> argument.
              </li>
            </ol>
          </li>
          <li>Otherwise, <a>queue a task</a> to:
            <ol>
              <li>Change the <a>defaultServiceId</a> attribute to the
              <a>telephony service id</a> of the new <a>default telephony
              service</a>.
              </li>
              <li>invoke <var>resolver</var>'s <code>accept(value)</code> method
              with the id of the new default service as <var>value</var>
              argument.
              </li>
              <li>
                <a>Fire an event</a> named <code>defaultservicechanged</code>
                at the <a>telephony</a> attribute of the navigator object.
              </li>
            </ol>
          </li>
        </ol>
      </section> <!-- setDefaultService -->

      <!-- - - - - - - - - - - - getServiceIds()  - - - - - - - - - - - - - -->
      <section> <h3>The <code>getServiceIds()</code> method</h3>
        <p>
          The <dfn id="widl-ServiceManager-getServiceIds-Promise">
          getServiceIds()</dfn> method provides a means to retrieve the
          list of <a>telephony service id</a>s representing enabled
          <a>telephony service</a>s. When invoked, the user agent MUST run the
          following steps:
        </p>
        <ol id="steps-get-serviceids">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Make a request to the underlying system to retrieve the list of
            <a>telephony service id</a>s of enabled <a>telephony service</a>s.
          </li>
          <li>Wait for response from the underlying system.
          </li>
          <li>If it's not possible to retrieve the list of telephony service
          identifiers for whatever reason: timeout, security, etc., then run the
          following sub-steps and terminate this algorithm:
            <ol>
              <li>Let <var>error</var> be a new DOMError object whose name is
              <code>"NoModificationAllowedError"</code>.
              </li>
              <li>Call <var>resolver</var>'s <code>reject(value)</code> method
              with <var>error</var> as the <var>value</var> argument.
              </li>
            </ol>
          </li>
          <li>Otherwise, <a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept(value)</code> method with the sequence of id's as
            <var>value</var> argument, even if the list is empty.
          </li>
        </ol>
      </section> <!-- getServiceIds -->

      <!-- - - - - - - - - - - - getService() - - - - - - - - - - - - - - - -->
      <section> <h3>The <code>getService()</code> method</h3>
        <p>
          The <dfn
       id="widl-ServiceManager-getService-TelephonyService-DOMString-serviceId">
          getService()</dfn> method provides a means to synchronously retrieve
          the <a><code>TelephonyService</code></a> object corresponding to a
          <a>telephony service id</a>. When invoked, the user agent MUST run the
          following steps:
        </p>
        <ol id="steps-get-service">
          <li>Let <var>service</var> be the <a><code>TelephonyService</code></a>
            object whose <code>serviceId</code> property is equal to
            <var>service</var>. Implementations SHOULD maintain an associative
            list of <a>telephony service id</a>s to
            <a><code>TelephonyService</code></a> objects.
          </li>
          <li>Return <var>service</var>.
          </li>
        </ol>
      </section> <!-- getServiceIds -->
      </section> <!-- ServiceManager -->

      <!-- - - - - - - - - - Interface TelephonyServiceEvent  - - - - - - - -->
      <section> <h2>The <a>TelephonyServiceEvent</a> Interface</h2>
        <p>
          Defines a telephony event for notifying a changed <a>telephony
          service</a>.
        </p>
        <dl title=
        "[Constructor(DOMString type, optional TelephonyServiceEventInit eventInitDict)]interface TelephonyServiceEvent : Event"
        class="idl">
          <dt>readonly attribute DOMString serviceId</dt>
        </dl>
        <!-- - - - - - - - - - serviceId attribute  - - - - - - - - - - - - -->
        <section>
          <h3>The <code>serviceId</code> attribute</h3>
          <p>
            When getting the <code>serviceId</code>, the user
            agent MUST return the <a>telephony service id</a> of the
            <a>telephony service</a> that triggered the event.
          </p>
        </section>
      </section><!-- interface TelephonyServiceEvent -->

      <!-- - - - - - - - - - Interface TelephonyService - - - - - - - - - - -->
      <section class="informative">
      <h2>The <a>TelephonyService</a> Interface</h2>
        <p>The interface which manages a given <a>telephony service</a>s present
          in the system. Different services may provide different set of
          interfaces for managing service specific settings, depending on
          protocol and the current telephony network to which the device is
          connected.
        </p>
        <dl title="[NoInterfaceObject]
          interface TelephonyService: EventHandler"
          class="idl">
          <dt>readonly attribute DOMString            serviceId     </dt>
          <dt>readonly attribute boolean              enabled       </dt>
          <dt>readonly attribute boolean              emergencyOnly </dt>
          <dt>readonly attribute TelephonyProtocol    protocol      </dt>
          <dt>readonly attribute TelephonyServiceType serviceType   </dt>
          <dt>         attribute DOMString            displayName   </dt>
          <dt>readonly attribute DOMString            provider      </dt>
          <dt>Promise setEnabled(boolean enabled)                   </dt>
        </dl>

        <!-- - - - - - - - - TelephonyService.serviceId - - - - - - - - - - -->
        <section> <h3>The <code>serviceId</code> property</h3>
          <p>
            It MUST return the <a>telephony service id</a> of the
            <a>telephony service</a>.
          </p>
        </section> <!--serviceId -->

        <!-- - - - - - - - - TelephonyService.enabled - - - - - - - - - - - -->
        <section> <h3>The <code>enabled</code> property</h3>
          <p>
            It MUST return or set the enabled state of the service, i.e.
            <code>TRUE</code> if the service is enabled, and <code>FALSE</code>
            if the service is disabled.
          </p>
        </section> <!-- enabled -->

        <!-- - - - - - - - - TelephonyService.emergencyOnly - - - - - - - - -->
        <section> <h3>The <code>emergencyOnly</code> property</h3>
          <p>
            It MUST return <code>TRUE</code> if the service permits only
            emergency calls, and <code>FALSE</code> otherwise.
          </p>
        </section> <!-- emergencyOnly -->

        <!-- - - - - - - - - TelephonyService.displayName - - - - - - - - - -->
        <section> <h3>The <code>displayName</code> property</h3>
          <p>
            It MUST return the string value as displayed to the user by the
            application. It MAY be a localization string identifier.
          </p>
        </section> <!-- displayName -->

        <!-- - - - - - - - - TelephonyService.provider  - - - - - - - - - - -->
        <section> <h3>The <code>provider</code> property</h3>
          <p>
            It MUST return the name of the service provider, which SOULD be
            unique in the telephony domain. A provider may have multiple
            services provisioned, therefore multiple
            <code>TelephonyService</code> objects MAY have the same provider.
          </p>
        </section> <!-- provider -->

        <!-- - - - - - - - - TelephonyService.protocol  - - - - - - - - - - -->
        <section> <h3>The <code>protocol</code> property</h3>
          <p>
            The following values are supported as telephony protocols:
            <ul>
              <li><code>"unknown"</code>: protocol not known</li>
              <li><code>"gsm"</code>: used for GSM and related protocols</li>
              <li><code>"cdma"</code>: used for CDMA and related protocols</li>
              <li><code>"sip"</code>: used for SIP based protocols and
                extensions</li>
              <li><code>"xmpp"</code>: used for XMPP based protocols and
                extensions.
              </li>
          </p>
          </p>
          <dl title="enum TelephonyProtocol" class="idl">
            <dt>unknown</dt>
            <dt>gsm</dt>
            <dt>cdma</dt>
            <dt>sip</dt>
            <dt>xmpp</dt>
          </dl>
        </section> <!-- protocol -->

        <!-- - - - - - - - - TelephonyService.serviceType - - - - - - - - - -->
        <section> <h3>The <code>serviceType</code> property</h3>
          <p>
            The following values are supported as <a>telephony service</a> type:
            <ul>
              <li><code>"unknown"</code>: service type not known</li>
              <li><code>"hw"</code>: hardware modem</li>
              <li><code>"hfp"</code>: external modem used through Bluetooth
                Hands Free Profile (for control and also handles audio)
              </li>
              <li><code>"sap"</code>: external modem used through Bluetooth SIM
                Access Profile (only for control, audio is local)
              </li>
              <li><code>"sw"</code>: software modem</li>
              <li><code>"voip"</code>: VoIP account.</li>
          </p>
          <dl title="enum TelephonyServiceType" class="idl">
            <dt>unknown</dt>
            <dt>hw</dt>
            <dt>hfp</dt>
            <dt>sap</dt>
            <dt>sw</dt>
            <dt>voip</dt>
          </dl>
        </section> <!-- serviceType -->

        <!-- - - - - - - - - TelephonyService.setEnabled()  - - - - - - - - -->
        <section> <h3>The <code>setEnabled()</code> method</h3>
          <p>
            The <dfn
            id="widl-TelephonyService-setEnabled-Promise-boolean-enabled">
            setEnabled()</dfn> method enables or disabled the
            <a>telephony service </a>. When invoked, the user agent MUST run the
            following steps:
          </p>
          <ol id="steps-telephonyservice-setenabled">
            <li>Let <var>enabled</var> be the first argument passed to
              this operation.
            </li>
            <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated resolver.
            </li>
            <li>Return <var>promise</var> and continue the following steps
              asynchronously.
            </li>
            <li>Make a request to the underlying system to enable the
              <a>telephony service</a> if <var>enabled</var> is
              <code>TRUE</code>, and disable it otherwise.
            </li>
            <li>Wait for response from the underlying system.
            </li>
            <li>If it was not possible to complete the request for whatever
              reason: timeout, security, etc., then run the following sub-steps
              and terminate this algorithm:
              <ol>
                <li>Let <var>error</var> be a new DOMError object whose name is
                <code>"NoModificationAllowedError"</code>.
                </li>
                <li>Call <var>resolver</var>'s <code>reject(value)</code> method
                with <var>error</var> as the <var>value</var> argument.
                </li>
              </ol>
            </li>
            <li>Otherwise, when the request has been completed,
              <a>queue a task</a> to invoke <var>resolver</var>'s
              <code>accept()</code> method. Parallel to this, implementations
              MUST also follow the
              <a href="steps-servicemanager-change-events">steps</a> for
              handling service change events.
            </li>
          </ol>
        </section> <!-- setEnabled() -->

        <!-- - - - - - - - TelephonyService extension note  - - - - - - - - -->
        <section> <h3>Extension possibilities</h3>
        <section class="note">
          <p>
            In the future, <a>TelephonyService</a> could be extended e.g. in
            the following way:
          </p>
          <dl title="CellularService implements TelephonyService" class="idl">
          </dl>
          <dl title="[NoInterfaceObject]
          interface CellularService" class="idl">
          <dt>readonly attribute SimInfo?               simInfo     </dt>
          <dt>readonly attribute SimSettings?           simSettings </dt>
          <dt>readonly attribute TelephonyNetwork?      network     </dt>
          <dt>readonly attribute CallForwarding?        forwarding  </dt>
          <dt>readonly attribute CallBarring?           barring     </dt>
          <dt>readonly attribute CallMeters?            meters      </dt>
          <dt>readonly attribute SupplementaryServices? ss          </dt>
          <dt>//... and other interfaces...                         </dt>
          </dl>
          <p>Depending on implementation, on operator network support and on
          settings, some of these interfaces may not be available, in which case
          the value of the corresponding attributes is set to <code>null</code>.
          </p>
        </section> <!-- note -->
        </section> <!-- extensions -->
      </section> <!-- TelephonyService -->
    </section> <!-- Telephony services -->


    <!-- - - - - - - - - - - - - -  Changes - - - - - - - - - - - - - - - - -->
    <section class="appendix" id="Changes">
      <h2>
        Changes
      </h2>
      <p>
        The following is a list of substantial changes to the document. For a
        complete list of changes, see the <a href=
        "https://github.com/sysapps/telephony/commits/gh-pages">change log on
        Github</a>. You can also view the <a href=
        "https://github.com/sysapps/telephony/issues?page=1&amp;state=closed">
        recently closed bugs</a>.
      </p>
      <ul>
        <li>No changes yet.
        </li><!--
        <li><a href="">Link to bug that documents the change</a></li>
        -->
      </ul>
    </section>
    <!-- - - - - - - - - - - - - - Acknowledgements - - - - - - - - - - - - -->
    <section>
      <h2>
        Acknowledgements
      </h2>
      <p>
        The editors would like to express their gratitude to the Mozilla B2G
        Team for their technical guidance, implementation work and support,
        especially to Ben Turner and Jonas Sicking, the authors of the
        <cite><a href="https://wiki.mozilla.org/WebAPI/WebTelephony">B2G
        WebTelephony API</a></cite>. Also, thanks to Denis Kenzior
        (<cite><a href="https://ofono.org/">ofono</a></cite> maintainer) and
        Oleg Zhurakivskyy of Intel Open Source Technology Center, and many
        others for their advice and support.
      </p>
    </section>
  </body>
</html>

<!--
For conference issues, see also:

GSM
===

GSM TS 04.08 call control states
GSM TS 04.83 call hold states
GSM TS 04.80 error values
GSM TS 24.084 Phase-4 MPTY
GSM TS 23.018 Basic call handling; Technical realization
      http://www.3gpp.org/ftp/Specs/html-info/23018.htm
IMS TS 23.228 IP Multimedia Subsystem (IMS); Stage 2
      http://www.3gpp.org/ftp/Specs/html-info/23228.htm

- any call ID will serve as a transaction ID
- implementation to generate a MPTY_ID which refers to the list of all active
call ID's in the mpty call

CDMA
====

http://www.scribd.com/doc/7029977/Network-Inter-Working-Between-GSM-MAP-and-ANSI41-CDMA

http://support.verizonwireless.com/support/faqs/FeaturesandOptionalServices/faq_3-way_calling.html
-->
