<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>
      Web Telephony API
    </title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class=
    'remove'>
</script>
    <script class="remove">
/*Respec configuration*/
    var respecConfig = {
          specStatus:           "ED",
          shortName:            "telephony",
          noLegacyStyle:        true,
          publishDate:          "",
          previousPublishDate:  "",
          previousMaturity:     "",
          edDraftURI:           "http://www.w3.org/2012/sysapps/telephony/",
          // lcEnd:                "",
          crEnd:                "",
          editors: [
            { name: "Marcos Cáceres", company: "Mozilla",
                  companyURL: "http://www.tid.es/" },
            { name: "José M. Cantera", company: "Telefónica",
                    companyURL: "http://www.tid.es/" },
            { name: "Eduardo Fullea", company: "Telefónica",
                    companyURL: "http://www.tid.es/" },
            { name: "Zoltan Kis", company: "Intel",
                    companyURL: "http://www.intel.com/" },
            { name: "John Lyle", company: "University of Oxford",
                    companyURL: "http://www.cs.ox.ac.uk/"
            }
          ],
          inlineCSS:    true,
          noIDLIn:      true,
          // extraCSS:     ["../ReSpec.js/css/respec.css"],
          wg:           "System Applications Working Group",
          wgURI:        "http://www.w3.org/2012/sysapps/",
          wgPublicList: "public-sysapps",
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/58119/status",
          otherLinks: [{
            key: "Repository",
            data: [{
                    value: "We are on Github.",
                    href: "https://github.com/sysapps/telephony"
                }, {
                    value: "File a bug.",
                    href: "https://github.com/sysapps/telephony/issues"
                }, {
                    value: "Commit history.",
                    href: "https://github.com/sysapps/telephony/commits/gh-pages"
                }
            ]
        }]
    };
    </script>
    <style>
/*HTML5 Tidy screws up if this line is missing.*/
    figure{
        display: block;
        width: auto;
        margin: 2em auto;
        text-align: center;
    }
    figcaption{
        display: block;
        margin-top: 1em;
    }
    </style>
  </head>
  <body>
    <!-- - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - -->
    <section id="abstract">
      <p>
        This specification defines an API to manage telephone calls. A typical
        use case of the <cite>Web Telephony API</cite> is the implementation of
        a 'Dialer' application supporting multiparty calls and multiple
        <a>telephony service</a>s.
      </p>
    </section>
    <!-- - - - - - - - - - -  Status of this document - - - - - - - - - - - -->
    <section id="sotd">
      <p>
        Implementors should be aware that this specification is not stable.
        <strong>Implementors who are not taking part in the discussions are
        likely to find the specification changing out from under them in
        incompatible ways.</strong> Vendors interested in implementing this
        specification before it eventually reaches the Candidate Recommendation
        stage should join the aforementioned mailing lists and take part in the
        discussions.
      </p>
      <p>
        Significant changes to this document since last publication are
        documented in the <a href="#Changes">Changes section</a>.
      </p>
    </section>
    <!-- - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - -->
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        The <cite>Web Telephony API</cite> allows applications to manage
        interaction with telephony call signaling, but does not handle audio
        channels management and volume control.
      </p>
      <p>
        For managing telephony calls, a <a>call state</a> handler needs to be
        defined, which defines actions on the call states, usually updating the
        user interface elements enabling interaction with the call, according
        to what user input different call states require.
        An example of making and receiving a telephony call is provided below.
      </p>
      <pre title="Dialing a call" class="example highlight">
        var number = '+1234567890';
        navigator.telephony.dial(number).then(
          function(call) {
            console.log("The call to " + number +
              " is controlled by TelephonyCall object with id: " + call.callId);
            console.log("Now hanging up...");
            call.disconnect();
          },
          function (err) {
            console.log("Error making the call: " + err.message);
          });

      </pre>
      <pre title="Monitoring received and dialed calls"
           class="example highlight">
        // handle the state changes of both received and dialed calls
        function stateHandler(event) {
          var call = event.call;
          var state = call.state;
          if (state == 'incoming' || state == 'waiting') {
            // new TelephonyCall object has been created and added to CallManager
            // display the dialog for incoming/waiting call
            // wait for user input: accept, hangup, hold, deflect
            console.log(state + ' call...');
          } else if (state == 'dialing') {
            console.log('Call is dialing');
          } else if (state == 'alerting') {
            console.log('Outgoing call is alerting the remote party');
          } else if (state == 'ringing') {
            console.log('Incoming call is ringing');
            // wait for user input: accept, hangup, hold, deflect
          } else if (state == 'accepted') {
            console.log('Incoming call is accepted');
          } else if (state == 'held') {
            console.log('Call is on hold');
          } else if (state == 'active') {
            console.log('Call is active');
            if (call.conferenceId)
              console.log('Call is part of a conference call');
          } else if(state == 'disconnected') {
            // the TelephonyCall object has been removed from the CallManager list
            // update call history
            console.log('Call disconnected: ' + call.stateReason);
          }
        }

        navigator.telephony.addEventListener("callstatechange", stateHandler);

      </pre>
      <p>
        The use cases for this specification are collected in the <a href=
        'http://www.w3.org/wiki/System_Applications_WG:_Telephony_API'>wiki
        page</a> of this API.
      </p>
      <p>
        The following specifications informed the design of the <cite>Web
        Telephony API</cite>: for <abbr title=
        "Global System for Mobile Communications">GSM</abbr> the [[!GSM-CALL]]
        suite, for IMS/SIP the [[!IMS]] suite, for <abbr title=
        "Extensible Messaging and Presence Protocol ">XMPP</abbr> the
        [[!JINGLE]] specification. Note, however, that IMS/SIP and XMPP are not
        supported in this version.
      </p>
      <p>
        It is likely that the same API would work also for <abbr title=
        "Session Initiation Protocol">SIP</abbr> and <abbr title=
        "Extensible Messaging and Presence Protocol ">XMPP</abbr> calls with
        the exception of multiparty call handling, which is modeled after the
        cellular multiparty calls. Future versions of this specification will
        probably add <abbr title="Session Initiation Protocol">SIP</abbr> and
        <abbr title="Extensible Messaging and Presence Protocol ">XMPP</abbr>
        conference support.
      </p>
      <p class='issue'>
        It is under discussion whether a system message should be propagated
        when a CDMA telephony call is active, since not all CDMA networks
        support concurrent services. Therefore, many applications will lose
        their data connection when the end user is in a voice call.
      </p>
    </section>
    <!-- - - - - - - - - - - - - - Permissions  - - - - - - - - - - - - - - -->
    <section class="informative"> <h2>Permissions</h2>
      <p>
        This API conforms to the permission model defined for System
        Applications.
      </p>
      <p class="issue">
        The permission model is not finished yet and it will affect on how to
        expose lower vs higher privilege functionality in this API.
      </p>
    </section>
    <!-- - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - -->
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in
        this specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]],
        as this specification uses that specification and terminology.
      </p>
    </section>
    <!-- - - - - - - - - - - - - -  Dependencies  - - - - - - - - - - - - - -->
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        This specification depends on the following interfaces and concepts
        defined in other specifications.
      </p>
      <p>
        The following dependencies are defined in [[!HTML]]:
        <dfn><code><a href="http://www.whatwg.org/specs/web-apps/current-work/#eventhandler">
        EventHandler</a></code></dfn> interface, <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#queue-a-task">queue
        a task</a></dfn>, <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#event-handlers">event
        handler</a></dfn>, <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#origin">origin</a></dfn>,
        <dfn><a href=
        "http://www.whatwg.org/specs/web-apps/current-work/#task-source">task
        source</a></dfn>.
      </p>
      <p>
        The following dependencies are defined in [[!DOM4]]: the <dfn><a href=
        "http://dom.spec.whatwg.org/#event"><code>Event</code></a></dfn> and
        the <dfn><a href=
        "http://dom.spec.whatwg.org/#promise"><code>Promise</code></a></dfn>
        interfaces, the concepts of a <a href=
        "http://dom.spec.whatwg.org/#concept-resolver"><dfn>resolver</dfn></a>,
        <dfn><a href="http://dom.spec.whatwg.org/#concept-event-fire">fire an
        event</a></dfn>.
      </p>
    </section>
    <!-- - - - - - - - - - -  Task Source - - - - - - - - - - - - - - - - - -->
    <section> <h2>Task Source</h2>
      <p>
        The <a>task source</a> for all <a title="queue a task">tasks queued</a>
        in this specification is the <dfn>telephony task source</dfn>.
      </p>
    </section>
    <!-- - - - - - - - - - - - - -  Terminology - - - - - - - - - - - - - - -->
    <section> <h2>Terminology</h2>
      <section> <h3>Telephony service</h3>
      <p>
        A <dfn>telephony network</dfn> is the infrastructure providing telephony
        functionality in a given geographical area, to which the device running
        the <a>user agent</a> is registered with at the point of operation.
      </p>
      <p>
        A <dfn>subscriber identity</dfn> identifies and authenticates the user
        in the <a>telephony network</a>. In cellular telephony, subscriber
        identity is associated with the <abbr title=
        "Subscriber Identity Module">SIM</abbr> card (Subscriber Identity
        Module). A given subscriber identity can be used in different, but
        interoperable <a>telephony network</a>s.
      </p>
      <p>
        A <dfn>telephony provider</dfn> is the company operating the
        <a>telephony network</a>. A telephony provider can have multiple
        <a>telephony network</a>s.
      </p>
      <p>
        A <dfn>telephony modem</dfn> is the software and hardware entity which
        implements the telephony protocols needed for interacting with the
        <a>telephony network</a>s, and which exposes an API which is used for
        implementing this API specification.
        A modem can be local to the device, or can be a remote modem, used e.g.
        via a paired Bluetooth device.
      </p>
      <p>
        A <dfn>telephony service</dfn> is an abstract concept used in this API
        to denote the tuple of a given <a>subscriber identity</a>, and a given
        <a>telephony modem</a>. If any of these elements is changed, it means a
        different telephony service. Note that when a device is moving, and
        eventually changes the <a>telephony network</a>, it continues to see the
        same telephony service.
        A telephony service can use different protocols for telephony
        signaling and media (e.g. GSM, CDMA, VoLTE, etc.) with the same
        subscriber identity. There may be multiple SIM cards registered with the
        same provider, which will map to different telephony services.
      </p>
      <p>
        Note the difference between dual-SIM and multiple-SIM card use cases.
        In dual-SIM use case the subscriber has two identities, which both can
        be active in the same time, i.e. could make and receive calls. In the
        multiple SIM card use case the subscriber has multiple identities, but
        only one can be active at a given time. These constraints are not
        exposed by this API, and implementations are expected to encapsulate
        them.
      </p>
      </section>
      <section> <h3>Telephony service id</h3>
      <p>
        A user agent can access zero or more <a>telephony service</a>s.
        Each telephony service has a unique <dfn>telephony service id</dfn> at
        any given moment, but it is not required to uniquely identify services
        in call history. In other words, the identifiers MAY be reused as
        services appear and disappear. Service identifiers
        SHOULD NOT be saved in call history, only displayable service names.
      </p>
      <p>
        Access to a telephony service by any <a>origin</a> is restricted by a
        security policy. See the <strong>Security and privacy considerations
        </strong> section for more details.
      </p>
      <!--p>
        In the API, telephony services are represented by a DOMString that maps
        to a <a>telephony service id</a> for each <a>telephony service</a>
        available to an <a>origin</a>.
      </p-->
      <p>
        It is strongly RECOMMENDED that implementations <strong>do not</strong>
        use use the MSISDN as the telephony service id. The <abbr
        title="Mobile Subscriber Integrated Services Digital Network-Number">
        MSISDN</abbr> cannot guarantee uniqueness. For telephony services that
        make use of a SIM card, it is RECOMMENDED that the ICC-ID is used for
        the service identifier. For reducing fingerprinting, implementations
        SHOULD choose to use opaque UUID's or SHA signatures as service
        identifiers, associated in the implementation to the internal service identifiers such as ICC-ID.
      </p>
      </section>
      <section> <h3>Selected telephony service</h3>
      <p>
        The <dfn>selected telephony service</dfn> is the <a>telephony
        service</a> that is used as default for the <a>origin</a> for the
        methods of this API.
      </p>
      <p>
        Implementations are not required to initialize a selected service at
        startup. Instead, clients of this API may choose the preferred moment of initializing the telephony system by invoking the
        <code>navigator.telephony.service.getServices()</code> (if implemented)
        or the <code>navigator.telephony.getCalls()</code>, or the
        <code>navigator.telephony.dial()</code> methods.
      </p>
      <p>
        If there is no <a>selected telephony service</a> set for the
        <a>origin</a>, the user agent SHOULD use the underlying system's default
        telephony service, if available.
        On implementations that have access to a hardware modem, regulations
        require supporting emergency number dialing from PIN dialog or dialer
        interface even in the absence of a SIM card.
      </p>
      </section>
      <section><h3>Telephony call</h3>
      <p>
          A <dfn>telephony call</dfn> means
          a connected communication link between two or more call participants
          in a given a <a>telephony service</a>. From an application's
          point of view, a telephony call is an object which exposes properties
          and methods to monitor and control telephony calls.
          A telephony call involving more than two parties are referred to as a
          <a>conference call</a> or a multiparty call.
      </p>
      </section>
      <section><h3>Remote party identifier</h3>
      <p>
          A <dfn>remote party id</dfn>, e.g. as a phone number, uniquely
          identifies a remote participant in a telephony call in the given
          <a>telephony service</a>.
      </p>
      </section>
      <section><h3>Outbound and inbound call</h3>
      <p>
          Telephony calls initiated by the user using a <a>telephony service</a>
          in the system is an <dfn>outbound call</dfn>.
          Conversely, a telephony call from a remote party is an
          <dfn>inbound call</dfn>.
      </p>
      </section>
      <section><h3>Call identifier</h3>
      <p>
          Every telephony call has a <dfn>call id</dfn>, which is a string that
          uniquely identifies the call among the other calls in progress. It is
          not required that the <a>call id</a> be unique across call history.
          Clients SHOULD NOT save the <a>call id</a> in call history, but SHOULD
          maintain their own id space, e.g. using start time and remote party
          information.
      </p>
      </section>
      <section><h3>Call state</h3>
        <p>
          A <dfn>call state</dfn> represents the state of interaction between a
          <a>telephony service</a>, the <a>user agent</a>, and one or more
          remote parties.
          In the process of establishing and maintaining a connection between
          multiple parties, a telephony call transitions through various
          call states. A <a>telephony call</a> is always in a defined
          call state, which can only be changed by using methods of this API, or
          by the <a>telephony service</a>.
        </p>
        <p>
          in GSM, there are 3 types of call states:
          <ul>
            <li>GSM TS 04.08 defines call <i>control</i> states,</li>
            <li>GSM TS 04.83 defines call <i>hold</i> states, and </li>
            <li>GSM TS 24.084 defines auxiliary states associated with a
              multiparty call.</li>
          </ul>
          This would result in a 3-dimensional call state space, where not all
          combinations are allowed, for example a call cannot be split from a
          conference call while it is held.
        </p>
        <p>
          Instead of using a 3-dimensional call state space, this API uses a one
          dimensional call state model, in which call states map to valid
          combinations in of 3-dimensional states, and are able to describe
          valid state transitions.
        </p>
        </section>
      <section><h3>Active call</h3>
      <p>
          An <dfn>active call</dfn> is a <a>telephony call</a> in the
          <a>active</a> state representing a connected call which is bound to
          the media input and output devices (e.g. microphone, speaker, tone
          generator). Note that a call on hold is also connected from a call
          signaling point of view, but it is not bound to media input and output
          devices.
      </p>
      </section>
      <section> <h3>Conference call</h3>
        <p>
          A <dfn>conference call</dfn> is a <a>telephony call</a> with multiple
          remote party participants. The way conference calls are handled are
          quite different depending on the telephony protocol.
        </p>
        <p class="note">
          This of the API version supports GSM multiparty calls and CDMA 3-way
          calls. Supporting SIP and XMPP conferences is possible in the future,
          and would require additional method parameters to conference creation.
        </p>
        <p class="note">
          Note that the terms "GSM" and "CDMA" refer to the type of interaction
          needed with the telephony network, rather than the radio technology
          itself. For instance, 3G and 4G GSM is also using CDMA radio
          technology, but expose a GSM type interface.
        </p>
        <p>
         Creating GSM multiparty calls involve the following user interaction:
         <ol>
           <li>dial the first number</li>
           <li>when the call is active, put the call on hold</li>
           <li>dial the second number</li>
           <li>when the second call is active, press the 'Conference' button
             </li>
           <li>optionally repeat the steps so far to add more calls</li>
           <li>any participating call can be split from the conference call
             for private chat, during which the conference call is put on hold
             </li>
           <li>during private chat, it is possible to re-merge the call into the
             conference call using the same procedure as described from step 2.
             </li>
           <li>disconnecting a GSM conference call will disconnect all member
             calls.</li>
         </ol>
        </p>
        <p>
         In CDMA, only a limited form of conference call is supported, called
         3-way call, which is usually mapped to multiple presses of the 'Call'
         button, which in background uses modem AT commands (ATD, ATH and Flash)
         to achieve the desired action. Handling 3-way calls involve the
         following user interactions:
         <ol>
           <li>dial the first number (involves the ATD command)</li>
           <li>when the call is active, dial the second number (by sending a
             Flash command with the second number), which automatically puts
             the first call on hold</li>
           <li>when the second call is active, press the 'Call' button to make
             3-way call (by sending a Flash command)</li>
           <li>while the 3-way call is active, press the 'Call' button to
             disconnect the second call (which sends a Flash command</li>
           <li>while the 3-way call is active, any incoming call SHOULD be
             rejected</li>
           <li>while the 3-way call is active, pressing 'Hangup' (ATH command)
           will disconnect all calls.</li>
         </ol>
        </p>
        <p>
         The common way to support these user interactions by this API, there is
         possible programmatic support for the following actions:
         <ol>
           <li>dial the first call by calling the <code>dial()</code> method
             </li>
           <li>dial the second call, which puts the first call on hold</li>
           <li>create the conference call from the held and active calls by
             calling the <code>createConference()</code> method</li>
           <li>disconnecting the second call works from both CDMA and GSM, by
             calling the <code>disconnect()</code> method on the second call
             object</li>
           <li>disconnecting any other than the last call will work in GSM, but
             will hang up all calls in CDMA. The last call can be separately
             disconnected also in CDMA.</li>
         </ol>
        </p>
        <p>
          This API has been designed so that conference calls could be
          controlled using the same type object as with a single telephony call.
        </p>
        <p>
          Every conference call has a <dfn>conference id</dfn> that uniquely
          identifies a <a>conference call</a> in the system.
        </p>
      </section><!-- Conference calls -->
    </section> <!-- Terminology -->
    <!-- - - - - - - - - - - - - - Use cases  - - - - - - - - - - - - - - - -->
    <section class="informative"> <h2>Use cases</h2>
      <section> <h3>User interaction scenarios</h3>
      <p>
        This API has been designed to facilitate typical telephony interaction
        scenarios, such as:
        <ol>
          <li>incoming call dialog</li>
          <li>ongoing call dialog</li>
          <li>dialing emergency numbers in PIN code dialog</li>
          <li>typing MMI commands in dialer</li>
          <li>sending DTMF tones in dialer</li>
          <li>support <a>telephony service</a> (subscriber identity) selection
            for dual-SIM and multi-SIM phones. Note that dual-SIM allows both
            services being active (i.e. receive and dial calls), whereas
            multi-SIM allows only one active service at a time.
          </li>
        </ol>
      </p>
      </section>
      <section> <h3>Technical use cases</h3>
      <p>
        The technical use cases requiring elevated permissions are the
        following:
        <ul>
         <li>Call management
          <ol>
          <li>make a call to a remote party and subscribe to notifications about
            the state changes of the call</li>
          <!--li>when making a call, if multiple subscriber identities are
            configured, optionally choose which identity should be used for a
            dialed call, otherwise a default identity is used</li-->
          <li>when making a call, optionally hide the caller identity, if the
            <a>telephony service</a> supports it </li>
          <li>list the telephony calls in progress</li>
          <li>retrieve the active call(s), if any</li>
          <li>receive phone calls and subscribe to notifications about incoming
            calls and their state changes</li>
          <li>handle waiting calls, when the service is available and enabled
            </li>
          <li>put the active call(s) on hold, or swap the active and held calls
          </li>
          <li>resume the held call(s) or swap the active and held calls</li>
          <li>create phone conference, when the device and
            <a>telephony service</a> supports it</li>
          <li>(GSM) deflect an incoming or waiting call to be handled by another
            remote party, when the <a>telephony service</a> supports it</li>
          <li>(GSM) transfer an ongoing call with a remote party to become a
            call between the remote party and a third party, if the
            <a>telephony service</a> supports it</li>
          <li>provide sufficient instrumentation that applications could handle
            user interaction differences for different telephony protocols
            (such as CDMA 3-way calling vs. GSM multiparty calls</li>
          <li>(GSM) create a multiparty (conference) call</li>
          <li>(GSM) split a participant from a conference call for private
            conversation</li>
          <li>(GSM) hang up a conference call participant</li>
          <li>(GSM) hang up the conference call
          <li>(GSM) list the participants in a conference call</li>
          <li>(CDMA) create a 3-way call</li>
          <li>(CDMA) hang up the last participant call off the 3-way call</li>
          <li>(CDMA) hang up the 3-way call</li>.
          </ol>
         </li>
         <li>Tone management
          <ol>
          <li>send DTMF tones to the telephony network, and optionally set
          DTMF mark and space parameters.</li>
          <li>start a DTMF tone</li>
          <li>stop a DTMF tone</li>
          </ol>
         </li>
         <li>Emergency calls
          <ol>
          <li>dial an emergency call, even without having a SIM card, if it is
            technically possible (e.g. there is a telephony modem or service to
            support it)</li>
          <li>list the usable emergency numbers for a given
            <a>telephony service</a>, if supported by the device and the
            telephony network</li>
          <li>subscribe to notification when the list of emergency numbers
            changes</li>
          </ol>
         </li>
         <li>Telephony service management
          <ol>
          <li>select a <a>telephony service</a> to be used with the API methods
          </li>
          <li>list the available <a>telephony service</a>s</li>
          <li>subscribe to notifications about the activation of new telephony
            services in the system</li>
          <li>subscribe to notifications about the removal of telehony services
            in the system</li>
          <li>subscribe to notifications about the changes of telehony services
            in the system</li>
          </ol>
         </li>
        </ul>
      </p>
      </section>
      <section> <h3>Omitted use cases</h3>
        <p>
          Further telephony use cases which are currently <b>not</b> explicitly
          handled by this version of the API, but may be supported in
          the future:
          <ol>
          <li>set the default sound volume for telephony</li>
          <li>set the sound volume during a call</li>
          <li>mute and unmute the microphone for a call</li>
          <li>start the system dialer with a phone URI</li>
          <li>select between audio targets (speaker, headsets, etc)</li>
          <li>see and manage call capabilities during a call, such as is
            conference call possible, is video call possible, etc </li>
          <li>support network services, such as call forwarding, call
            barring, network selection mode, call counters, etc.</li>
          <li>Man-Machine Interface (MMI) Code Support
           Global Certification Forum compliancy requires support for MMI codes
           by dialer applications. Hence dialers need to handle multiple types
           of input, which can be dialed numbers, MMI codes, PIN codes and other
           input, all handled by different telephony services, e.g. MMI codes
           are handled by Supplementary Services in GSM. The API may provide
           in the future pre-validating and parsing user input in order to
           determine whether does it match a MMI code sendable to
           Supplementary Services
           (otherwise all applications would need to parse all MMI codes
           themselves). Codes not matched by the implementation need to be
           handled by the applications using this API.
          </li>
          </ol>
        </p>
      </section>
    </section> <!-- Terminology -->
    <!-- - - - - - - - - - - Extended interface Navigator - - - - - - - - - -->
    <section> <h2>Extension to the <code>Navigator</code> object</h2>
      <p>
        The <a>TelephonyManager</a> interface is exposed on [[!HTML]]'s
     <a href="http://www.whatwg.org/specs/web-apps/current-work/#dom-navigator">
        <code>Navigator</code></a> object.
      </p>
      <dl title="partial interface Navigator" class="idl">
        <dt>
          readonly attribute TelephonyManager telephony
        </dt>
      </dl>
      <!-- - - - - - - - - - - - telephony attribute  - - - - - - - - - - - -->
      <section> <h3>The <code>telephony</code> attribute</h3>
      <p>
        When getting the <dfn id="widl-Navigator-telephony">telephony</dfn>
        attribute, the user agent MUST return the <a>TelephonyManager</a>
        object, which provides telephony related functionality.
      </p>
      </section> <!-- telephony attribute -->
    </section> <!-- Navigator -->
    <!-- - - - - - - - - - - - Interface TelephonyManager - - - - - - - - - -->
    <section> <h2>The <a>TelephonyManager</a> Interface</h2>
      <p>
        The <dfn>TelephonyManager</dfn> interface provides access to telephony
        functionality related to <a>telephony call</a> management,
        sending [[!DTMF]] tones, and handling emergency numbers and calls.
      </p>
      <dl title="TelephonyManager implements CallManager" class="idl"></dl>
      <dl title="TelephonyManager implements ToneManager" class="idl"></dl>
      <dl title="TelephonyManager implements EmergencyManager" class="idl"></dl>
      <dl title="interface TelephonyManager" class="idl">
        <dt>readonly attribute ServiceManager? service</dt>
      </dl>
      <p>The <code>service</code> property MUST return the
      <code><a>ServiceManager</a></code> object exposing functionality
       concerning <a>telephony service</a>s, or <code>null</code> if not
       supported.
      </p>
      <p>The rest of <code><a>TelephonyManager</a></code> properties are
        described by the <code><a>CallManager</a></code>,
        <code><a>ToneManager</a></code> and
        <code><a>EmergencyManager</a></code> interfaces.
      </p>
    </section> <!-- TelephonyManager -->

    <!-- - - - - - - - - - - - - - Telephony Calls  - - - - - - - - - - - -->
    <section> <h2>Telephony Calls</h2>
    <!-- - - - - - - - - - - - - - Call states  - - - - - - - - - - - - - - -
    ======= A short introducton on call state management for editors ========
    _________________________________________________________________________
    CDMA states for dialed calls       | Mapping to the API or [modem] state
    _________________________________________________________________________
        [ DIAL button pressed ]        | dialing
        -> channel request             |
        <- immediate assignment        |
        -> service request             |
        <- authentication request      |
        -> authentication response     |
        <- cyphering command           |
        -> cyphering complete          |
        -> setup                       |
        <- call confirmed              |
        <- assignment command          |
        -> assignment completed        |
        <- alerting                    | alerting
        <- connect                     |
        -> connect ack                 | active (connected)
        <-> dataspeech                 |
    _________________________________________________________________________
    CDMA states for received calls     | Mapping to the API or [modem] state
    _________________________________________________________________________
        <- paging request              |
        -> channel request             |
        <- immediate assignment        |
        -> paging response             |
        <- authentication request      |
        -> authentication response,    |
        <- cyphering command           |
        -> cyphering complete          |
        <- call setup                  |
        -> call confirmed              | incoming
        <- assignment command          |
        -> assignment complete         |
        -> call alerting               | [ringing]
        [ OK button pressed ]          | accepted
        -> connect                     |
        <- connect ack                 | active (connected)
        <-> dataspeech                 |
    _________________________________________________________________________
    GSM states for dialed calls        | Mapping to the API or [modem] state
    _________________________________________________________________________
        [ DIAL button pressed ]        | dialing
        -> channel request             |
        <- immediate assignment        |
        -> service request             |
        -> connection request          |
        <- cyphering command           |
        -> cyphering complete          |
        -> call setup                  |
        <- connecting                  | connecting
        [call mode: signaling -> voice]|
        [routing, voicemail, errors]   |
        <- call confirmed              |
        <- alerting                    | alerting
        <- connect                     |
        -> connect ack                 | active (connected)
        <-> dataspeech                 |
    _________________________________________________________________________
    GSM states for received calls      | Mapping to the API or [modem] state
    _________________________________________________________________________
        <- interrogation procedure     |
        <- paging request              |
        -> channel request             |
        <- immediate assignment        |
        -> paging response             |
        - cyphering                    |
        <- call setup                  | incoming
        -> call confirmed              |
        -> call alerting               | [ringing]
        [ OK button pressed ]          | accepted
        -> connect                     |
        <- connect ack                 | active (connected)
        <-> dataspeech                 |
    _________________________________________________________________________
    SIP/IMS states for dialed calls | Mapping to the API or [SIP stack] state
    _________________________________________________________________________
        [ DIAL button pressed ]        | dialing
        -> SIP Invite                  | [initializing]
        <- SIP 183 Session Progress    |
        [ SDP ]                        |
        -> PRACK                       | [initialized]
        [Caller PDP Context activation]|
        <- SIP 200 OK                  |
        -> UPDATE [ context ]          |
        <- SIP 200 OK                  |
        [ remote starts ringing ]      |
        <- SIP 180 RINGING             | alerting
        -> PRACK                       |
        [ remote accepts]              |
        <- SIP 200 OK                  |
        -> ACK                         | active (connected)
        <-> dataspeech                 |
    _________________________________________________________________________
    SIP states for received calls  | Mapping to the API or [SIP stack] state
    _________________________________________________________________________
        <- SIP Invite                  | incoming
        -> SIP 183 Session Progress    | [initializing]
        [ SDP ]                        |
        <- PRACK                       |
        -> SIP 200 OK                  | [initialized]
        [ PDP Context activation]      |
        <- UPDATE [ context ]          |
        -> SIP 200 OK                  |
        [ locally ringing ]            |
        -> SIP 180 RINGING             | [ringing]
        <- PRACK                       |
        [ accepts ]                    | accepted
        -> SIP 200 OK                  |
        <- ACK                         | active (connected)
        <-> dataspeech                 |
    _________________________________________________________________________
    XMPP states for dialed calls   | Mapping to the API or [XMPP stack] state
    [ XMPP XEP-0166 Jingle ]       | (may depend on XMPP implementation)
    _________________________________________________________________________
        DIAL button pressed            | dialing
        -> session-initiate            |
        <- ack                         |
        <- session-accept              | alerting
        -> ack                         | active (connected)
        <-> media session              |
        <- session-terminate           |
        -> ack                         | disconnected
    _________________________________________________________________________
    XMPP states for received calls | Mapping to the API or [XMPP stack] state
    [ XMPP XEP-0166 Jingle ]       | (may depend on XMPP implementation)
    _________________________________________________________________________
        <- session-initiate            | incoming
        -> ack                         |
        [ locally ringing ]            | [ringing]
        [ user accepts ]               | accepted
        -> session-accept              |
        <- ack                         | active (connected)
        <-> media session              |
        -> session-terminate           | disconnecting
        <- ack                         | disconnected
    _________________________________________________________________________

    ## Multiparty call sequences and states

    * GSM TS 24.084.
        "There are four auxiliary states associated with the MPTY service:
        - Idle;
        - MPTY request; A request has been made to add this call to the MPTY.
        - Call in MPTY; This call is in the MPTY.
        - Split request; A request has been made to remove this call from the
        MPTY.
        These Auxiliary states apply in addition to the GSM 04.08 call control
        states and the GSM 04.83 call hold states. Thus for example, an active
        call in a held MPTY has the state (Active, Call held, Call in MPTY).
        Not all states are allowed, for example an MPTY cannot be split while
        it is held, so (Active, Call held, Split request) is forbidden."

        Instead of this, we offer a model when states describe valid
        multiparty states. Valid state transitions for a multiparty call are:
        * joining -> active
        * active -> holding -> held
        * held -> resuming -> active (connected)
        * any state -> [disconnecting]-> disconnected

     * Creating GSM multiparty calls:
       - dial first number, then put on hold
       - dial second number, then press 'Multiparty' button


     * CDMA 3-way calling is mapped to multiple presses of the 'call' button:
       - dial the first number
       - when call active, press 'call' to put the first call on hold
       - dial the second number
       - when second call is active, press 'call' button to make 3-way call
       - while 3-way call active, press 'call' button to disconnect the
         second call
       - while 3-way call active, any incoming call should be rejected
       - while 3-way call active, pressing 'hangup' will hangup all calls.

     * The common way to handle by the API:
       - dial first call
       - hold first call
       - dial second call
       - create the conference call from the held and active calls
       - disconnecting the second call is OK from both CDMA and GSM
       - disconnecting the first call is OK in GSM, but will hang up all calls
         in CDMA
       - in GSM, any participating call can be split from the conference call
         for private chat, during which the conference call is on hold
       - during private chat, it is possible to re-merge the call into the
         conference
       - disconnecting a GSM conference call will disconnect all member calls.

    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   -->
    <section> <h3><a><code>CallState</code></a> enum</h3>
      <p>
        Within the API, the <a>call state</a>s are represented by the
        <code><a>CallState</a></code> enum.
      </p>
      <dl title="enum CallState" class="idl">
        <dt><a>dialing</a></dt>
        <dt><a>connecting</a></dt>
        <dt><a>alerting</a></dt>
        <dt><a>ringing</a></dt>
        <dt><a>active</a></dt>
        <dt><a>conference</a></dt>
        <dt><a>incoming</a></dt>
        <dt><a>waiting</a></dt>
        <dt><a>accepted</a></dt>
        <dt><a>held</a></dt>
        <dt><a>disconnected</a></dt>
        <dt><a>holding</a></dt>
        <dt><a>resuming</a></dt>
        <dt><a>redirecting</a></dt>
        <dt><a>transferring</a></dt>
        <dt><a>disconnecting</a></dt>
      </dl>
      <p>
        The meaning of the call states referenced in this API is the
        following:
      </p>
      <dl>
        <dt><dfn>dialing</dfn></dt>
        <dd>An outbound call is being dialed by a telephony service.</dd>

        <dt><dfn>connecting</dfn></dt>
        <dd>A request to establish the outbound call has been made and it is
          progressing. This state is skipped for CDMA calls.
          In this API it is also used as an initial state for
          <a><code>TelephonyCall</code></a> objects controlling
          <a>conference call</a>s, when created.
        </dd>

        <dt><dfn>alerting</dfn></dt>
        <dd>The destination number has been reached and alerting is taking
          place in an <a>outbound call</a>.
        </dd>

        <dt><dfn>ringing</dfn></dt>
        <dd>An <a>inbound call</a> is locally alerting (by beep, vibration
          pattern, ringing, or by other means), and the network can notify
          the remote party with the <a><code>alerting</code></a> state.
        </dd>

        <dt><dfn>active</dfn></dt>
        <dd>The call is connected and media channels are attached.</dd>

        <dt><dfn>conference</dfn></dt>
        <dd>The call is active, i.e. connected and media channels are attached,
          as part of a conference call.</dd>

        <dt><dfn>incoming</dfn></dt>
        <dd>An incoming call is being received whilst no other call is
          progressing.
        </dd>

        <dt><dfn>waiting</dfn></dt>
        <dd>An incoming call that has been received whilst there was another
          call progressing, and the call waiting service is active.
        </dd>

        <dt><dfn>accepted</dfn></dt>
        <dd>An incoming call has been accepted by the remote party and is
          being connected.</dd>

        <dt><dfn>held</dfn></dt>
        <dd>The call has been put on hold by the network.</dd>

        <dt><dfn>disconnected</dfn></dt>
        <dd>The call has been disconnected by the network and this object
          is invalid for call control.
        </dd>
        <dt><dfn>holding</dfn></dt>
        <dd>The call is being put on hold.</dd>
        <dt><dfn>resuming</dfn></dt>
        <dd>The call, which was on hold, is being resumed.</dd>
        <dt><dfn>redirecting</dfn></dt>
        <dd>The call is being redirected (deflected) to another remote
          party.
        </dd>
        <dt><dfn>transferring</dfn></dt>
        <dd>The call is being transferred to another remote party.</dd>
        <dt><dfn>disconnecting</dfn></dt>
        <dd>A request to disconnect the call has been made and it is
          progressing.
        </dd>
        <dt><dfn>splitting</dfn></dt>
        <dd>The call is being split from a multiparty call.</dd>
      </dl>
    </section><!-- Call state -->

    <!-- - - - - - - - - - - Call state reason  - - - - - - - - - - - - - -->
    <section> <h2>Call state reason</h2>
      <p>
        The call state reason is used primarily for the
        <a><code>disconnected</code></a> state, known as the
        <dfn>disconnect reason</dfn>.
        In this API the disconnection reasons are represented by
        the <code><a>DisconnectReason</a></code> enum.
      </p>
      <!-- - - - - - - - - - -  DisconnectReason Enum - - - - - - - - - -->
      <section> <h3><code><a>DisconnectReason</a></code> enum</h3>
        <dl title="enum DisconnectReason" class="idl">
          <dt>local</dt>
          <dt>remote</dt>
          <dt>network</dt>
          <dt>busy</dt>
          <dt>rejected</dt>
          <dt>redirected</dt>
          <dt>unreachable</dt>
          <dt>no-answer</dt>
          <dt>network-unreachable</dt>
          <dt>barred</dt>
          <dt>no-service</dt>
          <dt>invalid-number</dt>
        </dl>
        <p>
          The meaning of the disconnect reasons in this API is the following:
        </p>
        <dl>
          <dt><dfn id="disconnect-local">local</dfn></dt>
          <dd>The call was disconnected by the user, or the device, and no
            more specific reason is known.
          </dd>

          <dt><dfn id="disconnect-remote">remote</dfn></dt>
          <dd>The call was disconnected by the remote party, and no more
            specific reason is known.
          </dd>

          <dt><dfn id="disconnect-network">network</dfn></dt>
          <dd>The call was disconnected by the network, and no more specific
            reason is known.
          </dd>

          <dt><dfn id="disconnect-busy">busy</dfn></dt>
          <dd>The call was disconnected by the network, because the remote
            party was busy.
          </dd>

          <dt><dfn id="disconnect-rejected">rejected</dfn></dt>
          <dd>The call was disconnected because the remote party rejected the
            call.
          </dd>

          <dt><dfn id="disconnect-redirected">redirected</dfn></dt>
          <dd>The call has been redirected to another subscriber.</dd>

          <dt><dfn id="disconnect-unreachable">unreachable</dfn></dt>
          <dd>The call was disconnected by the network, because the remote
            party was unreachable by the network.
          </dd>

          <dt><dfn id="disconnect-no-answer">no-answer</dfn></dt>
          <dd>The call was disconnected by the network, because the remote
            party has not answered and the call has timed out.
          </dd>

          <dt>
            <dfn id="disconnect-network-unreachable">network-unreachable</dfn>
          </dt>
          <dd>The call was disconnected because the network was unreachable.
          </dd>

          <dt><dfn id="disconnect-barred">barred</dfn></dt>
          <dd>The call was disconnected because it was barred.</dd>

          <dt><dfn id="disconnect-no-service">no-service</dfn></dt>
          <dd>The call was not made because there is no telephony service set
            up and enabled (e.g. no SIM card).
          </dd>

          <dt><dfn id="disconnect-invalid-number">invalid-number</dfn></dt>
          <dd>The call was disconnected by the network, because the remote
            party identifier was invalid.
          </dd>
        </dl>
      </section><!-- DisconnectReason Enum -->
    </section><!-- Disconnect reason -->

    <section> <h3>Call state transitions</h3>
    <p>
      Since call state transitions depend on protocol, network equipment,
      modem, etc., the implementation SHOULD always re-synchronize any
      eventual internal states to the current call state reported by the
      telephony system. The implementation SHOULD NOT set the call state to
      any other value than specified in the descriptions of the methods
      of this interface.
    </p>
    <p class="note">
      Since <a title="call state">call states</a> can have slightly
      different semantics depending on the telephony protocol, the
      <code>protocol</code> property of <a><code>TelephonyCall</code></a>
      can be used for interpreting the call state in the implementation.
      See <a href="https://github.com/sysapps/telephony/issues/125">issue
      125</a>.
    </p>
    <!-- - - - - - - - - - - - - - Receiving calls  - - - - - - - - - - - -->
    <section> <h3>Inbound call state transitions</h3>
      <p>
        The device can receive phone calls from any active telephony service,
        even simultaneously, in which case the user agent arbitrates the
        calls either by a policy, or by the user by choosing which call to
        accept.
      </p>
      <p>
        For call setup on received calls, the following call states SHOULD be
        supported in this order:
      </p>
      <ol>
        <li>"<a>incoming</a>" or "<a>waiting</a>"</li>
        <li>"<a>accepted</a>"</li>
        <li>"<a>active</a>".</li>
      </ol>
      <p class="note">
        On received calls, telephony protocols use the
        <code>"<a>ringing</a>"</code> state, set by the mobile terminal when
        local call alerting starts, in order to notify the remote party about
        the ongoing alerting (ringing can actually be e.g. a beep, ring tone,
        or vibration pattern). If the modem expects this state to be set,
        implementations SHOULD make sure to set it.
      </p>
      <p class='note'>
        CDMA cannot report all these states in the expected sequence. The
        ‘connected’ network state (i.e. when the mobile station send the
        Service Connect Completion Message or Connect Order, depending on
        whether the call is mobile originated or terminated) is immediately
        followed by voice media transmission – there is no transition to
        ‘active’ before the media arrives. Therefore it should be up to the
        implementation to determine which events to fire and in which order.
        Dialer applications need to be prepared to handle such cases.
      </p>
      <figure>
        <img src="images/inbound_call_state_diagram.gif" alt="">
        <figcaption>
          The figure depicts the most usual state transitions for received
          calls.
        </figcaption>
      </figure>
    </section><!-- Inbound states -->

    <!-- - - - - - - - - -  Making calls (outbound states)  - - - - - - - -->
    <section> <h3>Outbound call state transitions</h3>
      <!--div class="issue">
        <p>
          The following needs to be redefined algorithmically in terms of the
          telephony service.
        </p>
        <p>
          To <dfn>make a call</dfn> with a
          <a><var>remote party id</var></a>, optionally a
          <var>telephony service</var>, and optionally a
          <var>hide caller id</var>, the user agent MUST ...
        </p>
      </div-->
      <p>
        For making a call, the <a>telephony service</a> transitions through
        the following states in order. Errors can occur at each state, which
        are handled by the <a>telephony network</a>, and may result in the call
        becoming <a>disconnected</a>:
      </p>
      <ol>
        <li><code><a>dialing</a></code></li>
        <li>[<code><a>connecting</a></code>]</li>
        <li><code><a>alerting</a></code></li>
        <li><code><a>active</a></code></li>
      </ol>
      <p class="note">
        On the telephony services which support the <code>'connecting'</code>
        call state (e.g. GSM and CDMA, for call routing, forwarding, voicemail
        handling etc), implementations SHOULD support this state too.
      </p>
      <figure>
        <img src="images/outbound_call_state_diagram.gif" alt="">
        <figcaption>
          The figure depicts the most usual state transitions for dialed
          calls.
        </figcaption>
      </figure>
    </section><!-- Making calls (Outbound states) -->

    <!-- - - - - - - - - Conference calls states  - - - - - - - - - - - - -->
    <section> <h3>Conference call state transitions</h3>
      <p>
        Valid state transitions for a conference call are:
        <ul>
          <li>from <code>'<a>connecting</a>'</code> to
            <code>'<a>active</a>'</code></li>
          <li>from <code>'<a>active</a>'</code> to
            <code>'<a>holding</a>'</code> to <code>'<a>held</a>'</code></li>
          <li>from <code>'<a>held</a>'</code> to <code>'<a>resuming</a>'</code>
            to <code>'<a>active</a>'</code></li>
          <li>from any state to <code>'<a>disconnected</a>'</code>.</li>
        </ul>
        In addition, <code>Promise</code> objects are used for tracking the
        protocol transactions (e.g. GSM multiparty states), resolving either to
        success or error.
      </p>
    </section>
    </section><!-- <h3>State transitions-- >

    <!-- - - - - - - - - - - -  Interface TelephonyCall - - - - - - - - - - -->
    <section> <h2><a><code>TelephonyCall</code></a> Interface</h2>
      <p>
        Defines the object structure for controlling calls, including
        <a>conference call</a>s.
      </p>
      <dl title="interface TelephonyCall" class="idl">
        <dt>readonly attribute DOMString? callId      </dt>
        <dt>readonly attribute DOMString? conferenceId</dt>
        <dt>readonly attribute DOMString? remoteParty </dt>
        <dt>readonly attribute DOMString serviceId    </dt>
        <dt>readonly attribute CallState state        </dt>
        <dt>readonly attribute DOMString stateReason  </dt>
        <dt>Promise accept()                          </dt>
        <dt>Promise hold()                            </dt>
        <dt>Promise resume()                          </dt>
        <dt>Promise disconnect()                      </dt>
        <dt>Promise deflect(DOMString remoteParty)    </dt>
        <dt>Promise transfer(TelephonyCall call)      </dt>
        <dt>Promise split()                           </dt>
      </dl>

      <p class="note">In the methods implementation the user agent MAY choose
      to make an early validation of preconditions and parameters, or defer
      those checks to the underlying telephony system.</p>

      <!-- - - - - - - - - - - - callId attribute - - - - - - - - - - - - - -->
      <section> <h3>The <code>callId</code> attribute</h3>
        <p>
          When getting the <dfn id="widl-TelephonyCall-callId">callId</dfn>
          attribute, the user agent MUST return the unique <a>call id</a>.
          After construction, the value MUST be <code>null</code>.
          The implementation MUST assign a non-null value when the
          <code>state</code> property is assigned a value different from
          <code>'initializing'</code>.
        </p>
      </section><!-- callId attribute -->

      <!-- - - - - - - - - - - - conferenceId attribute - - - - - - - - - - -->
      <section> <h3>The <code>conferenceId</code> attribute</h3>
        <p>
          When getting the
          <dfn id="widl-TelephonyCall-conferenceId">conferenceId</dfn>
          attribute, the user agent MUST return the value of the
          <code>callId</code> attribute of the <a>conference call</a>
          to which this call is part of, or <code>null</code> if it is not
          part of any <a>conference call</a>. If the <code>callId</code> and
          the <code>conferenceId</code> values are equal and not
          <code>null</code>, then the  <code>TelephonyCall</code> object is
          controlling a conference call.
        </p>
      </section>

      <!-- - - - - - - - - - - - remoteParty attribute  - - - - - - - - - - -->
      <section> <h3>The <code>remoteParty</code> attribute</h3>
        <p>
          When getting the
          <dfn id="widl-TelephonyCall-remoteParty">remoteParty</dfn> attribute,
          the user agent MUST return the <a>remote party id</a> (e.g. telephone
          number) of the call participant. If not available (e.g. callerId has
          been hidden), return <code>null</code>.
        </p>
      </section>

      <!-- - - - - - - - - - - -  serviceId attribute - - - - - - - - - - - -->
      <section> <h3>The <code>serviceId</code> attribute</h3>
        <p>
          When getting the
          <dfn id="widl-TelephonyCall-serviceId">serviceId</dfn>
          attribute, the user agent MUST return the <a>telephony service id</a>
          of the <a>telephony service</a> associated with this call.
        </p>
      </section><!-- serviceId attribute -->

      <!-- - - - - - - - - - - -  state attribute - - - - - - - - - - - - - -->
      <section> <h3>The <code>state</code> attribute</h3>
        <p>
          When getting the <dfn id="widl-TelephonyCall-state">state</dfn>
          attribute, the user agent MUST return the <a>CallState</a> value that
          represents the state of for the <a>telephony call</a>.
        </p>
      </section><!-- state attribute -->

      <!-- - - - - - - - - - - -  stateReason attribute - - - - - - - - - - -->
      <section> <h3>The <code>stateReason</code> attribute</h3>
        <p>
          When getting the <dfn id="widl-TelephonyCall-stateReason">
          stateReason</dfn> attribute, the user agent MUST return:
          <ul>
            <li>the <a>DisconnectReason</a> value if the call <code>state</code>
              is <code>"<a>disconnected</a>"</code>",</li>
            <li>the value <code>"inbound"</code> for calls that started with
              the <code>"<a>incoming</a>"</code> or <code>"<a>waiting</a>"
              </code> state</li>
            <li>the value <code>"outbound"</code> for calls that started with
              the <code>"<a>dialing</a>"</code> state.</li>
          </ul>
        </p>
      </section><!-- stateReason attribute -->

      <!-- - - - - - - - - - - - accept() method  - - - - - - - - - - - - - -->
      <section> <h3>The <code>accept()</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-accept-void">accept()</dfn> method
          accepts an incoming or waiting <a>telephony call</a>. When invoked,
          the user agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If the value of the <code>state</code> property is not equal to
            <a><code>incoming</code></a> or <a><code>waiting</code></a>, then
            optionally call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Save the <code>state</code> of the call</li>
          <li>Make a request to the telephony system to accept the call.</li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then reset the <code>state</code> of the
            call to the call state on the modem. Then,
            call <var>resolver</var>'s <code>reject(value)</code> method with
            the <var>value</var> argument set to a new <code>DOMError</code>
            object whose name is set to
            <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then set <code>state</code> to
            <a><code>accepted</code></a>, execute the
            <a href="#steps-call-statechange-event">state change steps</a> and
            <a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- accept() method -->

      <!-- - - - - - - - - - - -  hold() method - - - - - - - - - - - - - -->
      <section> <h3>The <code>hold()</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-hold-void">hold()</dfn> method
          requests the telephony system put the call on hold. When
          invoked, the user agent MUST run the following <dfn>hold steps</dfn>:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If the value of the <code>state</code> property is not equal to
            <a><code>active</code></a>, then optionally call
            <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Set the <code>state</code> of the call to <code>holding</code>
          </li>
          <li>Make a request to the telephony system to put the call on hold.
          </li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then reset the <code>state</code> of the
            call to the call state on the modem. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then set <code>state</code> to
            <a><code>held</code></a>, execute the
            <a href="#steps-call-statechange-event">state change steps</a> and
            <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section> <!-- hold() method -->

      <!-- - - - - - - - - - - -  resume() method - - - - - - - - - - - - -->
      <section> <h3>The <code>resume()</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-resume-void">resume()</dfn> method
          requests the telephony system to resume resume a held call.
          When invoked, the user agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If <code>state</code> is not equal to <a><code>held</code></a>,
            optionally call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Set the <code>state</code> of the call to
            <a><code>resuming</code></a>
          </li>
          <li>Make a request to the telephony system to resume the call.</li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then reset the <code>state</code> of the
            call to the call state on the modem.
            Then call <var>resolver</var>'s <code>reject(value)</code> method
            with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then set <code>state</code> to
            <a><code>active</code></a>, execute the
            <a href="#steps-call-statechange-event">state change steps</a> and
            <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- resume() method -->

      <!-- - - - - - - - - - - -  disconnect() method - - - - - - - - - - - -->
      <section> <h3>The <code>disconnect</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-disconnect-void">disconnect</dfn>
          method, if invoked on a <a><code>TelephonyCall</code></a> which is not
          controlling a <a>conference call</a> (i.e. its <code>callId</code> is
          different from its <code>conferenceId</code>), it initiates releasing
          of the telephony call. If the call is controlling a conference call,
          then initiates releasing the conference call, including each
          participating <a><code>TelephonyCall</code></a> object.
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Set the <code>state</code> of the call to
            <code>disconnecting</code>
          </li>
          <li>Make a request to the telephony system to disconnect the call</li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then reset the <code>state</code> of the
            call to the call state on the modem.
            Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, and terminate
            this algorithm.
          </li>
          <li>If the request is acknowledged, then execute the
            <a href="#steps-call-disconnected">call disconnected steps</a>, and
            <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
        <p class="note">
          Depending on the protocol, there may be restrictions on methods. For
          instance, GSM does not permit disconnecting a held call. Also,
          disconnecting a participant in a held GSM multiparty call is not
          supported. Also, if the controlling party disconnects a call
          participating in a IS-41 3-way call in CDMA which is not the last
          dialed call, then all parties are disconnected (other participants
          should choose to hang up).
        </p>
      </section><!-- disconnect() method -->

      <!-- - - - - - - - - - - - deflect() method - - - - - - - - - - - - - -->
      <section> <h3>The <code>deflect()</code> method</h3>
        <p class="note">
          The telephony service in use needs to have the call deflection
          feature enabled in order for this method to succeed. For instance, in
          GSM, the Call Deflection supplementary service needs to be active.
        </p>
        <p>
          The <dfn id=
          "widl-TelephonyCall-deflect-void-DOMString-remoteParty">redirect()</dfn>
          method initiates deflecting an incoming or waiting telephone call to
          a remote party. The method takes one argument, which represents the
          remote party to which the call is redirected. When invoked, the user
          agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If the <code>state</code> is not <a><code>incoming</code></a> or
            <a><code>waiting</code></a>, then optionally
            call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>if the method is not supported by the implementation, optionally
            call <var>resolver</var>'s <code>reject(value)</code> method with
            the <var>value</var> argument set to a new <code>DOMError</code>
            object whose name is set to <code>NotSupportedError</code>, and terminate these steps.</li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Make a request to the telephony system to redirect the
           call to the number indicated in the <var>remoteParty</var> parameter
          </li>
          <li>Set the <code>state</code> of the call to
            <a><code>redirecting</code></a>
          </li>
          <li>Wait for response from the telephony system</li>
          <li>If the request fails, then reset the <code>state</code> of the
            call to the call state on the modem.
            Then call <var>resolver</var>'s <code>reject(value)</code> method
            with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"NoModificationAllowedError"</code> or
            <code>"NotSupportedError"</code>, and terminate these steps.
          </li>
          <li>If the request is successful, then execute the
            <a href="#steps-call-disconnected">call disconnected steps</a> and
            <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- deflect() method -->

      <!-- - - - - - - - - - - - transfer() method  - - - - - - - - - - - - -->
      <section> <h3>The <code>transfer()</code> method</h3>
        <p class="note">
          The <a>telephony service</a> needs to have the call transfer feature
          enabled in order for this method to succeed. For instance, in GSM,
          the Call Transfer supplementary service needs to be active.
        </p>
        <p>
          The <dfn id=
          "widl-TelephonyCall-transfer-void-TelephonyCall-call">transfer()</dfn>
          method Initiates transferring the call to a new call between the
          remote party of this call and another remote party, then disconnects
          the call. The method needs the Explicit Call Transfer supplementary
          service to be active.The method takes one argument, which represents
          the held call whose remote party is connected with the remote party
          of this call (which MUST be the <a>active call</a>).
           When invoked, the user agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If <code>state</code> is not equal to <a><code>active</code></a>
            or if the <code>state</code> of the parameter '<var>call</var> is not
            equal to <a><code>held</code></a>, then optionally call
            <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is set to
            <code>"InvalidStateError"</code>, and terminate this algorithm.
          </li>
          <li>if the method is not supported by the implementation, optionally
            call <var>resolver</var>'s <code>reject(value)</code> method with
            the <var>value</var> argument set to a new <code>DOMError</code>
            object whose name is set to <code>NotSupportedError</code>, and terminate these steps.</li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Set the <code>state</code> of this call to
            <a><code>transferring</code></a>
          </li>
          <li>Make a request to the telephony system to transfer the
            call to the remote party indicated in the <var>call</var> parameter,
            and wait for response from the telephony system
          </li>
          <li>If the request fails, then reset the <code>state</code> of the
            call to the call state on the modem. Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>
            or <code>"NotSupportedError"</code> and terminate these steps.
          </li>
          <li>If the transfer request is successful, then execute the
            <a href="#steps-call-disconnected"> call disconnected steps</a>,
            and <a>queue a task</a> to invoke
            <var>resolver</var>'s <code>accept()</code> method.
          </li>
        </ol>
      </section><!-- transfer() method -->

      <!-- - - - - - - - - - - - split() method - - - - - - - - - - - - - - -->
      <section> <h3>The <code>split()</code> method</h3>
        <p>
          The <dfn id="widl-TelephonyCall-split-Promise">split()</dfn>
          method requests the telephony system to split the
          <a><code>TelephonyCall</code></a> object from the
          <a>conference call</a> it is participating, activate it and put the
          conference call on hold. When invoked, the
          user agent MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>If the <code>conferenceId</code> property is <code>null</code>,
            or does not match to a <a>conference call</a> in progress, then
            optionally
            set <code>conferenceId</code> to <code>null</code>,
            call <var>resolver</var>'s <code>reject(value)</code> method with
            the <var>value</var> argument set to a new <code>DOMError</code>
            object whose name is set to
            <code>"InvalidModificationError"</code>, and terminate this
            algorithm.
          </li>
          <li>if the method is not supported by the implementation, optionally
            call <var>resolver</var>'s <code>reject(value)</code> method with
            the <var>value</var> argument set to a new <code>DOMError</code>
            object whose name is set to <code>NotSupportedError</code>, and terminate these steps.</li>
          <li>let <var>confCall</var> be the <a><code>TelephonyCall</code></a>
            object controlling the <a>conference call</a>, whose
            <code>callId</code> and <code>conferenceId</code> property is equal
            to the <code>conferenceId</code> property.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Set the <code>state</code> of the <var>call</var> and
            set the state of <var>confCall</var> to
            <a></code>splitting</code></a>.
          </li>
          <li>Make a request to the telephony system to split the call
            participant from the conference call and wait the response from the
            telephony system.
          </li>
          <li>If the request fails, then reset the <code>state</code> of the
            call to the call state on the modem.
            Then call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var> argument
            set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code> or
            <code>NotSupportedError</code>, and terminate these steps.
          </li>
          <li>If the request was successful, reset the <code>conferenceId</code>
            of the split call to <code>null</code>.
            The telephony system has by now put the conference call on hold and
            activated the split call.
          </li>
          <li>Execute the
            <a href="#steps-call-statechange-event">state change steps</a> and
            <a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept()</code> method.
          </li>
        </ol>
        <p class='note'>
          In CDMA, only the last dialed call can be split off the 3-way call.
          For other call participants, calling this method MUST fail.
        </p>
      </section><!-- split() method -->
    </section><!-- TelephonyCall -->

    <!-- - - - - - - - - - - - - Interface CallManager  - - - - - - - - - - -->
    <section> <h2>The <a>CallManager</a> Interface</h2>
      <p>
        The <a>CallManager</a> interface provides access to telephony
        functionality related to given <a>telephony service</a>s, and manages
        the lifecycle of the <a><code>TelephonyCall</code></a> objects.
        A <a><code>TelephonyCall</code></a> object can be created in the
        following ways:
        <ul>
        <li>by the <code><a>dial</a>()</code> method, returned as a parameter
          to the <code>accept()</code> method of the returned
          <a><code>Promise</code></a> object, as explained in the
          <a href="#steps-dial">dialing steps</a>.
        <li>by the <code><a>createConference()</a></code> method, returned as a
          parameter to the <code>accept()</code> method of the returned
          <a><code>Promise</code></a> object, as explained in the
          <a href="#steps-createconference">conference creation steps</a>.
          The same object will be received as a property to the
          <code><a>TelephonyCallStateEvent</a></code> corresponding to the
          <code>'<a>connecting</a>'</code>' state.
        </li>
        <li>when the system notifies the <a>user agent</a> about an inbound
          call, the corresponding <a><code>TelephonyCall</code></a> object is
          created and passed as a property exposed in the
          <code><a>TelephonyCallStateEvent</a></code> event which is fired at
          the <a><code>CallManager</code></a> object
          <var>navigator.telephony</var>. This is explained at the
          <a href="#steps-call-incoming">inbound call steps</a>.
        </li>
        <li>received as a property to the
          <code><a>TelephonyCallStateEvent</a></code> event.
        </li>
        </ul>
      </p>
      <dl title="interface CallManager: EventTarget" class="idl">
        <dt>readonly attribute TelephonyCall? activeCall</dt>
        <dt>Promise getCalls()</dt>
        <dt>TelephonyCall? getCall(DOMString callId)</dt>
        <dt>Promise dial(DOMString remoteParty, DialOptions options)</dt>
        <dt>Promise createConference()</dt>
        <dt>Promise getParticipantCalls(DOMString conferenceId)</dt>
        <dt>attribute EventHandler oncallstatechange</dt>
        <dt>attribute EventHandler onactivecallchange</dt>
      </dl>
      <!-- - - - - - - - - - -  Event handlers  - - - - - - - - - - - - - - -->
      <section> <h2>Event handlers</h2>
        <p>
          The following are the event handlers implemented by the
          <code><a>CallManager</a></code> interface.
        </p>
        <table class="simple">
          <tr>
            <th>event handler</th>
            <th>event name   </th>
            <th>event type   </th>
            <th>description  </th>
          </tr>
          <tr>
            <td><dfn id="widl-CallManager-onactivecallchange">
              <code>onactivecallchange</code></dfn>
            </td>
            <td><dfn><code>activecallchange</code></dfn></td>
            <td><a>Event</a></td>
            <td>handles a change in the <a>active call</a></td>
          </tr>
          <tr>
            <td><dfn id="widl-CallManager-oncallstatechange">
              <code>oncallstatechange</code></dfn>
            </td>
            <td><dfn><code>statechange</code></dfn></td>
            <td><a>TelephonyCallStateEvent</a></td>
            <td>handles a change in a call state</td>
          </tr>
        </table>
        <!-- - - - - - - - Active call change event steps - - - - - - - - - -->
        <section> <h3>Handling the <code>activecallchange</code> event</h3>
        <p>
          When a telephony call becames the <a>active call</a>, the user agent
          MUST run the following steps:
        </p>
        <ol id="steps-CallManager-onactivechange">
          <li>Let <var>call</var> denote the <a><code>TelephonyCall</code></a>
          object which has become active.</li>
          <li>Change the value of the <code>activeCall</code> property of all
            instances of <a><code>CallManager</code></a>, to <var>call</var>.
          </li>
          <li><a>Queue a task</a> to <a>fire an event</a> named
            <code>activecallchange</code> at all the instances of
            <a><code>CallManager</code></a>.
          </li>
        </ol>
        </section>
        <!-- - - - - - - - Call state change steps  - - - - - - - - - - - - -->
        <section> <h3>Handling the <code>callstatechange</code> event</h3>
          <p>
            The <code>callstatechange</code> event is used for tracking
            <a><code>TelephonyCall</code></a> objects and based on the current
            state, applications decide how to change the user interface elements
            connected to method of this API in order to control the call.
          </p>
          <!-- - - - - - - - - - - - Interface TelephonyCallStateEvent  - - -->
          <section> <h3><a>TelephonyCallStateEvent</a> Interface</h3>
            <p>
              Defines telephony events for <a><code>TelephonyCall</code></a>
              state changes, including handling incoming and waiting calls, and
              conference call creation.
            </p>
            <dl title="interface TelephonyCallStateEvent : Event"
            class="idl">
              <dt>readonly attribute TelephonyCall call</dt>
            </dl>
            <!-- - - - - - - - - - - - call attribute - - - - - - - - - - -->
            <section> <h3>The <code>call</code> attribute</h3>
              <p>
                When getting the <code>call</code> attribute, the
                <a>user agent</a> MUST return the
                <code><a>TelephonyCall</a></code> object that triggered the
                event, on which the <code>state</code> property indicates the
                state which has triggered the event.
              </p>
            </section>
          <p>
            Whenever there is a change in the <code>state</code> attribute of a
            <a><code>TelephonyCall</code></a> object, the <a>user agent</a>
            MUST run the following steps:
          </p>
          <ol id="steps-call-statechange-event">
            <li>
              <a>Queue a task</a> to <a>fire an event</a> named
              <code>callstatechange</code> of type
              <a><code>TelephonyCallStateEvent</code></a>, to the
              <a><code>CallManager</code></a> object
              <var>navigator.telephony</var>.
            </li>
          </ol>
        </section><!-- interface TelephonyCallStateEvent -->
          <section> <h3>Handling inbound (incoming or waiting) calls</h3>
            <p>
              Upon a new incoming or waiting call the <a>user agent</a> MUST
              execute the following <dfn>onincoming steps</dfn>:
            </p>
            <ol id="steps-call-incoming">
            <li>Let <var>call</var> be a new instance of
            <a><code>TelephonyCall</code></a>.
            </li>
            <li>Set the <code>state</code> of <var>call</var>
              to <a><code>incoming</code></a> in case the underlying telephony
              system reports that state (which happens when there is no other call
              in <a><code>active</code></a> state),
            </li>
            <li>Or, set the <code>state</code> of <var>call</var> to
              <a><code>waiting</code></a>, in case the underlying telephony system
              reports that state (which happens if the call waiting service is
              active and there is already an <a>active call</a>),
            </li>
            <li>Otherwise, if there already is an <a>active call</a> and the call
              waiting service is not enabled, the telephony system will disconnect
              the call, the implementation MUST follow the resulting state change
              and terminate these steps.
            </li>
            <li>If the <code>state</code> of <var>call</var> has been set
              to either <a><code>incoming</code></a> or
              <a><code>waiting</code></a>, then add <var>call</var> to the
              list of calls managed by <a><code>CallManager</code></a>.
            </li>
            <li>
              <a>Queue a task</a> to <a>fire an event</a> named
              <code>callstatechange</code> of type
              <a><code>TelephonyCallStateEvent</code></a> to all instances of
              the <a><code>CallManager</code></a> object, with <var>call</var>
              passed as a property.
            </li>
            </ol>
          </section>
          <section> <h3>Handling call disconnection</h3>
            <p>
              When a telephony call <var>telCall</var> is disconnected, the
              user agent MUST run the following steps:
            </p>
            <ol id="steps-call-disconnected"> <a>Queue a task</a> to:
              <li>Remove the <var>telCall</var> object from all internal lists
                of <a><code>CallManager</code></a>
              </li>
              <li>set the <code>state</code> of <var>telCall</var> to
                "<a>disconnected</a>".
              </li>
              <li>
                fire a <a><code>TelephonyCallStateEvent</code></a>
                named <code>statechange</code> at all the
                <code><a>CallManager</a></code> objects,
                with the <code>call</code> property set to <var>call</var>,
                whose <code>stateReason</code> property is set to the
                <code><a>DisconnectReason</a></code>. At least the
                following values MUST be supported for the disconnect reason:
                "<a>local</a>", "<a>remote</a>" and "<a>network</a>".
                The rest of the <a>DisconnectReason</a> values SHOULD be
                supported.
              </li>
            </ol>
          </section>
        </section>
      </section><!-- event handers -->

      <!-- - - - - - - - - - - - -  activeCall attribute  - - - - - - - - - -->
      <section> <h3>The <code>activeCall</code> attribute</h3>
        <p>
          When getting the <dfn id=
          "widl-CallManager-activeCall">activeCall</dfn> attribute, the
          user agent MUST return the <a><code>TelephonyCall</code></a> object
          that represents the <a>active call</a>. If there is no active call,
          return <code>null</code>.
        </p>
      </section>

      <!-- - - - - - - - - - - - - getCalls() method  - - - - - - - - - - - -->
      <section> <h3>The <code>getCalls()</code> method</h3>
        <p>
          When the <code><dfn id=
          "widl-CallManager-getCalls-Promise">getCalls()</dfn></code> method is
          invoked, the
          <a>user agent</a> MUST return a <code>Promise</code> object, which in
          case of success resolves to an array, which can be empty, of all
          <a><code>TelephonyCall</code></a> objects in the system which have the
          value of the <code>state</code> property different from
          <code>'disconnected'</code>, i.e. all
          telephony calls in progress. <a><code>TelephonyCall</code></a> objects
          belonging to a conference call are also listed here.
          The applications SHOULD check the <code>conferenceId</code> property
          of each <code>TelephonyCall</code> object in order to determine
          whether the call is part of a conference call, and if yes, which is
          the controlling <code><a>TelephonyCall</a></code> object for the
          conference call.
        </p>
        <p>
          This method MUST get all calls from all enabled
          <a>telephony service</a>s, hence the <code>getServices()</code>
          method needs to be called first. If the client has not explicitly
          called it yet, it is the responsibility of
          the implementation to retrieve the available telephony services.
        </p>
      </section>

      <!-- - - - - - - - - - - - - getCall() method - - - - - - - - - - - - -->
      <!--section> <h3>The <code>getCall()</code> method</h3>
        <p>
          When the <code><dfn
          id="widl-CallManager-getCall-TelephonyCall-DOMString-callId">
          getCall(DOMString callId)</dfn></code> method is invoked, the
          <a>user agent</a> MUST return the unique <code>TelephonyCall</code>
          object whose <code>callId</code> property is equal with the parameter
          <var>callId</var>, or <code>null</code> if there is no match.
        </p>
      </section-->

      <!-- - - - - - - - - - - dial() method  - - - - - - - - - - - - - - - -->
      <section><h3>The <code>dial()</code> method</h3>
        <p>
          The <code><dfn id="widl-CallManager-dial-Promise-DOMString-remoteParty">
          dial</dfn>(remoteParty)</code> method initiates a new
          <a>telephony call</a> on the <a>selected telephony service</a>.
        </p>
        <p>
          When the <code>dial()</code> method is invoked, the user agent MUST
          run the following <dfn>dialing steps</dfn>:
        </p>
        <p class="note">
          Note that verification of the format of the <var>remoteParty</var>
          argument is left to the <a>telephony service</a>. Providing an
          <var>remoteParty</var> in the invalid format will generally result in
          the call disconnecting because the <a>telephony service</a> or
          telephony network will deem it an invalid number. However, the user
          agent SHOULD do a basic validation of the user input.
        </p>
        <ol id="steps-dial">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>If there is no <a>selected telephony service</a>, then the
            user agent SHOULD attempt retrieving the available
            <a>telephony service</a>s andset a <a>selected telephony service</a>, then continue these steps. If this fails, then
            call <var>resolver</var>'s <code>reject(value)</code> method with
            the <var>value</var> argument set to a new <code>DOMError</code>
            object whose name is set to <code>"NoModificationAllowedError"</code>, and terminate these steps.
          </li>
          <li>Optionally validate the value of the <code>remoteParty</code>
            property and if it is not valid, resolve <var>promise</var> with an
            <code>"InvalidCharacterError"</code> error, and terminate this
            algorithm.
          </li>
          <li>Make a request to the underlying telephony system to
            dial the call and wait for response from the underlying system.
          </li>
          <li>If it's not possible to fulfill the request for whatever reason:
            timeout, security, etc., then
            call <var>resolver</var>'s <code>reject(value)</code>
            method with the <var>value</var> argument set to a new
            <code>DOMError</code> object whose name is set to
            <code>"NoModificationAllowedError"</code>, and terminate this
            algorithm.
          </li>
          <li>Otherwise, if the request is successful, then set the value of the
            <code>state</code> property to <code>'<a>dialing</a>'</code>,
            execute the <a href="#steps-call-statechange-event">state change
            steps</a>, and <a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept(value)</code> method.
          </li>
        </ol>
      </section><!--dial() method-->

      <!-- - - - - - - - - createConference() method  - - - - - - - - - - - -->
      <section><h3>The <code>createConference()</code> method</h3>
        <p>
          When the <dfn id=
          "widl-CallManager-createConference-Promise">createConference()</dfn>
          method is invoked, the user agent MUST run the following steps:
        </p>
        <ol id="steps-createconference">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>If there is no <a>active call</a>, or no call in the
            <code>'<a>held</a>'</code> state, then optionally resolve
            <var>promise</var> with a <code>"NoModificationAllowedError"</code>
              error, and terminate this algorithm.
          </li>
          <li>Let <var>service</var> be the value of the <code>serviceId</code>
            property of the <a>active call</a>.
          </li>
          <li>Let <var>confCall</var> be a new instance of <a>TelephonyCall</a>
            with a unique <code>callId</code> property having the same value as
            the <code>conferenceId</code> property, and the value of the
            <code>serviceId</code> property set to <var>service</var>.
          </li>
          <li>Set the <code>state</code> of <var>confCall</var> to
             <code>'<a>connecting</a>'</code> and execute the
             <a href=#"steps-call-statechange-event">state change steps</a>.
          </li>
          <li>In the <a>telephony service</a> specified by the
            <code>serviceId</code> property of <var>service</var> make a request
            to the telephony system to create a conference call, and wait for
            the response. In GSM this will mean joining the active and held
            calls into a conference call.
            In CDMA, it means joining the <code>waiting</code> or
            <code>held</code> call with the <a>active call</a> into a 3-way
            call.
          </li>
          <li>If the request fails, call <var>resolver</var>'s
            <code>reject(value)</code> method with the <var>value</var>
            argument set to a new <code>DOMError</code> object whose name is
            set to <code>"NoModificationAllowedError"</code>, invalidate
            <var>confCall</var> and terminate this algorithm.
          </li>
          <li>If the request succeeds, add <var>confCall</var> to the list
            of managed calls of the <a><code>CallManager</code></a> object
            (<var>navigator.telephony</var>). In the same step, set the
            <code>conferenceId</code> attribute of all the
            participating calls to the <code>callId</code> of the
            conference call <var>confCall</var>, and their state to
            <a>conference</a>.
          </li>
          <li>Set the <code>state</code> of <var>confCall</var> to
             <code>'<a>active</a>'</code> and execute the
             <a href=#"steps-call-statechange-event">state change steps</a>, and
             the <a href=#"steps-CallManager-onactivechange">active call change
             </a> steps.
          </li>
          <li>Call <var>resolver</var>'s <code>accept(value)</code> method
            with the <var>value</var> argument set to <var>confCall</var>.
          </li>
        </ol>
      </section><!--createConference() method-->

      <!-- - - - - - - - getParticipantCalls() method - - - - - - - - - - - - - -->
      <section> <h3>The <code>getParticipantCalls()</code> method</h3>
        <p>
          When the <dfn
          id="widl-CallManager-getParticipantCalls-Promise-DOMString">
          getParticipantCalls()</dfn> method is invoked, the user agent MUST
          run the following steps:
          <ol>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Let <var>confId</var> be the parameter of type
            <code>DOMString</code> of this method.
          </li>
          <li>Let <var>confCall</var> be the <code><a>TelephonyCall</a></code>
            object with the <code>callId</code> property equal to
            <var>confId</var>. If there is no such object, then resolve
            <var>promise</var> with a <code>"NoModificationAllowedError"</code>
              error, and terminate this algorithm.
          </li>
          <li>Collect the list of <a><code>TelephonyCall</code></a> objects
            participating in the <a>conference call</a>, i.e. those
            whose <code>conferenceId</code> property is equal to
            <var>confId</var>.
          </li>
          <li><a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept(value)</code> method with <var>value</var> parameter
            set to the array containing the list of participant calls.
          </li>
          </ol>
        </p>
      </section>
    </section><!-- CallManager -->
    </section><!-- Telephony Calls -->

    <!-- - - - - - - - - - - -  Tone management - - - - - - - - - - - - - - -->
    <section> <h2>The <a>ToneManager</a> Interface</h2>
      <p>
        The <a>ToneManager</a> interface provides [[!DTMF]] related
        functionality, such as sending a series of tones, and starting and
        stopping a single tone.
      </p>
      <p>
        Tone value can be any of the following characters: 0-9, A-D, *, #.
      </p>
      <p class="issue">
        The above needs to be converted to ABNF
      </p>
      <dl title="interface ToneManager" class="idl">
        <dt>
          Promise sendTones(DOMString tones, optional ToneOptions options)
        </dt>
        <dt>
          Promise startTone(DOMString tone, optional ToneOptions options)
        </dt>
        <dt>
          Promise stopTone(optional DOMString serviceId)
        </dt>
      </dl>
      <!-- - - - - - - - - - - -  sendTones() - - - - - - - - - - - - - - -->
      <section> <h3>The <code>sendTones()</code> method</h3>
        <p>
          The <dfn id=
          "widl-ToneManager-sendTones-Promise">sendTones()</dfn> method
          requests a telephony service emit one or more [[!DTMF]] tones.
        </p>
        <!-- - - - - - - - - - - -  ToneOptions - - - - - - - - - - - - - -->
        <section> <h3><a>ToneOptions</a> Dictionary</h3>
          <dl title="dictionary ToneOptions" class="idl">
            <dt> unsigned long duration </dt>
            <dt> unsigned long gap      </dt>
          </dl>
          <section> <h3>The <code>duration</code> member</h3>
            <p>
              The <code>duration</code> member represents the duration (mark)
              in milliseconds of the [[!DTMF]] tones to be sent. The minimum
              value SHOULD be 70 ms.
            </p>
          </section>
          <section> <h3>The <code>gap</code> member</h3>
            <p>
              The <code>gap</code> member represents
              the duration in milliseconds of the time gap (space) before a
              [[!DTMF]] tone. The minimum value SHOULD be 30 ms.
            </p>
          </section>
        </section> <!-- ToneOptions -->
        <p>When the <code>sendTones()</code> method is invoked, the user agent
          MUST run the following steps:
        </p>
        <ol id="steps-sendtones">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated
            <a><code>resolver</code></a>.
          </li>
          <li>If there is no <a>selected telephony service</a>,then invoke
            <var>resolver</var>'s <code>reject(value)</code> method with the
            <var>value</var> argument set to a new <code>DOMError</code> object
            whose name is set to <code>"NoModificationAllowedError"</code>, and
            terminate these steps.
          </li>
          <li>Return <var>promise</var> to the caller and continue the
            following steps asynchronously.
          </li>
          <li>If the <a>ToneOptions</a> parameter specifies the tone
          <code>duration</code>, then validate and use that value, otherwise
          use a default value.
          </li>
          <li>If the <a>ToneOptions</a> parameter specifies the tone
          <code>gap</code>, then validate and use that value, otherwise use a
          default value.
          </li>
          <li>Request from the telephony system to send the specified tones.
          </li>
          <li>If the request to the telephony system is successful, or if the
            telephony system does not support feedback about the result of the
            request, invoke <var>resolver</var>'s <code>accept()</code> method
            with no arguments.
          </li>
          <li>If the request to the telephony system is unsuccessful, invoke
            <var>resolver</var>'s <code>reject()</code> method, with no
            arguments.
          </li>
        </ol>
        </section>

        <!-- - - - - - - - - - - -  startTone() - - - - - - - - - - - - - -->
        <section> <h3>The <code>startTone()</code> method</h3>
          <p>
            The <dfn id=
            "widl-ToneManager-startTone-Promise">startTone()</dfn> method
            starts emitting a [[!DTMF]] tone with the platform default or
            specified delay, in the platform default or the specified
            telephony service. A <a><code>Promise</code></a> object will be
            returned in order to notify the result of the request.
          </p>
          <p>
            When the <code>startTone</code> method is invoked, the user agent
            MUST run the following steps:
          </p>
          <ol id="steps-starttone">
            <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated
              <a><code>resolver</code></a>.
            </li>
            <li>If there is no <a>selected telephony service</a>, then invoke
              <var>resolver</var>'s <code>reject(value)</code> method with the
              <var>value</var> argument set to a new <code>DOMError</code> object
              whose name is set to <code>"NoModificationAllowedError"</code>, and
              terminate these steps.
            </li>
            <li>Return <var>promise</var> to the caller and continue the
              following steps asynchronously.
            </li>
            <li>If the platform does not support long press [[!DTMF]] tones or
            starting tones, then invoke
            <var>resolver</var>'s <code>reject(value)</code> method with the
            <var>value</var> argument set to a new <code>DOMError</code> object
            whose name is set to <code>"NotSuppoertedError"</code>, and
            terminate these steps. In
            this case applications may then use the <code>sendTones</code>
            method for sending [[!DTMF]].
            </li>
            <li>Request from the telephony system to start sending the
            specified tone. The tone SHOULD play until the
            <code>stopTone</code> method is called.
            </li>
            <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated
            <a><code>resolver</code></a>.
            </li>
            <li>Return <var>promise</var> to the caller and continue the
            following steps asynchronously.
            </li>
            <li>If the request to the telephony system is successful, or if
            the telephony system does not support feedback about the result of
            the request, invoke <var>resolver</var>'s <code>accept()</code>
            method with no arguments.
            </li>
            <li>If the request to the telephony system is unsuccessful, invoke
            <var>resolver</var>'s <code>reject()</code> method, with no
            arguments.
            </li>
          </ol>
        </section>

        <!-- - - - - - - - - - - -  stopTone()  - - - - - - - - - - - - - -->
        <section> <h3>The <code>stopTone()</code> method</h3>
          <p>
            The <dfn
            id="widl-ToneManager-stopTone-Promise-DOMString-serviceId">
            stopTone()</dfn>
            method stops emitting a [[!DTMF]] tone in the
            <a>selected telephony service</a>.
            When invoked, the user agent MUST run the following steps:
          </p>
          <ol id="steps-stoptone">
            <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated
              <a><code>resolver</code></a>.
            </li>
            <li>If there is no <a>selected telephony service</a>, then invoke
              <var>resolver</var>'s <code>reject(value)</code> method with the
              <var>value</var> argument set to a new <code>DOMError</code> object
              whose name is set to <code>"NoModificationAllowedError"</code>, and
              terminate these steps.
            </li>
            <li>Return <var>promise</var> to the caller and continue the
              following steps asynchronously.
            </li>
            <li>If the platform does not support long press [[!DTMF]] tones or
            starting tones, then invoke
            <var>resolver</var>'s <code>reject(value)</code> method with the
            <var>value</var> argument set to a new <code>DOMError</code> object
            whose name is set to <code>"NotSupportedError"</code>, and
            terminate these steps.
            </li>
            <li>Otherwise, request from the telephony system to stop sending
            the specified tone.
            </li>
            <li>If the request to the telephony system is successful, or if
            the telephony system does not support feedback about the result of
            the request, invoke <var>resolver</var>'s <code>accept()</code>
            method with no arguments.
            </li>
            <li>If the request to the telephony system is unsuccessful, invoke
            <var>resolver</var>'s <code>reject()</code> method, with no
            arguments.
            </li>
          </ol>
        </section> <!-- stopTone -->
      </section> <!-- ToneManager -->
    </section> <!-- Tone management -->

    <!-- - - - - - - - - - - -  Emergency numbers - - - - - - - - - - - - - -->
    <section> <h2>The <a>EmergencyManager</a> Interface</h2>
      <p>
        This interface provides access for reading emergency numbers from the
        available <a>telephony service</a>s.
      </p>
      <dl title="interface EmergencyManager" class="idl">
        <dt> // on success returns emergency numbers as sequence of DOMString
        <dt>Promise getEmergencyNumbers()</dt>
        <dt>attribute EventHandler onemergencynumberschanged</dt>
      </dl>
      <!-- - - - - - - - - - - EmergencyManager Event handlers  - - - - - - -->
      <section> <h2>Event handlers</h2>
      <p>
        The following are the <a>event handler</a>s implemented by the
        <a>EmergencyManager</a> interface.
      </p>
      <table class="simple">
        <tr>
          <th>event handler    </th>
          <th>event name       </th>
        </tr>
        <tr>
          <td>
            <dfn id="widl-EmergencyManager-onemergencynumberschanged">
                 <code>onemergencynumberschanged</code>
            </dfn>
          </td>
          <td>
            <dfn><code>emergencynumberschanged</code></dfn>
          </td>
        </tr>
      </table>
      <p>
        When emergency numbers have changed, the <code>changed</code> event of
        type <a><code>Event</code></a> MUST be fired at the object implementing
        this interface. The applications SHOULD read the emergency numbers
        by the <code>getEmergencyNumbers()</code> method.
      </p>
    </section>
    <section> <h3>The <code>getEmergencyNumbers()</code> method</h3>
      <p>
        When the <dfn id=
        "widl-EmergencyManager-getEmergencyNumbers-Promise">
        getEmergencyNumbers()</dfn>
        method is invoked, the user agent MUST run the following steps:
      </p>
      <ol id="steps-getemergencynumbers">
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
          object and <var>resolver</var> its associated resolver.
        </li>
        <li>Return <var>promise</var> and continue the following steps
          asynchronously.
        </li>
        <li> make a request to the underlying telephony system to provide the
          list of emergency numbers from the <a>selected telephony service</a>,
          and wait for response.
        </li>
        <li>If it's not possible to retrieve the list of telephony service
        identifiers for whatever reason: timeout, security, etc., then run the
        following sub-steps and terminate this algorithm:
          <ol>
            <li>Let <var>error</var> be a new DOMError object whose name is
            <code>"NoModificationAllowedError"</code>.
            </li>
            <li>Call <var>resolver</var>'s <code>reject(value)</code> method
            with <var>error</var> as the <var>value</var> argument.
            </li>
          </ol>
        </li>
        <li>Otherwise, combine the emergency numbers into a sequence of
          distinct <code>DOMString</code> strings, and <a>queue a task</a> to
          invoke <var>resolver</var>'s <code>accept(value)</code> method with
          the sequence of emergency numbers in the current geographical area,
          as the <var>value</var> argument. The list can be empty.
        </li>
      </ol>
      </p>
    </section>
    </section> <!-- Emergency numbers -->

    <!-- - - - - - - - - - - - Security and privacy - - - - - - - - - - - - -->
    <section> <h2>Security and privacy considerations</h2>
      <div class="issue">
        <p>
          To be improved. See <a href=
          "https://github.com/sysapps/telephony/issues/26">bug 26</a>.
        </p>
      </div>
      <p>
        This API provides access to a potentially dangerous and valuable
        feature of a device. As a result, misuse of the API would have a large
        cost to users and other system stakeholders. This API should,
        therefore, not be implemented without careful consideration of security
        and privacy issues.
      </p>
      <p>
        This section provides a limited overview of security and privacy
        considerations relevant for this API. It includes a set of threats to
        users and other stakeholders, as well as requirements for mitigating
        them.
      </p>
      <p>
        However, this section cannot cover all of the potential threats, nor
        can it reflect the context in which a conformant implementation may be
        operating. As a result, this security section should be considered only
        the starting point for implementers.
      </p>
      <!-- - - - - - - - - - - - Threats  - - - - - - - - - - - - - - - - - -->
      <section> <h3>Threats</h3>
        <p>
          The following list of threats should be considered by the
          implementer. Note that these are not given in any order.
        </p>
        <ul>
          <li>The API could be used by a malicious application to deny other
          system applications access to the device's telephony services,
          creating an availability problem. This is a safety, as well as
          security, concern.
          </li>
          <li>The API could be used by a malicious application as part of a
          distributed denial of service attack, making frequent calls to a
          remote call system such as an emergency response number.
          </li>
          <li>The API could be used by an application to list the telephone
          numbers that the end user has called and is, at any time, calling.
          This information ought to be considered private, and could also be
          used as part of a social engineering attack, or for identity theft.
          </li>
          <li>The API could be used to make unwanted calls to premium-rate
          telephone numbers. A malicious application could use this to earn
          money at the user's expense. Similarly, this API could be misused to
          enroll the user into a premium-rate calling service, which would then
          charge the end user when calls are received.
          </li>
          <li>The API could be used to make unwanted advertising calls, in a
          similar manner to spam email campaigns. When combined with access to
          the user's contact list, this would be both expensive and embarassing
          for the user, and could result in their telephony service being
          terminated by the network operator.
          </li>
          <li>The API could be used by a malicious application to make
          telephone calls impersonating the end user, or as part of a process
          to defeat a two-factor authentication system.
          </li>
          <li>A poorly implemented application could misuse this API to make
          unnecessary or unexpected calls, costing the user money or
          embarassing them.
          </li>
          <li>This API could be used to call a number other than the one that
          the user was expecting, routing calls to an unknown
          man-in-the-middle. This could be used to eavesdrop on the user. When
          used in combination with recordings from the microphone, this API
          could be used to covertly survey the end user.
          </li>
          <li>This API could be used to send USSD messages to the service
          provider and invoke functions such as wiping the handset or accessing
          security settings.
          </li>
          <li>The API could be misused to access the user's voicemail
          recordings.
          </li>
          <li>The API could be misused as part of a DDoS attack on an operator
          or service provider, flooding the network with calls at certain
          times.
          </li>
          <li>The API could cost the end user money by making outgoing calls
          when the user is roaming, or on an expensive network.
          </li>
        </ul>
      </section><!-- threats -->
      <!-- - - - - - - - - - - - Mitigations  - - - - - - - - - - - - - - - -->
      <section> <h3>Mitigations</h3>
        <p>
          The following mechanisms may be employed to help an implementer
          mitigate the threats outlined in the previous section.
        </p>
        <ul>
          <li>The user agent should only expose this API to <em>privileged</em>
          applications, as defined in the <a href=
          "http://www.w3.org/TR/runtime/">Runtime and Security Model</a>.
          </li>
          <li>The user agent should only expose this API to applications which
          were distributed by an institution that the handset recognises as a
          valid source. For example, the API might only be accessible to
          applications distributed by the handset manufacturer.
          </li>
          <li>All applications with access to this API should be reviewed
          before they are made available. A mechanism for remote update of
          applications with access to this API should be provided to allow for
          identified security issues to be fixed.
          </li>
          <li>The user agent should maintain the integrity of any application
          with access to this API when initially downloaded, as well as when it
          is stored offline.
          </li>
          <li>The user agent should only expose this API to downloaded, offline
          applications which are not modifiable by external web servers. A
          restrictive content security policy should be used to enforce that
          application with external content (such as scripts) cannot access
          this API.
          </li>
          <li>The API implementation should have different behaviour when used
          with premium-rate numbers. Accessing premium-rate numbers may require
          an additional permission to be listed in the manifest, a different
          (or additional) warning to be displayed to users, or place an
          additional requirement on the valid distributors of the application.
          It is up to the implementing user agent to identify whether a remote
          party identifier is premium-rate or not.
          </li>
          <li>The API implementation should have different behaviour when the
          user is roaming on a network with a different (less favourable)
          service-level agreement. For example, presenting a different warning
          to the user, or denying access to this API from certain applications
          altogether.
          </li>
          <li>User consent must be captured when a call is made. For example,
          the user must press a 'dial' button, or equivalent, before the call
          is placed. The user must also be shown the recipients of the call,
          and the numbers that have and will be dialled as part of placing it.
          </li>
          <li>It should be obvious, visually, when a call is being invoked, is
          in progress, and has ended. This should be visible to the end user
          and it must not be possible for applications to hide or obscure this
          indicator.
          </li>
          <li>The user agent should introduce rate limiting to prevent an
          application from making too many calls in too short a period of time.
          </li>
        </ul>
      </section><!-- Mitigations -->

      <!-- - - - - - - - - - - - User interaction guidelines  - - - - - - - -->
      <section> <h2>User interaction guidelines</h2>
        <p>
          Implementations SHOULD make sure the phone calls are controllable by
          the user at any point in time while the call is active.
        </p>
      </section><!-- User interaction guidelines -->
    </section><!-- Security and privacy -->

    <!-- - - - - - - - - - -  Managing Call History   - - - - - - - - - - - -->
    <section class="appendix"> <h2>Managing call history</h2>
      <p>
        The <a>CallHistoryEntry</a> interface describes the minimum set of
        properties which a user agent would need to support for call history
        entries. For conference call there needs to be a separate
        <a>CallHistoryEntry</a> object for each call participant, sharing the
        same value for the <a>conferenceId</a> attribute.
      </p>
      <p class='note'>
        It is up the the implementations and applications how to store and
        access call history. This document only specifies the minimum content
        of the data to be saved.
      </p>
      <!-- - - - - - - - - - - CallHistoryEntry Interface - - - - - - - - - -->
      <section> <h3><code>CallHistoryEntry</code> interface</h3>
        <dl title="interface CallHistoryEntry" class="idl">
          <dt> readonly attribute DOMString          remoteParty      </dt>
          <dt> readonly attribute Date               startTime        </dt>
          <dt> readonly attribute unsigned long long duration         </dt>
          <dt> readonly attribute CallDirection      direction        </dt>
          <dt> readonly attribute DisconnectReason?  disconnectReason </dt>
          <dt> readonly attribute boolean            conference       </dt>
          <dt> readonly attribute boolean            emergency        </dt>
          <dt> readonly attribute DOMString          serviceName      </dt>
        </dl>
        <!-- - - - - - - - - - -  remoteParty attribute - - - - - - - - - - -->
        <section> <h3>The <code>remoteParty</code> attribute</h3>
          <p>
            When getting the <code>remoteParty</code> attribute, the
            user agent MUST return the <a>remote party id</a> (e.g. telephone
            number) of the call participant.
          </p>
        </section><!-- remoteParty attribute -->
        <!-- - - - - - - - - - - startTime attribute  - - - - - - - - - - - -->
        <section> <h3>The <code>startTime</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-startTime">startTime</dfn> attribute, the user
            agent MUST return the starting time of the call, measured from when
            the call is in <a>active</a> state.
          </p>
        </section><!-- startTime attribute -->
        <!-- - - - - - - - - - -  duration attribute  - - - - - - - - - - - -->
        <section> <h3>The <code>duration</code> attribute </h3>
          <p>
            When getting the <dfn id="CallHistoryEntry-duration">duration</dfn>
            attribute, the user agent MUST return the duration of the call
            expressed in milliseconds.
          </p>
        </section><!-- duration attribute -->
        <!-- - - - - - - - - - -  CallDirection attribute - - - - - - - - - -->
        <section> <h3>The <code>direction</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-direction">direction</dfn> attribute, the user
            agent MUST return the <a>CallDirection</a>.
          </p>
        </section><!-- CallDirection attribute -->
        <!-- - - - - - - - - - - disconnectReason attribute  - - - -  - - - -->
        <section> <h3>The <code>disconnectReason</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-disconnectReason">disconnectReason</dfn>
            attribute, the user agent MUST return the <a>DisconnectReason</a>
            if available, or return <code>null</code> otherwise.
          </p>
        </section><!-- disconnectReason attribute -->
        <!-- - - - - - - - - - -   emergency attribute  - - - - - - - - - - -->
        <section> <h3>The <code>emergency</code> attribute</h3>
          <p>
            When getting the <dfn id=
            "CallHistoryEntry-emergency">emergency</dfn> attribute, the user
            agent MUST return <code>true</code> if the call was an emergency
            call, or <code>false</code> otherwise.
          </p>
        </section><!-- emergency attribute -->
        <!-- - - - - - - - - - -  conference attribute  - - - - - - - - - -->
        <section> <h3>The <code>conference</code> attribute</h3>
          <p>
            When getting the <code>conference</code> attribute, the
            user agent MUST return the <code>true</code> if the
            call has participated in a conference call. Otherwise, return
            <code>false</code>.
          </p>
        </section><!-- conference attribute -->
        <!-- - - - - - - - - -  serviceName attribute - - - - - - - - - - - -->
        <section> <h3>The <code>serviceName</code> attribute</h3>
          <p>
            When getting the <code>serviceName</code> attribute, the user
            agent MUST return the name of the <a>telephony service</a>
            used for the call.
          </p>
        </section><!-- serviceId attribute -->
      </section><!-- CallHistoryEntry Interface-->
      <!-- - - - - - - - - - -  CallDirection Enum  - - - - - - - - - - - - -->
      <section> <h2><a>CallDirection</a> enum</h2>
        <dl class="idl" title="enum CallDirection">
          <dt>dialed</dt>
          <dt>received</dt>
          <dt>missed</dt>
          <dt>missed-new</dt>
        </dl>
        <p>The <dfn>call direction</dfn> can take the following values:</p>
        <dl>
          <dt>"dialed"</dt>
          <dd>The call has been dialed.</dd>

          <dt>"received"</dt>
          <dd>The call has been received.</dd>

          <dt>"missed"</dt>
          <dd>The call has been missed.</dd>

          <dt>"missed-new"</dt>
          <dd>The call was a missed call not seen yet by the user.</dd>
        </dl>
      </section><!-- CallDirection Enum -->
    </section><!-- Managing Call History -->

    <!-- - - - - - - - - - - - - -  Telephony Services  - - - - - - - - - - -->
    <section  class="informative"> <h2>Telephony services</h2>
      <!-- - - - - - - - -  ServiceManager WebIDL definitions - - - - - - - -->
      <section> <h2>The <a>ServiceManager</a> Interface</h2>
        <p>
          The <a>ServiceManager</a> interface manages the state of the
          <a>TelephonyService</a> objects.
        </p>
        <dl title="interface ServiceManager : EventTarget" class="idl">
          <dt> readonly attribute TelephonyService? selectedService    </dt>
          <dt> Promise selectService(DOMString serviceId)              </dt>
          <dt> Promise getServices()                                   </dt>
          <dt> attribute EventHandler onserviceadded                   </dt>
          <dt> attribute EventHandler onserviceremoved                 </dt>
          <dt> attribute EventHandler onservicechanged                 </dt>
          <dt> attribute EventHandler onselectedservicechanged         </dt>
        </dl>

      <!-- - - - - - - - - - - ServiceManager Event handlers  - - - - - - - -->
      <section> <h2>Event handlers</h2>
        <p>
          The following are the <a>event handler</a>s implemented by the
          <a>ServiceManager</a> interface.
        </p>
        <table class="simple">
          <tr>
            <th>event handler    </th>
            <th>event name       </th>
            <th>event type       </th>
            <th>short description</th>
          </tr>
          <tr>
            <td><dfn id="widl-ServiceManager-onserviceadded">
                   <code>onserviceadded</code></dfn>
            </td>
            <td><dfn><code>serviceadded</code></dfn></td>
            <td><a>TelephonyServiceEvent</a></td>
            <td>handles a new enabled telephony service.</td>
          </tr>
          <tr>
            <td> <dfn id="widl-ServiceManager-onserviceremoved">
                   <code>onserviceremoved</code></dfn>
            </td>
            <td><dfn><code>serviceremoved</code></dfn></td>
            <td><a>TelephonyServiceEvent</a></td>
            <td>handles a disabled telephony service.</td>
          </tr>
          <tr>
            <td> <dfn id="widl-ServiceManager-onservicechanged">
                   <code>onservicechanged</code></dfn>
            </td>
            <td><dfn><code>servicechanged</code></dfn></td>
            <td><a>TelephonyServiceChangeEvent</a></td>
            <td>handles a changed telephony service.</td>
          </tr>
          <tr>
            <td><dfn id="widl-ServiceManager-onselectedservicechanged">
                   <code>onselectedservicechanged</code></dfn>
            </td>
            <td><dfn><code>selectedservicechanged</code></dfn></td>
            <td><a>TelephonyServiceEvent</a></td>
            <td>handles the change of selected telephony service.</td>
          </tr>
        </table>
      </section>

      <!-- - - - - - - - -  Telephony service changes - - - - - - - - - - - -->
      <section> <h3>Handling events for changes in telephony services</h3>
        <p>
          Telephony services can be added or removed from the system at any
          time (e.g., the user pops out the SIM card or adds a different SIM
          card; the user tells the system to only allow certain applications to
          access a particular telephony service, etc.).
        </p>
        <p>
          The functionality related to managing telephony services is described
          in the <a><code>ServiceManager</code></a> interface.
          <a><code>TelephonyManager</code></a> implements the the
          <a><code>ServiceManager</code></a> interface.
        </p>
        <p>
          When a <a>telephony service</a> is either added or removed in the
          system, or the <a>selected telephony service</a> is changed, the user
          agent MUST run the next steps to change the telephony service:
        </p>
        <ol id="steps-ServiceManager-change-events">
          <li>Let <var>event</var> be a new <a>TelephonyServiceEvent</a>, with
          the event name set to <code>serviceremoved</code> if the telephony
          service was removed, or <code>serviceadded</code> if it was added, or
          <code>selectedservicechanged</code> if the
          <a>selected telephony service</a> has changed. Or, if a telephony
          service has changed, let <var>event</var> be a new
          <a>TelephonyServiceChangeEvent</a>, with
          the event name set to <code>servicechanged</code>.
          This event does not bubble, is not cancelable, has no default action,
          and its <code>serviceId</code> attribute is set to the
          <a>telephony service id</a> of the <a>telephony service</a> that
          initiated this algorithm.
          </li>
          <li>If the service has been removed and it's been the selected
          telephony service for the <a>origin</a>, then change
          <a>selected telephony service</a> to <code>null</code> and
          <a>queue a task</a> to fire a <var>selectedservicechange</var>
          event at the <a>ServiceManager</a> object(s).
          </li>
          <li>
            <a>Queue a task</a> to fire an event <var>event</var> at the
            <a>TelephonyManager</a>.
          </li>
        </ol>
        <p class="issue">
          Note that compliant implementations may not be reporting events
          exactly when they occur, and the implementations may have to poll
          for these (e.g. OTA SIM update or hot-swappable SIM cards). See
          <a href="https://github.com/sysapps/telephony/issues/127">issue
          127</a>.
        </p>
      </section>

      <!-- - - - - - - - - -  Selected Telephony Service - - - - - - - - - -->
      <section> <h3>The <a><code>selectedService</code></a> property</h3>
        <p>
          When getting the <dfn id=
          "widl-ServiceManager-selectedService">selectedService</dfn>
          attribute, the user agent MUST return the
          <code>TelephonyService</code> object that
          represents the <a>selected telephony service</a>, or
          return <code>null</code> if it is not available.
        </p>
      </section>

      <!-- - - - - - - - - Selecting TelephonyService - - - - - - -->
      <section> <h3>The <code>selectService()</code> method</h3>
        <p>
          The <dfn id=
          "widl-ServiceManager-selectService-Promise-DOMString-serviceId">
          selectService()</dfn> method provides a means to change the
          <a>selected telephony service</a> used by the user agent. When
          invoked, the user agent MUST run the the following steps:
        </p>
        <ol id="steps-set-selected-service">
          <li>Let <var>serviceId</var> be the first argument passed to
          this operation.
          </li>
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
          object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
          asynchronously.
          </li>
          <li>If <var>serviceId</var> does not exactly match the identifier of
          any <a>telephony service</a> known to the user agent,run the following
          error steps and terminate this algorithm:
            <ol id="steps-promise-error">
              <li>Let <var>error</var> be a new <a href=
              "http://dom.spec.whatwg.org/#domerror"><code>DOMError</code></a>
              object whose name is <a href=
              "http://dom.spec.whatwg.org/#notfounderror">
              <code>NotFoundError</code></a>.
              </li>
              <li>Invoke <var>resolver</var>'s reject(value) method with <var>
                error</var> as the value argument.
              </li>
            </ol>
          </li>
          <li>If <var>serviceId</var> exactly matches the
            <a>telephony service id</a> of the current
            <a>selected telephony service</a>, invoke <var>resolver</var>'s
            accept() method and terminate these steps.
          </li>
          <li>Otherwise, make a request to the underlying system to change from
          the currently selected telephony service to the one identified by
          <var>serviceId</var>.
          </li>
          <li>Wait for response from the underlying system.
          </li>
          <li>If it's not possible to change the selected telephony service for
          whatever reason: timeout, security, etc., then run the following
          sub-steps and terminate this algorithm:
            <ol>
              <li>Let <var>error</var> be a new DOMError object whose name is
              <code>"NoModificationAllowedError"</code>.
              </li>
              <li>Call <var>resolver</var>'s <code>reject(value)</code> method
              with <var>error</var> as the <var>value</var> argument.
              </li>
            </ol>
          </li>
          <li>Otherwise, <a>queue a task</a> to:
            <ol>
              <li>Change the <a>selectedService</a> attribute to the
              <a>telephony service</a> of the new
              <a>selected telephony service</a>.
              </li>
              <li>invoke <var>resolver</var>'s <code>accept()</code> method.
              </li>
              <li>
                <a>Fire an event</a> named <code>selectedservicechanged</code>
                at the <code><a>ServiceManager</a></code> object(s).
              </li>
            </ol>
          </li>
        </ol>
      </section> <!-- selectService -->

      <!-- - - - - - - - - - - - getServices() - - - - - - - - - - - - - - -->
      <section> <h3>The <code>getServices()</code> method</h3>
        <p>
          The <dfn id="widl-ServiceManager-getServices-Promise">
          getServices()</dfn> method provides a means to retrieve the
          list of <a>telephony service id</a>s representing enabled
          <a>telephony service</a>s. When invoked, the user agent MUST run the
          following steps:
        </p>
        <ol id="steps-get-services">
          <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
            object and <var>resolver</var> its associated resolver.
          </li>
          <li>Return <var>promise</var> and continue the following steps
            asynchronously.
          </li>
          <li>Make a request to the underlying system to retrieve the list of
           available <a>telephony service</a>s.
          </li>
          <li>Wait for response from the underlying system.
          </li>
          <li>If it's not possible to retrieve the list of telephony services
          for whatever reason: timeout, security, etc., then run the
          following sub-steps and terminate this algorithm:
            <ol>
              <li>Let <var>error</var> be a new DOMError object whose name is
              <code>"NoModificationAllowedError"</code>.
              </li>
              <li>Call <var>resolver</var>'s <code>reject(value)</code> method
              with <var>error</var> as the <var>value</var> argument.
              </li>
            </ol>
          </li>
          <li>Otherwise, <a>queue a task</a> to invoke <var>resolver</var>'s
            <code>accept(value)</code> method with the sequence of
            <code><a>TelephonyService</a></code> objects as
            <var>value</var> argument, even if the list is empty.
          </li>
        </ol>
      </section> <!-- getServices -->
      </section> <!-- ServiceManager -->

      <!-- - - - - - - - - - Interface TelephonyServiceEvent  - - - - - - - -->
      <section> <h2>The <a>TelephonyServiceEvent</a> Interface</h2>
        <p>
          Defines a telephony event for notifying about a new or removed
          <a>telephony service</a>.
        </p>
        <dl title="interface TelephonyServiceEvent : Event"
        class="idl">
          <dt>readonly attribute TelephonyService service</dt>
        </dl>
        <!-- - - - - - - - - - service attribute  - - - - - - - - - - - - -->
        <section>
          <h3>The <code>service</code> attribute</h3>
          <p>
            When getting the <code>service</code>, the user
            agent MUST return the <code><a>TelephonyService</a></code> object
            representing the <a>telephony service</a> that triggered the event.
          </p>
        </section>
      </section><!-- interface TelephonyServiceEvent -->

      <!-- - - - - - - Interface TelephonyServiceChangeEvent  - - - - - - - -->
      <section> <h2>The <a>TelephonyServiceChangeEvent</a> Interface</h2>
        <p>
          Defines a telephony event for notifying about a changed
          <a>telephony service</a>.
        </p>
        <dl title="TelephonyServiceChangeEvent implements TelephonyService"
          class="idl"></dl>
        <dl title="interface TelephonyServiceChangeEvent" class="idl">
          <dt>readonly attribute DOMString[] changedProperties</dt>
        </dl>
        <!-- - - - - - - - changedProperties attribute  - - - - - - - - - - -->
        <section>
          <h3>The <code>changedProperties</code> attribute</h3>
          <p>
            When getting the <code>changedProperties</code>, the user
            agent MUST return the sequence of property names of the
            <code><a>TelephonyService</a></code> object <var>service</var>,
            whose value has been changed.
          </p>
        </section>
      </section><!-- interface TelephonyServiceChangeEvent -->


      <!-- - - - - - - - -  Interface TelephonyProvider - - - - - - - - - - -->
      <section class="informative">
      <h2>The <a>TelephonyProvider</a> Interface</h2>
        <p>The interface which represents <a>telephony provider</a>s present
          in the system.
        </p>
        <dl title="[NoInterfaceObject] interface TelephonyProvider" class="idl">
          <dt>         attribute DOMString             name              </dt>
          <dt>readonly attribute RegistrationMode?     registrationMode  </dt>
          <dt>readonly attribute TelephonyTechnology   technology        </dt>
          <dt>readonly attribute TelephonyTechnology[] technologies      </dt>
          <dt>readonly attribute double                signalStrength    </dt>
          <dt>readonly attribute double                dataStrength      </dt>
          <dt>readonly attribute DOMString?            mobileNetworkCode </dt>
          <dt>readonly attribute DOMString?            mobileCountryCode </dt>
          <dt>readonly attribute DOMString?            locationAreaCode  </dt>
        </dl>

        <section> <h3>The <code>name</code> property</h3>
          <p>
            It MUST return the name of the <a>telephony provider</a>.
          </p>
        </section>

        <!-- - - - - - - TelephonyProvider.registrationMode - - - - - - - - -->
        <section> <h3>The <code>registrationMode</code> property</h3>
          <p>
            It MUST return the registration mode used by the
            <a>telephony provider</a>.
            The following values are supported:
            <ul>
              <li><code>"manual"</code>: manual registration</li>
              <li><code>"auto"</code>: automatic registration</li>
            </ul>
          </p>
          <dl title="enum TelephonyTechnology" class="idl">
            <dt>"manual"</dt>
            <dt>"auto"</dt>
          </dl>
        </section> <!-- registrationMode -->

        <!-- - - - - - - - TelephonyProvider.technology - - - - - - - - - - -->
        <section> <h3>The <code></code> property</h3>
          <p>
            It MUST return the current technology used by the
            <a>telephony provider</a>, if available, otherwise <code>null</code>.
            The following values are supported as telephony technologies:
            <ul>
              <li><code>"gsm"</code>: used for GSM protocols</li>
              <li><code>"cdma"</code>: used for CDMA and related protocols</li>
              <li><code>"edge"</code>: used for EDGE protocol</li>
              <li><code>"umts"</code>: used for UMTS protocols</li>
              <li><code>"hspa"</code>: used for HSPA and HSPA+ protocols</li>
              <li><code>"lte"</code>: used for LTE protocols</li>
            </ul>
          </p>
          <dl title="enum TelephonyTechnology" class="idl">
            <dt>gsm</dt>
            <dt>cdma</dt>
            <dt>edge</dt>
            <dt>umts</dt>
            <dt>hspa</dt>
            <dt>lte</dt>
          </dl>
        </section> <!-- technology -->

        <!-- - - - - - - - TelephonyProvider.technologies - - - - - - - - - -->
        <section> <h3>The <code>technologies</code> property</h3>
          <p>
            It MUST return the list of supported technologies of the
            <a>telephony provider</a>.
          </p>
        </section> <!-- technologies -->

        <!-- - - - - - - TelephonyProvider.signalStrength - - - - - - - - - -->
        <section> <h3>The <code>signalStrength</code> property</h3>
          <p>
            It MUST return the current radio signal strength with the
            <a>telephony provider</a> as a number scaled between 0 (no signal)
            and 1.0 (maximum).
          </p>
        </section> <!-- signalStrength -->

        <!-- - - - - - - TelephonyProvider.dataStrength - - - - - - - - - -->
        <section> <h3>The <code>dataStrength</code> property</h3>
          <p>
            It MUST return the current radio signal strength of the High Data
            Rate network if the provider is a CDMA network, as a value between
            0 (no signal) and 1 (full strength), or 0 if not available.
          </p>
        </section> <!-- dataStrength -->

        <!-- - - - - - - TelephonyProvider.mobileNetworkCode  - - - - - - - -->
        <section> <h3>The <code></code> property</h3>
          <p>
            It MUST return the Mobile Network Code of the
            <a>telephony provider</a>, if available, otherwise <code>null</code>.
          </p>
        </section> <!-- mobileNetworkCode -->

        <!-- - - - - - - TelephonyProvider.mobileCountryCode  - - - - - - - -->
        <section> <h3>The <code></code> property</h3>
          <p>
            It MUST return the Mobile Country Code of the
            <a>telephony provider</a>, if available, otherwise <code>null</code>.
          </p>
        </section> <!-- mobileCountryCode -->

        <!-- - - - - - - TelephonyProvider.locationAreaCode - - - - - - - - -->
        <section> <h3>The <code></code> property</h3>
          <p>
            It MUST return the Location Area Code of the
            <a>telephony provider</a>, if available, otherwise <code>null</code>.
          </p>
        </section> <!-- locationAreaCode -->

      </section> <!-- TelephonyProvider -->

      <!-- - - - - - - - - - Interface TelephonyService - - - - - - - - - - -->
      <section class="informative">
      <h2>The <a>TelephonyService</a> Interface</h2>
        <p>The interface which manages a given <a>telephony service</a>s present
          in the system. Different services may provide different set of
          interfaces for managing service specific settings, depending on
          protocol and the current telephony network to which the device is
          connected.
        </p>
        <dl title="[NoInterfaceObject]
          interface TelephonyService: EventHandler"
          class="idl">
          <dt>         attribute DOMString            name          </dt>
          <dt>readonly attribute DOMString            serviceId     </dt>
          <dt>readonly attribute TelephonyServiceType serviceType   </dt>
          <dt>readonly attribute boolean              enabled       </dt>
          <dt>readonly attribute boolean              emergencyMode </dt>
          <dt>readonly attribute TelephonyProvider    provider      </dt>
          <dt>Promise setEnabled(boolean enabled)                   </dt>
          <dt>Promise getProviders()                                </dt>
          <dt>Promise selectProvider(TelephonyProvider provider)    </dt>
        </dl>

        <!-- - - - - - - - - TelephonyService.serviceId - - - - - - - - - - -->
        <section> <h3>The <code>serviceId</code> property</h3>
          <p>
            It MUST return the <a>telephony service id</a> of the
            <a>telephony service</a>.
          </p>
        </section> <!--serviceId -->

        <!-- - - - - - - - - TelephonyService.enabled - - - - - - - - - - - -->
        <section> <h3>The <code>enabled</code> property</h3>
          <p>
            It MUST return or set the enabled state of the service, i.e.
            <code>true</code> if the service is enabled, and <code>false</code>
            if the service is disabled.
          </p>
        </section> <!-- enabled -->

        <!-- - - - - - - - - TelephonyService.emergencyMode - - - - - - - - -->
        <section> <h3>The <code>emergencyMode</code> property</h3>
          <p>
            It MUST return <code>true</code> if the service is in             emergency mode, i.e. an emergency call is in progress,
            and <code>false</code> otherwise.
          </p>
        </section> <!-- emergencyMode -->

        <!-- - - - - - - - -  TelephonyService.name - - - - - - - - - - - - -->
        <section> <h3>The <code>displayName</code> property</h3>
          <p>
            It MUST return the string value as displayed to the user by the
            application. It MAY be a localization string identifier.
          </p>
        </section> <!-- name -->

        <!-- - - - - - - - - TelephonyService.provider  - - - - - - - - - - -->
        <section> <h3>The <code>provider</code> property</h3>
          <p>
            It MUST return the <code><a>TelephonyProvider</a></code> object
            selected for the telephony service.
          </p>
        </section> <!-- provider -->

        <!-- - - - - - - - - TelephonyService.serviceType - - - - - - - - - -->
        <section> <h3>The <code>serviceType</code> property</h3>
          <p>
            The following values are supported as <a>telephony service</a> type:
            <ul>
              <li><code>"unknown"</code>: service type not known</li>
              <li><code>"hw"</code>: hardware modem</li>
              <li><code>"hfp"</code>: external modem used through Bluetooth
                Hands Free Profile (for control and also handles audio)
              </li>
              <li><code>"sap"</code>: external modem used through Bluetooth SIM
                Access Profile (only for control, audio is local)
              </li>
              <li><code>"sw"</code>: software modem.</li>
          </p>
          <dl title="enum TelephonyServiceType" class="idl">
            <dt>unknown</dt>
            <dt>hw</dt>
            <dt>hfp</dt>
            <dt>sap</dt>
            <dt>sw</dt>
          </dl>
        </section> <!-- serviceType -->

        <!-- - - - - - - - - TelephonyService.setEnabled()  - - - - - - - - -->
        <section> <h3>The <code>setEnabled()</code> method</h3>
          <p>
            The <dfn
            id="widl-TelephonyService-setEnabled-Promise-boolean-enabled">
            setEnabled()</dfn> method enables or disabled the
            <a>telephony service </a>. When invoked, the user agent MUST run the
            following steps:
          </p>
          <ol id="steps-telephonyservice-setenabled">
            <li>Let <var>enabled</var> be the first argument passed to
              this operation.
            </li>
            <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated resolver.
            </li>
            <li>Return <var>promise</var> and continue the following steps
              asynchronously.
            </li>
            <li>Make a request to the underlying system to enable the
              <a>telephony service</a> if <var>enabled</var> is
              <code>true</code>, and disable it otherwise.
            </li>
            <li>Wait for response from the underlying system.
            </li>
            <li>If it was not possible to complete the request for whatever
              reason: timeout, security, etc., then run the following sub-steps
              and terminate this algorithm:
              <ol>
                <li>Let <var>error</var> be a new DOMError object whose name is
                <code>"NoModificationAllowedError"</code>.
                </li>
                <li>Call <var>resolver</var>'s <code>reject(value)</code> method
                with <var>error</var> as the <var>value</var> argument.
                </li>
              </ol>
            </li>
            <li>Otherwise, when the request has been completed,
              <a>queue a task</a> to invoke <var>resolver</var>'s
              <code>accept()</code> method. Parallel to this, implementations
              MUST also follow the
              <a href="steps-servicemanager-change-events">steps</a> for
              handling service change events.
            </li>
          </ol>
        </section> <!-- setEnabled() -->

        <!-- - - - - - - TelephonyService.selectProvider()  - - - - - - - - -->
        <section> <h3>The <code>selectProvider()</code> method</h3>
          <p>
            The <dfn
            id="widl-TelephonyService-selectProvider-Promise-TelephonyProvider-provider">
            selectProvider()</dfn> method registers with the selected provider
            (network operator). When invoked, the user agent MUST run the
            following steps:
          </p>
          <ol id="steps-telephonyservice-selectprovider">
            <li>Let <var>provider</var> be the first argument passed to
              this operation.
            </li>
            <li>Let <var>promise</var> be a new <a><code>Promise</code></a>
              object and <var>resolver</var> its associated resolver.
            </li>
            <li>Return <var>promise</var> and continue the following steps
              asynchronously.
            </li>
            <li>Make a request to the underlying system to register with the
              <a>telephony provider</a> represented by <var>provider</var>.
            </li>
            <li>Wait for response from the underlying system.
            </li>
            <li>If it was not possible to complete the request for whatever
              reason: timeout, security, etc., then run the following sub-steps
              and terminate this algorithm:
              <ol>
                <li>Let <var>error</var> be a new DOMError object whose name is
                <code>"NoModificationAllowedError"</code>.
                </li>
                <li>Call <var>resolver</var>'s <code>reject(value)</code> method
                with <var>error</var> as the <var>value</var> argument.
                </li>
              </ol>
            </li>
            <li>Otherwise, when the request has been completed,
              <a>queue a task</a> to invoke <var>resolver</var>'s
              <code>accept()</code> method. Parallel to this, implementations
              MUST also follow the
              <a href="steps-servicemanager-change-events">steps</a> for
              handling service change events.
            </li>
          </ol>
        </section> <!-- selectProvider() -->

        <!-- - - - - - - - TelephonyService extension note  - - - - - - - - -->
        <section> <h3>Extension possibilities</h3>
        <section class="note">
          <p>
            In the future, <a>TelephonyService</a> could be extended e.g. in
            the following way:
          </p>
          <dl title="CellularService implements TelephonyService" class="idl">
          </dl>
          <dl title="[NoInterfaceObject]
          interface CellularService" class="idl">
          <dt>readonly attribute SimInfo?               simInfo     </dt>
          <dt>readonly attribute SimSettings?           simSettings </dt>
          <dt>readonly attribute CallForwarding?        forwarding  </dt>
          <dt>readonly attribute CallBarring?           barring     </dt>
          <dt>readonly attribute CallMeters?            meters      </dt>
          <dt>readonly attribute SupplementaryServices? ss          </dt>
          <dt>//... and other interfaces...                         </dt>
          </dl>
          <p>Depending on implementation, on operator network support and on
          settings, some of these interfaces may not be available, in which case
          the value of the corresponding attributes is set to <code>null</code>.
          </p>
        </section> <!-- note -->
        </section> <!-- extensions -->
      </section> <!-- TelephonyService -->
    </section> <!-- Telephony services -->


    <!-- - - - - - - - - - - - - -  Changes - - - - - - - - - - - - - - - - -->
    <section class="appendix" id="Changes">
      <h2>
        Changes
      </h2>
      <p>
        The following is a list of substantial changes to the document. For a
        complete list of changes, see the <a href=
        "https://github.com/sysapps/telephony/commits/gh-pages">change log on
        Github</a>. You can also view the <a href=
        "https://github.com/sysapps/telephony/issues?page=1&amp;state=closed">
        recently closed bugs</a>.
      </p>
      <ul>
        <li>Separation of TelephonyService functionality into
          <code>navigator.telephony.service</code> object, in order to keep
          <code>navigator.telephony</code> compatible with earlier versions.
        </li>
        <li>Added the TelephonyProvider abstraction.</li>
        <li>Using TelephonyCall objects to control normal, multiparty and
          3-way calls.
        </li>
      </ul>
    </section>
    <!-- - - - - - - - - - - - - - Acknowledgements - - - - - - - - - - - - -->
    <section>
      <h2>
        Acknowledgements
      </h2>
      <p>
        The editors would like to express their gratitude to the Mozilla B2G
        Team for their technical guidance, implementation work and support,
        especially to Ben Turner and Jonas Sicking, the authors of the
        <cite><a href="https://wiki.mozilla.org/WebAPI/WebTelephony">B2G
        WebTelephony API</a></cite>. Also, thanks to Denis Kenzior
        (<cite><a href="https://ofono.org/">ofono</a></cite> maintainer) and
        Oleg Zhurakivskyy of Intel Open Source Technology Center, and many
        others for their advice and support.
      </p>
    </section>
  </body>
</html>

<!--
For conference issues, see also:

GSM
===

GSM TS 04.08 call control states
GSM TS 04.83 call hold states
GSM TS 04.80 error values
GSM TS 24.084 Phase-4 MPTY
GSM TS 23.018 Basic call handling; Technical realization
      http://www.3gpp.org/ftp/Specs/html-info/23018.htm
IMS TS 23.228 IP Multimedia Subsystem (IMS); Stage 2
      http://www.3gpp.org/ftp/Specs/html-info/23228.htm

- any call ID will serve as a transaction ID
- implementation to generate a MPTY_ID which refers to the list of all active
call ID's in the mpty call

CDMA
====

http://www.scribd.com/doc/7029977/Network-Inter-Working-Between-GSM-MAP-and-ANSI41-CDMA

http://support.verizonwireless.com/support/faqs/FeaturesandOptionalServices/faq_3-way_calling.html
-->
